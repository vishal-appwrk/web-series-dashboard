{"ast":null,"code":"!function (e) {\n  \"object\" == typeof module && \"undefined\" != typeof module.exports ? module.exports = e : e();\n}(function () {\n  (window.webpackJsonpFusionCharts = window.webpackJsonpFusionCharts || []).push([[13], {\n    1106: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t.Maps = undefined;\n      var r,\n          a = o(1107),\n          i = (r = a) && r.__esModule ? r : {\n        \"default\": r\n      };\n      t.Maps = i[\"default\"], t[\"default\"] = {\n        name: \"maps\",\n        type: \"package\",\n        requiresFusionCharts: !0,\n        extension: function extension(e) {\n          return e.addDep(i[\"default\"]);\n        }\n      };\n    },\n    1107: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n\n      var r = u(o(459)),\n          a = o(138),\n          i = function (e) {\n        if (e && e.__esModule) return e;\n        var t = {};\n        if (null != e) for (var o in e) {\n          Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);\n        }\n        return t[\"default\"] = e, t;\n      }(o(373)),\n          n = u(o(127)),\n          l = o(131),\n          s = o(125),\n          c = u(o(1108)),\n          d = u(o(363)),\n          h = u(o(938)),\n          p = u(o(942));\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function f(e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      function g(e, t) {\n        if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n      }\n\n      function m(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), r = 0; r < o.length; r++) {\n            var a = o[r],\n                i = Object.getOwnPropertyDescriptor(t, a);\n            i && i.configurable && e[a] === undefined && Object.defineProperty(e, a, i);\n          }\n        }(e, t));\n      }\n\n      var b = (0, s.extend2)({\n        foregroundcolor: \"333333\",\n        foregroundalpha: \"100\",\n        foregrounddarkcolor: \"111111\",\n        foregrounddarkalpha: \"100\",\n        foregroundlightcolor: \"666666\",\n        foregroundlightalpha: \"100\",\n        backgroundlightcolor: \"FFFFFF\",\n        backgroundlightalpha: \"100\",\n        backgroundlightangle: 90,\n        backgroundlightratio: \"\",\n        backgroundcolor: \"FFFFCC\",\n        backgroundalpha: \"100\",\n        backgrounddarkcolor: \"ffcc66\",\n        backgrounddarkalpha: \"100\",\n        backgrounddarkangle: 270,\n        backgrounddarkratio: \"\",\n        shadow: 1\n      }, i),\n          v = \"0,100\",\n          k = {\n        basefontcolor: \"foregroundcolor\",\n        bordercolor: \"foregrounddarkcolor\",\n        borderalpha: \"foregrounddarkalpha\",\n        bgcolor: \"backgroundlightcolor\",\n        bgalpha: \"backgroundlightalpha\",\n        bgangle: \"backgroundlightangle\",\n        bgratio: \"backgroundlightratio\",\n        canvasbordercolor: \"foregrounddarkcolor\",\n        canvasborderalpha: \"foregrounddarkalpha\",\n        canvasbgcolor: \"backgroundlightcolor\",\n        canvasbgalpha: \"backgroundlightalpha\",\n        canvasbgangle: \"backgroundlightangle\",\n        canvasbgratio: \"backgroundlightratio\",\n        tooltipbordercolor: \"foregrounddarkcolor\",\n        tooltipborderalpha: \"foregrounddarkalpha\",\n        tooltipbgcolor: \"backgroundlightcolor\",\n        tooltipbgalpha: \"backgroundlightalpha\",\n        tooltipfontcolor: \"foregroundcolor\",\n        legendbordercolor: \"foregrounddarkcolor\",\n        legendborderalpha: \"foregrounddarkalpha\",\n        markerbordercolor: \"foregroundlightcolor\",\n        markerborderalpha: \"foregroundlightalpha\",\n        markerfillcolor: \"backgrounddarkcolor\",\n        markerfillalpha: \"backgrounddarkalpha\",\n        markerfillangle: \"backgrounddarkangle\",\n        markerfillratio: \"backgrounddarkratio\",\n        plotfillcolor: \"backgroundcolor\",\n        plotfillalpha: \"backgroundalpha\",\n        plotfillangle: \"backgroundangle\",\n        plotfillratio: \"backgroundratio\",\n        plothoverfillcolor: \"backgrounddarkcolor\",\n        plothoverfillalpha: \"backgrounddarkalpha\",\n        plothoverfillangle: \"backgrounddarkangle\",\n        plothoverfillratio: \"backgrounddarkratio\",\n        plotbordercolor: \"foregroundcolor\",\n        plotborderalpha: \"foregroundalpha\",\n        shadow: \"shadow\"\n      },\n          y = {\n        getMapName: function getMapName() {\n          return this.jsVars.instanceAPI.getName().toLowerCase();\n        },\n        getEntityList: function getEntityList() {\n          var e = this.jsVars.instanceAPI.getDatasets() || [],\n              t = void 0,\n              o = void 0,\n              r = void 0,\n              a = e.length,\n              i = [],\n              n = void 0,\n              l = void 0;\n\n          for (t = 0; t < a; t++) {\n            if (\"entities\" === (r = e[t] || []).getName()) {\n              o = r;\n              break;\n            }\n          }\n\n          for (t in a = (n = o.components.data).length, n) {\n            n.hasOwnProperty(t) && (l = (n[t] || {}).config || {}, i.push({\n              id: l.id,\n              originalId: l.originalId || l.id,\n              label: l.label,\n              shortlabel: l.shortLabel,\n              value: l.value,\n              formattedValue: l.formattedValue,\n              toolText: l.toolText\n            }));\n          }\n\n          return i;\n        },\n        getMapAttribute: function getMapAttribute() {\n          return (0, l.raiseWarning)(this, \"12061210581\", \"run\", \"JavaScriptRenderer~getMapAttribute()\", 'Use of deprecated \"getMapAttribute()\". Replace with \"getChartAttribute()\".'), this.getChartAttribute.apply(this, arguments);\n        },\n        exportMap: function exportMap() {\n          return (0, l.raiseWarning)(this, \"12061210581\", \"run\", \"JavaScriptRenderer~exportMap()\", 'Use of deprecated \"exportMap()\". Replace with \"exportChart()\".'), this.exportChart && this.exportChart.apply(this, arguments);\n        },\n        addMarker: function addMarker(e) {\n          var t = this.jsVars.instanceAPI.getDatasets() || [],\n              o = t.length,\n              r = void 0,\n              a = void 0,\n              i = void 0;\n\n          for (r = 0; r < o; r++) {\n            if (\"markers\" === (a = t[r] || []).getName()) {\n              i = a;\n              break;\n            }\n          }\n\n          i && !i.addMarkerItem(e) && (0, l.raiseWarning)(this, \"1309264086\", \"run\", \"MapsRenderer~addMarker()\", \"Failed to add marker. Check the options and try again.\");\n        },\n        updateMarker: function updateMarker(e, t) {\n          var o = this.jsVars.instanceAPI.getDatasets() || [],\n              r = o.length,\n              a = void 0,\n              i = void 0,\n              n = void 0;\n\n          for (a = 0; a < r; a++) {\n            if (\"markers\" === (i = o[a] || []).getName()) {\n              n = i;\n              break;\n            }\n          }\n\n          n && e && (e = (e + C).toLowerCase(), n.updateMarkerItem(e, t));\n        },\n        removeMarker: function removeMarker(e) {\n          var t = this.jsVars.instanceAPI.getDatasets() || [],\n              o = t.length,\n              r = void 0,\n              a = void 0,\n              i = void 0;\n\n          for (r = 0; r < o; r++) {\n            if (\"markers\" === (a = t[r] || []).getName()) {\n              i = a;\n              break;\n            }\n          }\n\n          e && (e = (e + C).toLowerCase(), i._removeMarkerItem(e));\n        }\n      },\n          C = \"\",\n          w = window.Math,\n          F = w.min,\n          A = w.max,\n          E = function (e) {\n        function t(o, r) {\n          f(this, t);\n          var a,\n              i = g(this, e.call(this));\n\n          for (a in i.subpalette = \"\", i.key = \"\", i.index = r, o) {\n            i.subpalette = b[o[a]], i[a] = i.subpalette instanceof Array ? i.subpalette[r] : i.subpalette, i.key = a;\n          }\n\n          return i;\n        }\n\n        return m(t, e), t;\n      }(a.ComponentInterface),\n          x = function (e) {\n        function t() {\n          f(this, t);\n          var o = g(this, e.call(this));\n          return o.friendlyName = \"Map\", o.revision = 1, o.hasCanvas = !0, o.standaloneInit = !1, o.defaultDatasetType = \"maps\", o.defaultSeriesType = \"geo\", o.fireGroupEvent = !0, o.legendposition = \"right\", o.hasGradientLegend = !0, o.isMap = !0, o.defaultPaletteOptions = {\n            paletteColors: [[\"A6A6A6\", \"CCCCCC\", \"E1E1E1\", \"F0F0F0\"], [\"A7AA95\", \"C4C6B7\", \"DEDFD7\", \"F2F2EE\"], [\"04C2E3\", \"66E7FD\", \"9CEFFE\", \"CEF8FF\"], [\"FA9101\", \"FEB654\", \"FED7A0\", \"FFEDD5\"], [\"FF2B60\", \"FF6C92\", \"FFB9CB\", \"FFE8EE\"]],\n            bgColor: [\"FFFFFF\", \"CFD4BE,F3F5DD\", \"C5DADD,EDFBFE\", \"A86402,FDC16D\", \"FF7CA0,FFD1DD\"],\n            bgAngle: [270, 270, 270, 270, 270],\n            bgRatio: [v, v, v, v, v],\n            bgAlpha: [\"100\", \"60,50\", \"40,20\", \"20,10\", \"30,30\"],\n            toolTipBgColor: [\"FFFFFF\", \"FFFFFF\", \"FFFFFF\", \"FFFFFF\", \"FFFFFF\"],\n            toolTipBorderColor: [\"545454\", \"545454\", \"415D6F\", \"845001\", \"68001B\"],\n            baseFontColor: [\"555555\", \"60634E\", \"025B6A\", \"A15E01\", \"68001B\"],\n            tickColor: [\"333333\", \"60634E\", \"025B6A\", \"A15E01\", \"68001B\"],\n            trendColor: [\"545454\", \"60634E\", \"415D6F\", \"845001\", \"68001B\"],\n            plotFillColor: [\"545454\", \"60634E\", \"415D6F\", \"845001\", \"68001B\"],\n            borderColor: [\"767575\", \"545454\", \"415D6F\", \"845001\", \"68001B\"],\n            borderAlpha: [50, 50, 50, 50, 50]\n          }, o.colorPaletteMap = k, o.eiMethods = y, o.registerFactory(\"legend\", p[\"default\"], [\"canvas\"]), o.registerFactory(\"axis\", function () {}, [\"canvas\"]), o.registerFactory(\"colormanager-decider\", h[\"default\"], [\"legend\"]), o.registerFactory(\"dataset\", c[\"default\"], [\"colormanager-decider\"]), o.registerFactory(\"canvas\", d[\"default\"]), o;\n        }\n\n        return m(t, e), t.prototype._checkInvalidSpecificData = function () {\n          return this.config.invalid = !1, !1;\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          !t.baseWidth && (t.baseWidth = 400), !t.baseHeight && (t.baseHeight = 300), !t.baseScaleFactor && (t.baseScaleFactor = 1);\n        }, t.getName = function () {\n          return \"maps\";\n        }, t.getType = function () {\n          return \"chartAPI\";\n        }, t.prototype.getName = function () {\n          return this.config.name || \"GEO\";\n        }, t.prototype.getType = function () {\n          return \"chartAPI\";\n        }, t.prototype.configureAttributes = function (t) {\n          var o,\n              r = this.getChildren(\"colorPalette\") && this.getChildren(\"colorPalette\")[0];\n          o = t.chart = t.chart || t.graph || t.map || {}, this.jsonData = t, r || (r = new E(this.colorPaletteMap, (o.palette > 0 && o.palette < 6 ? o.palette : (0, s.pluckNumber)(this.paletteIndex, 1)) - 1), this.attachChild(r, \"colorPalette\")), this.config.skipCanvasDrawing = !0, e.prototype.configureAttributes.call(this, t), this._parseBackgroundCosmetics();\n        }, t.prototype.parseChartAttr = function (t) {\n          var o,\n              r,\n              a,\n              i,\n              n = void 0,\n              l = this.jsonData,\n              c = l.chart || l.map,\n              d = l.markers,\n              h = new E(this.colorPaletteMap, (c.palette > 0 && c.palette < 6 ? c.palette : (0, s.pluckNumber)(this.paletteIndex, 1)) - 1),\n              p = (0, s.pluck)(c.entitybordercolor, c.bordercolor, h.plotbordercolor),\n              u = (0, s.pluck)(c.entityfillcolor, c.fillcolor, h.plotfillcolor),\n              f = (0, s.pluck)(c.entityfillalpha, c.fillalpha, h.plotfillalpha),\n              g = (0, s.pluck)(c.entityfillratio, c.fillratio, h.plotfillratio),\n              m = (0, s.pluck)(c.entityfillangle, c.fillangle, h.plotfillangle),\n              b = (0, s.pluck)(c.nullentityfillcolor, c.nullentitycolor, u),\n              v = (0, s.pluckNumber)(c.usevaluesformarkers, l.markers && l.markers.items && l.markers.items.length, !(l.markers && l.markers.application && l.markers.application.length && l.markers.definition && l.markers.definition.length));\n          e.prototype.parseChartAttr.call(this, t), (n = this.config).origMarginTop = (0, s.pluckNumber)(c.charttopmargin, c.maptopmargin, 11), n.origMarginLeft = (0, s.pluckNumber)(c.chartleftmargin, c.mapleftmargin, 11), n.origMarginBottom = (0, s.pluckNumber)(c.chartbottommargin, c.mapbottommargin, 11), n.origMarginRight = (0, s.pluckNumber)(c.chartrightmargin, c.maprightmargin, 11), n.labelsOnTop = (0, s.pluckNumber)(c.entitylabelsontop, 1), o = (i = n.style).inCancolor, r = i.inCanfontFamily, a = i.inCanfontSize, n.entityOpts = {\n            baseScaleFactor: n.baseScaleFactor,\n            dataLabels: {\n              style: {\n                fontFamily: r,\n                fontSize: a,\n                lineHeight: i.inCanLineHeight,\n                color: i.inCancolor\n              }\n            },\n            fillColor: u,\n            fillAlpha: f,\n            fillRatio: g,\n            fillAngle: m,\n            borderColor: p,\n            borderAlpha: (0, s.pluck)(c.entityborderalpha, c.borderalpha, this.borderAlpha, \"100\"),\n            borderThickness: (0, s.pluckNumber)(c.showentityborder, c.showborder, 1) ? (0, s.pluckNumber)(c.entityborderthickness, c.borderthickness, 1) : 0,\n            scaleBorder: (0, s.pluckNumber)(c.scaleentityborder, c.scaleborder, 0),\n            hoverFillColor: (0, s.pluck)(c.entityfillhovercolor, c.hoverfillcolor, c.hovercolor, h.plothoverfillcolor),\n            hoverFillAlpha: (0, s.pluck)(c.entityfillhoveralpha, c.hoverfillalpha, c.hoveralpha, h.plothoverfillalpha),\n            hoverFillRatio: (0, s.pluck)(c.entityfillhoverratio, c.hoverfillratio, c.hoverratio, h.plothoverfillratio),\n            hoverFillAngle: (0, s.pluck)(c.entityfillhoverangle, c.hoverfillangle, c.hoverangle, h.plothoverfillangle),\n            hoverBorderThickness: (0, s.pluck)(c.entityborderhoverthickness, c.hoverborderthickness),\n            hoverBorderColor: (0, s.pluck)(c.entityborderhovercolor, p, h.plotbordercolor),\n            hoverBorderAlpha: (0, s.pluck)(c.entityborderhoveralpha, h.plotborderalpha),\n            nullEntityColor: b,\n            nullEntityAlpha: (0, s.pluck)(c.nullentityfillalpha, c.nullentityalpha, f),\n            nullEntityRatio: (0, s.pluck)(c.nullentityfillratio, c.nullentityratio, g),\n            nullEntityAngle: (0, s.pluck)(c.nullentityfillangle, c.nullentityangle, m),\n            connectorColor: (0, s.pluck)(c.labelconnectorcolor, c.connectorcolor, o),\n            connectorAlpha: (0, s.pluck)(c.labelconnectoralpha, c.connectoralpha, \"100\"),\n            connectorThickness: (0, s.pluckNumber)(c.labelconnectorthickness, c.borderthickness, 1),\n            showHoverEffect: (0, s.pluckNumber)(c.showentityhovereffect, c.usehovercolor, c.showhovereffect, 1),\n            hoverOnNull: (0, s.pluckNumber)(c.hoveronnull, c.entityhoveronnull, 1),\n            labelPadding: (0, s.pluckNumber)(c.labelpadding, 5),\n            showLabels: (0, s.pluckNumber)(c.showlabels, 1),\n            labelsOnTop: (0, s.pluckNumber)(c.entitylabelsontop, 1),\n            includeNameInLabels: (0, s.pluckNumber)(c.includenameinlabels, 1),\n            includeValueInLabels: (0, s.pluckNumber)(c.includevalueinlabels, 0),\n            useSNameInTooltip: (0, s.pluckNumber)(c.usesnameintooltip, 0),\n            useShortName: (0, s.pluckNumber)(c.usesnameinlabels, 1),\n            labelSepChar: (0, s.pluck)(c.labelsepchar, \", \"),\n            showTooltip: (0, s.pluckNumber)(c.showentitytooltip, c.showtooltip, 1),\n            tooltipSepChar: (0, s.pluck)(c.tooltipsepchar, \", \"),\n            tooltext: c.entitytooltext,\n            hideNullEntities: (0, s.pluckNumber)(c.hidenullentities, 0),\n            showHiddenEntityBorder: (0, s.pluckNumber)(c.showhiddenentityborder, 1),\n            showNullEntityBorder: (0, s.pluckNumber)(c.shownullentityborder, 1),\n            hiddenEntityColor: (0, s.pluck)(c.hiddenentitycolor, c.hiddenentityfillcolor, c.hiddenentityalpha || c.hiddenentityfillalpha ? b : \"ffffff\"),\n            hiddenEntityAlpha: (0, s.pluck)(c.hiddenentityalpha, c.hiddenentityfillalpha, .001),\n            shadow: (0, s.pluckNumber)(c.showshadow, this.defaultPlotShadow, h.shadow)\n          }, n.markerOpts = {\n            dataLabels: {\n              style: {\n                fontFamily: (0, s.pluck)(c.markerfont, r),\n                fontSize: (0, s.pluckNumber)(c.markerfontsize, parseInt(a, 10)),\n                fontColor: (0, s.pluck)(c.markerfontcolor, o)\n              }\n            },\n            showTooltip: (0, s.pluckNumber)(c.showmarkertooltip, c.showtooltip, 1),\n            showLabels: (0, s.pluckNumber)(c.showmarkerlabels, c.showlabels, 1),\n            showHoverEffect: (0, s.pluckNumber)(c.showmarkerhovereffect, 1),\n            labelPadding: (0, s.pluck)(c.markerlabelpadding, \"5\"),\n            labelWrapWidth: (0, s.pluckNumber)(c.markerlabelwrapwidth, 0),\n            labelWrapHeight: (0, s.pluckNumber)(c.markerlabelwrapheight, 0),\n            fillColor: (0, s.pluck)(c.markerfillcolor, c.markerbgcolor, h.markerfillcolor),\n            fillAlpha: (0, s.pluck)(c.markerfillalpha, h.markerfillalpha),\n            fillAngle: (0, s.pluck)(c.markerfillangle, h.markerfillangle),\n            fillRatio: (0, s.pluck)(c.markerfillratio, h.markerfillratio),\n            fillPattern: (0, s.pluck)(c.markerfillpattern, h.markerbgpattern),\n            hoverFillColor: c.markerfillhovercolor,\n            hoverFillAlpha: c.markerfillhoveralpha,\n            hoverFillRatio: c.markerfillhoverratio,\n            hoverFillAngle: c.markerfillhoverangle,\n            borderThickness: (0, s.pluck)(c.markerborderthickness, 1),\n            borderColor: (0, s.pluck)(c.markerbordercolor, h.markerbordercolor),\n            borderAlpha: (0, s.pluckNumber)(c.markerborderalpha, h.markerborderalpha),\n            hoverBorderThickness: c.markerborderhoverthickness,\n            hoverBorderColor: c.markerborderhovercolor,\n            hoverBorderAlpha: c.markerborderhoveralpha,\n            radius: (0, s.pluckNumber)(c.markerradius && (0, s.trimString)(c.markerradius), 7),\n            shapeId: (0, s.pluck)(c.defaultmarkershape, \"circle\"),\n            labelSepChar: (0, s.pluck)(c.labelsepchar, \", \"),\n            tooltipSepChar: (0, s.pluck)(c.tooltipsepchar, \", \"),\n            autoScale: (0, s.pluckNumber)(c.autoscalemarkers, 0),\n            tooltext: (0, s.pluck)(d && d.tooltext, c.markertooltext),\n            dataEnabled: v,\n            valueToRadius: (0, s.pluckNumber)(c.markerradiusfromvalue, 1),\n            valueMarkerAlpha: (0, s.pluck)(c.valuemarkeralpha, \"75\"),\n            hideNull: (0, s.pluckNumber)(c.hidenullmarkers, 0),\n            nullRadius: (0, s.pluckNumber)(c.nullmarkerradius, c.markerradius, 7),\n            adjustViewPort: (0, s.pluckNumber)(c.adjustviewportformarkers, 0),\n            startAngle: (0, s.pluckNumber)(c.markerstartangle, 90),\n            maxRadius: (0, s.pluckNumber)(c.maxmarkerradius, 0),\n            minRadius: (0, s.pluckNumber)(c.minmarkerradius, 0),\n            applyAll: (0, s.pluckNumber)(c.applyallmarkers, 0),\n            shadow: (0, s.pluckNumber)(c.showmarkershadow, c.showshadow, 0)\n          }, n.connectorOpts = {\n            showHoverEffect: (0, s.pluckNumber)(c.showconnectorhovereffect, 1),\n            thickness: (0, s.pluckNumber)(c.connectorthickness, c.markerconnthickness, \"2\"),\n            color: (0, s.pluck)(c.connectorcolor, c.markerconncolor, h.markerbordercolor),\n            alpha: (0, s.pluck)(c.connectoralpha, c.markerconnalpha, \"100\"),\n            hoverThickness: (0, s.pluckNumber)(c.connectorhoverthickness, c.connectorthickness, c.markerconnthickness, \"2\"),\n            hoverColor: (0, s.pluck)(c.connectorhovercolor, c.connectorcolor, c.markerconncolor, h.markerbordercolor),\n            hoverAlpha: (0, s.pluck)(c.connectorhoveralpha, c.connectoralpha, c.markerconnalpha, \"100\"),\n            dashed: (0, s.pluckNumber)(c.connectordashed, c.markerconndashed, 0),\n            dashLen: (0, s.pluckNumber)(c.connectordashlen, c.markerconndashlen, 3),\n            dashGap: (0, s.pluckNumber)(c.connectordashgap, c.markerconndashgap, 2),\n            font: (0, s.pluck)(c.connectorfont, c.markerconnfont, r),\n            fontColor: (0, s.pluck)(c.connectorfontcolor, c.markerconnfontcolor, o),\n            fontSize: (0, s.pluckNumber)(c.connectorfontsize, c.markerconnfontsize, parseInt(a, 10)),\n            showLabels: (0, s.pluckNumber)(c.showconnectorlabels, c.showmarkerlabels, c.showlabels, 1),\n            labelBgColor: (0, s.pluck)(c.connectorlabelbgcolor, c.markerconnlabelbgcolor, h.plotfillcolor),\n            labelBorderColor: (0, s.pluck)(c.connectorlabelbordercolor, c.markerconnlabelbordercolor, h.markerbordercolor),\n            shadow: (0, s.pluckNumber)(c.showconnectorshadow, c.showmarkershadow, c.showshadow, 0),\n            showTooltip: (0, s.pluckNumber)(c.showconnectortooltip, c.showmarkertooltip, c.showtooltip, 1),\n            tooltext: (0, s.pluck)(d && d.connectortooltext, c.connectortooltext),\n            hideOpen: (0, s.pluckNumber)(c.hideopenconnectors, 1)\n          }, n.adjustViewPortForMarkers = (0, s.pluckNumber)(c.adjustviewportformarkers, v);\n        }, t.prototype._attachMouseEvents = function () {\n          var e = this.getFromEnv(\"eventListeners\"),\n              o = this.getFromEnv(\"chart-container\");\n          e.push(n[\"default\"].listen(o, s.hasTouch ? \"touchstart\" : \"click\", t.searchMouseMove, this)), e.push(n[\"default\"].listen(window.document, s.hasTouch ? \"touchstart\" : \"mousemove\", t.searchMouseMove, this));\n        }, t.prototype._dispose = function () {\n          var o = this.getFromEnv(\"chart-container\");\n          s.hasTouch && (n[\"default\"].unlisten(o, \"touchstart\", t.searchMouseMove), n[\"default\"].unlisten(window.document, \"touchstart\", t.searchMouseMove)), n[\"default\"].unlisten(o, \"click\", t.searchMouseMove), n[\"default\"].unlisten(window.document, \"mousemove\", t.searchMouseMove), e.prototype._dispose.call(this);\n        }, t.searchMouseMove = function (e) {\n          var t,\n              o = e.data,\n              r = o.config,\n              a = o.getDatasets()[1],\n              i = a && a.getFromEnv(\"toolTipController\"),\n              n = a && a.config.currentToolTip,\n              l = o.config.lastHoveredPoint,\n              c = {};\n          o.getFromEnv(\"chart-container\") && o.config.lastInteractionEvent !== e.originalEvent && (o.config.lastInteractionEvent = e.originalEvent, (t = function (e, t) {\n            var o = (0, s.getMouseCoordinate)(t.getFromEnv(\"chart-container\"), e),\n                r = o.chartX,\n                a = o.chartY,\n                i = t.config,\n                n = i.canvasLeft,\n                l = i.canvasTop,\n                c = i.canvasLeft + i.canvasWidth,\n                d = i.canvasHeight + i.canvasTop;\n            return o.insideCanvas = !1, o.originalEvent = e, r > n && r < c && a > l && a < d && (o.insideCanvas = !0), o;\n          }(e, o)) && t.insideCanvas ? (r.lastMouseEvent = e, c = {\n            x: t.chartX,\n            y: t.chartY\n          }, o._searchNearestNeighbour(c, e)) : (l && a && a.hoverOutFn.call(l.element), o.config.lastHoveredPoint = null, i && i.hide(n)));\n        }, t.prototype._searchNearestNeighbour = function (e, t) {\n          var o = this.getDatasets()[1],\n              r = void 0;\n\n          if (o) {\n            if (!o.components.kDTree) return;\n            (r = o.getElement(e)) ? o.highlightPoint(r, t) : o.highlightPoint(!1, t);\n          }\n        }, t.prototype._createLayers = function () {\n          e.prototype._createLayers.call(this), this._attachMouseEvents();\n        }, t.prototype._parseBackgroundCosmetics = function () {\n          var e,\n              t = this.getChildren(\"background\")[0].config,\n              o = this.getChildren(\"colorPalette\")[0],\n              r = this.getFromEnv(\"chart-attrib\");\n          e = t.showBorder = (0, s.pluckNumber)(r.showcanvasborder, 1), t.borderWidth = e ? (0, s.pluckNumber)(r.canvasborderthickness, 1) : 0, t.borderRadius = t.borderRadius = (0, s.pluckNumber)(r.canvasborderradius, 0), t.borderDashStyle = t.borderDashStyle = (0, s.pluckNumber)(r.borderdashed, 0) ? (0, s.getDashStyle)((0, s.pluckNumber)(r.borderdashlen, 4), (0, s.pluckNumber)(r.borderdashgap, 2)) : \"none\", t.borderAlpha = (0, s.pluck)(r.canvasborderalpha, o.borderAlpha), t.borderColor = t.borderColor = (0, s.convertColor)((0, s.pluck)(r.canvasbordercolor, o && o.borderColor), t.borderAlpha);\n        }, t.prototype._getBackgroundCosmetics = function () {\n          var e = this.getFromEnv(\"chart-attrib\") || this.jsonData.map,\n              t = this.getChildren(\"colorPalette\")[0];\n          return {\n            FCcolor: {\n              color: (0, s.pluck)(e.bgcolor, e.canvasbgcolor, t.bgcolor),\n              alpha: (0, s.pluck)(e.bgalpha, e.canvasbgalpha, t.bgalpha),\n              angle: (0, s.pluck)(e.bgangle, e.canvasbgangle, t.bgangle),\n              ratio: (0, s.pluck)(e.bgratio, e.canvasbgratio, t.bgratio)\n            }\n          };\n        }, t.prototype._parseCanvasCosmetics = function () {\n          e.prototype._parseCanvasCosmetics.call(this);\n\n          var t = this.config,\n              o = this.getFromEnv(\"chart-attrib\") || this.jsonData.map,\n              r = this.getChildren(\"canvas\")[0].config;\n          t.origMarginTop = (0, s.pluckNumber)(o.maptopmargin, 11), t.origMarginLeft = (0, s.pluckNumber)(o.mapleftmargin, 11), t.origMarginBottom = (0, s.pluckNumber)(o.mapbottommargin, 11), t.origMarginRight = (0, s.pluckNumber)(o.maprightmargin, 11), t.origCanvasLeftMargin = (0, s.pluckNumber)(o.canvasleftmargin, 0), t.origCanvasRightMargin = (0, s.pluckNumber)(o.canvasrightmargin, 0), t.origCanvasTopMargin = (0, s.pluckNumber)(o.canvastopmargin, 0), t.origCanvasBottomMargin = (0, s.pluckNumber)(o.canvasbottommargin, 0), r.canvasBorderRadius = (0, s.pluckNumber)(o.canvasborderradius, 0), r.origCanvasTopPad = (0, s.pluckNumber)(o.canvastoppadding, 0), r.origCanvasBottomPad = (0, s.pluckNumber)(o.canvasbottompadding, 0), r.origCanvasLeftPad = (0, s.pluckNumber)(o.canvasleftpadding, 0), r.origCanvasRightPad = (0, s.pluckNumber)(o.canvasrightpadding, 0);\n        }, t.prototype.preliminaryScaling = function () {\n          for (var e = this.jsonData, t = e.markers && e.markers.items || [], o = t && t.length || 0, r = Infinity, a = Infinity, i = -Infinity, n = -Infinity, l = void 0, s = void 0, c = void 0; o--;) {\n            c = t[o], l = Number(c.x), s = Number(c.y), r = F(r, l), a = F(a, s), i = A(i, l), n = A(n, s);\n          }\n\n          return {\n            x: r,\n            y: a,\n            x1: i,\n            y1: n\n          };\n        }, t.prototype.getScalingParameters = function (e, t, o, r) {\n          var a = e / t,\n              i = o / (e * this.config.baseScaleFactor),\n              n = r / (t * this.config.baseScaleFactor),\n              l = 0,\n              s = 0,\n              c = void 0,\n              d = void 0;\n          return i > n ? (l += (o - r * a) / 2, d = 200 / (t * (c = n))) : (s += (r - o / a) / 2, d = 200 / (e * (c = i))), {\n            scaleFactor: c,\n            strokeWidth: d,\n            translateX: l,\n            translateY: s\n          };\n        }, t.prototype.calculateMarkerBounds = function (e, t, o) {\n          var r,\n              a = this.config,\n              i = a.markerOpts,\n              n = this.getDatasets(),\n              l = this.getDataLimits(),\n              s = l.dataMin,\n              c = l.dataMax,\n              d = i.hideNull,\n              h = i.nullRadius,\n              p = i.valueToRadius,\n              u = void 0,\n              f = void 0,\n              g = void 0,\n              m = void 0,\n              b = void 0,\n              v = void 0,\n              k = void 0,\n              y = Infinity,\n              C = Infinity,\n              w = -Infinity,\n              E = -Infinity,\n              x = void 0,\n              L = void 0,\n              N = void 0,\n              S = void 0;\n\n          for (v = 0, r = n.length; v < r; v++) {\n            \"markers\" === (k = n[v]).getName() && (u = k);\n          }\n\n          if (u) for (v in u.calculateMarkerRadiusLimits(), g = (f = u.config || {}).minRadius, m = f.maxRadius, b = u.components && u.components.markerObjs || {}) {\n            S = (a = b[v].config).definition || {}, null !== a.cleanValue ? (p && void 0 === S.radius && (a.radius = g + (m - g) * (a.cleanValue - s) / (c - s)), N = Number(a.radius), x = (Number(S.x) + t) * e, L = (Number(S.y) + o) * e, y = F(y, x - N), C = F(C, L - N), w = A(w, x + N), E = A(E, L + N)) : d ? a.__hideMarker = !0 : null === a.radius && (a.radius = h);\n          }\n          return {\n            x: y,\n            y: C,\n            x1: w,\n            y1: E\n          };\n        }, t.prototype._spaceManager = function () {\n          var e,\n              t,\n              o = this.config,\n              r = this.getChildren(\"legend\") && this.getChildren(\"legend\")[0],\n              a = r && r.config.legendPos,\n              i = this.getFromEnv(\"chart-attrib\"),\n              n = o.showBorder,\n              l = o.origMarginLeft,\n              c = o.origMarginTop,\n              d = this.config.baseWidth,\n              h = this.config.baseHeight,\n              p = void 0,\n              u = void 0,\n              f = void 0,\n              g = void 0,\n              m = {},\n              b = 0,\n              v = 0,\n              k = void 0,\n              y = void 0,\n              C = void 0,\n              w = o.markerOpts,\n              F = o.borderWidth = n ? (0, s.pluckNumber)(i.borderthickness, 1) : 0;\n          this._allocateSpace({\n            top: F,\n            bottom: F,\n            left: F,\n            right: F\n          }), this._allocateSpace(this._manageActionBarSpace && this._manageActionBarSpace(.225 * o.availableHeight) || {}), C = \"right\" === a ? .3 * o.canvasWidth : .3 * o.canvasHeight, o.showLegend && this._manageLegendSpace(C), e = \"bottom\" === a ? .225 * o.canvasHeight : .225 * o.canvasWidth, t = this._manageChartMenuBar(e), u = o.canvasWidth, f = o.canvasHeight, w.dataEnabled ? (o.adjustViewPortForMarkers ? ((m = this.preliminaryScaling()).x1 > d && (d = m.x1), m.x < 0 && (d += -m.x, b = -m.x), m.y1 > h && (h = m.y1), m.y < 0 && (h += -m.y, v = -m.y), p = this.getScalingParameters(d, h, u, f), k = f, y = u, (m = this.calculateMarkerBounds(p.scaleFactor * this.config.baseScaleFactor, b, v)).x < 0 && (l += -m.x, u += m.x), m.y < 0 && (c += -m.y, f += m.y), m.x1 > y && (u -= m.x1 - y), m.y1 > k && (f -= m.y1 - k)) : (p = this.getScalingParameters(d, h, u, f), this.calculateMarkerBounds(p.scaleFactor * this.config.baseScaleFactor, b, v)), l += b * (p = this.getScalingParameters(d, h, u, f)).scaleFactor * this.config.baseScaleFactor, c += v * p.scaleFactor * this.config.baseScaleFactor) : p = this.getScalingParameters(d, h, u, f), this.config.scalingParams = p, g = p.scaleFactor, p.translateX = p.translateX + l, p.translateY = p.translateY + c + t.top || 0, p.sFactor = g * this.config.baseScaleFactor * 100 / 100, p.transformStr = [\"t\", p.translateX, \",\", p.translateY, \"s\", g, \",\", g, \",0,0\"].join(\"\"), this.config.annotationConfig = {\n            id: \"Geo\",\n            showbelow: 0,\n            autoscale: 0,\n            grpxshift: p.translateX ? p.translateX : 0,\n            grpyshift: p.translateY ? p.translateY : 0,\n            xscale: 100 * (g ? g * this.config.baseScaleFactor : 1),\n            yscale: 100 * (g ? g * this.config.baseScaleFactor : 1),\n            scaletext: 1,\n            options: {\n              useTracker: !0\n            }\n          };\n        }, t.prototype.getDataLimits = function () {\n          var e = this.getDatasets(),\n              t = e.length,\n              o = +Infinity,\n              r = -Infinity,\n              a = void 0,\n              i = void 0;\n\n          for (i = 0; i < t; i++) {\n            a = e[i].getDataLimits(), o = F(o, a.min), r = A(r, a.max);\n          }\n\n          return {\n            dataMin: o,\n            dataMax: r\n          };\n        }, t.prototype.getEntityPaths = function (e) {\n          var t = {},\n              o = this.config.entities,\n              r = void 0;\n\n          if (e) {\n            for (r in o) {\n              t[r] = o[r];\n            }\n\n            return t;\n          }\n\n          return o;\n        }, t.prototype.checkComplete = function () {\n          this.config.entityFlag && this.config.entitiesReady && (this.config.entityFlag = !1, this.config.markersDrawn = !0, this.fireChartInstanceEvent(\"internal.mapdrawingcomplete\", {\n            renderer: this\n          }));\n        }, t;\n      }(r[\"default\"]);\n\n      t[\"default\"] = x;\n    },\n    1108: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t,\n            o = e.getFromEnv(\"dataSource\"),\n            l = o.data || {},\n            s = o.markers;\n        (0, r.componentFactory)(e, n[\"default\"], \"mapGroup\"), t = e.getChildren(\"mapGroup\")[0], (0, r.datasetFactory)(t, a[\"default\"], \"entities\", 1, [l]), s ? (0, r.datasetFactory)(t, i[\"default\"], \"markers\", 1, [s]) : e.getDatasets()[1] && e.getDatasets()[1].remove();\n      };\n      var r = o(125),\n          a = l(o(1109)),\n          i = l(o(1111)),\n          n = l(o(1112));\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n    },\n    1109: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      },\n          a = o(138),\n          i = h(o(193)),\n          n = o(132),\n          l = h(o(1110)),\n          s = o(125),\n          c = o(136),\n          d = h(o(486));\n\n      function h(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), r = 0; r < o.length; r++) {\n            var a = o[r],\n                i = Object.getOwnPropertyDescriptor(t, a);\n            i && i.configurable && e[a] === undefined && Object.defineProperty(e, a, i);\n          }\n        }(e, t));\n      }\n\n      var u = (0, n.getDep)(\"redraphael\", \"plugin\"),\n          f = void 0,\n          g = window.navigator.userAgent,\n          m = /msie/i.test(g) && !window.opera,\n          b = window.Math,\n          v = b.min,\n          k = b.max,\n          y = /stroke/gi,\n          C = /AppleWebKit/.test(g),\n          w = b.ceil,\n          F = function F(e, t) {\n        var o = t ? (0, s.extend2)(e.FCcolor, t, !1, !0) : {\n          FCcolor: e\n        };\n        return o.toString = s.toRaphaelColor, o;\n      },\n          A = function A(e, t) {\n        var o = void 0,\n            a = {};\n        if (t = t || 1, !e || \"object\" !== (void 0 === e ? \"undefined\" : r(e))) return a;\n\n        for (o in e) {\n          y.test(o) || (\"stroke-width\" === o ? (a[o] = Number(e[o]) / t, C && (a[o] = a[o] && w(a[o]) || 0)) : a[o] = e[o]);\n        }\n\n        return a;\n      },\n          E = {\n        right: function right() {\n          return arguments[1];\n        },\n        left: function left(e, t) {\n          return e - t;\n        },\n        center: function center(e, t) {\n          return 2 * v(t, e - t);\n        }\n      },\n          x = {\n        top: function top() {\n          return arguments[1];\n        },\n        middle: function middle(e, t) {\n          return 2 * v(t, e - t);\n        },\n        bottom: function bottom(e, t) {\n          return e - t;\n        }\n      };\n\n      (0, n.addDep)({\n        name: \"mapsAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      }), (0, d[\"default\"])(u);\n\n      var L = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.components = {}, o;\n        }\n\n        return p(t, e), t.prototype.getName = function () {\n          return \"entities\";\n        }, t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.configureAttributes = function (e) {\n          if (e) {\n            this.JSONData = {\n              data: e\n            };\n            var o,\n                r = this,\n                a = r.getFromEnv(\"chart\").jsonData,\n                i = r.config,\n                n = a.map || a.chart,\n                l = void 0,\n                c = void 0,\n                d = void 0,\n                h = void 0,\n                p = [],\n                u = void 0,\n                g = void 0,\n                m = void 0,\n                b = r.getFromEnv(\"colorManager\"),\n                v = a.entitydef || [];\n\n            for (h in !i.attachEvent && b && (r.addExtEventListener(\"legendUpdate\", function () {\n              if (\"legend\" === (m = arguments[1]).component) r.legendInteractivity(m.legendItem, m.colorObj);else for (p = m.maxMinArray, u = p.length, g = 0; g < u; g++) {\n                r.updateEntityColors(p[g].min, p[g].max);\n              }\n            }, b), i.attachEvent = !0), l = a.data && a.data[0] && a.data[0].data ? r.JSONData = a.data[0].data || [] : r.JSONData = a.data || [], i.useSNameAsId = (0, s.pluckNumber)(n.usesnameasid, 0), this._redefineEntities(v), o = r.components.data, i.showTooltip = (0, s.pluckNumber)(n.showtooltip, 1), i.showHoverEffect = (0, s.pluckNumber)(n.showhovereffect, 0), l = function (e) {\n              for (var t = e && e.length || 0, o = {}, r = void 0; t--;) {\n                (r = e[t]).id !== f && (o[r.id.toLowerCase()] = r);\n              }\n\n              return o;\n            }(l), r.calculateDataLimits(), !a.colorrange && r.detachChild(r.getChildren(\"colorRange\") && r.getChildren(\"colorRange\")[0].getId()), o) {\n              c = l[h], d = o[h], c ? this._configureEntity(h, d, (0, s.imprint)(t._sanitizeEntityOptions((0, s.extend2)({}, c)), d.config)) : this._configureEntity(h, d, d.config);\n            }\n          }\n        }, t.prototype.updateEntityColors = function (e, o) {\n          var r = this.components.data,\n              a = this.getFromEnv(\"chart\"),\n              i = void 0,\n              n = void 0,\n              l = void 0,\n              s = void 0,\n              c = void 0,\n              d = {\n            \"fill-opacity\": 0\n          };\n\n          for (s in r) {\n            l = (n = (i = r[s]).config).cleanValue, c = {\n              \"fill-opacity\": (n.alphaArr || [])[0] / 100 || 1\n            }, l < e || l > o ? (t.setCustomAttrs(i, d, a), i.hidden = !0) : (i.hidden = !1, t.setCustomAttrs(i, c, a));\n          }\n        }, t.prototype.legendInteractivity = function (e, o) {\n          var r = this.getFromEnv(\"chart\"),\n              a = this.components.data,\n              i = void 0,\n              n = void 0,\n              l = e.config,\n              s = e.hasState(\"hidden\"),\n              c = void 0,\n              d = this.getFromEnv(\"colorManager\"),\n              h = void 0,\n              p = {},\n              u = void 0,\n              f = {\n            \"fill-opacity\": 0\n          },\n              g = void 0;\n\n          for (i in r.getFromEnv(\"animationManager\").setAnimationState(\"legendInteraction\"), a) {\n            a.hasOwnProperty(i) && (c = (l = (n = a[i]).config).cleanValue, g = d.getColorObj(c), h = l.visibleEntityAttr, p[\"fill-opacity\"] = h[\"fill-opacity\"], u = s ? p : f, o.code === (!g.outOfRange && g.code) && (n.hidden = !s, t.setCustomAttrs(n, u, r), s ? e && e.removeLegendState(\"hidden\") : e.setLegendState(\"hidden\")));\n          }\n        }, t.setCustomAttrs = function (e, t) {\n          e && e.graphics.outlines.attr(t);\n        }, t.prototype.calculateDataLimits = function () {\n          var e,\n              t = this.getFromEnv(\"chart\"),\n              o = this.config,\n              r = t.jsonData.data || [],\n              a = this.getFromEnv(\"number-formatter\"),\n              i = void 0,\n              n = void 0,\n              l = +Infinity,\n              s = -Infinity,\n              c = void 0;\n\n          for (c = 0, e = r.length; c < e; c++) {\n            n = r[c].value, i = a.getCleanValue(n), l = v(l, i), s = k(s, i);\n          }\n\n          o.max = s, o.min = l;\n        }, t.prototype._configureEntity = function (e, t, o) {\n          var a,\n              i,\n              n,\n              l,\n              c,\n              d = this.getFromEnv(\"chart\"),\n              h = this.config,\n              p = this.getFromEnv(\"number-formatter\"),\n              u = d.config.entityOpts,\n              g = t.config,\n              m = t.labelConfig,\n              b = o.value,\n              v = g.cleanValue = p.getCleanValue(b),\n              k = g.formattedValue = v !== f ? p.dataLabels(v) : f,\n              y = (0, s.pluckNumber)(o.showtooltip, u.showTooltip),\n              C = this._getDefaultTooltip(t, o, this),\n              w = {\n            formattedValue: k,\n            sName: o.shortLabel,\n            lName: o.label\n          },\n              A = u.dataLabels.style,\n              E = g.toolText = y ? (0, s.parseUnsafeString)((0, s.pluck)((0, s.parseTooltext)((0, s.pluck)(o.tooltext, u.tooltext, C), [1, 2, 7, 38, 39], w, o))) : \"\",\n              x = g.borderColor = (0, s.pluck)(o.bordercolor, u.borderColor),\n              L = g.borderAlpha = (0, s.pluck)(o.borderalpha, u.borderAlpha),\n              N = g.borderThickness = (0, s.pluckNumber)(o.borderthickness, u.borderThickness),\n              S = u.hoverOnNull,\n              O = g.useHoverColor = (0, s.pluckNumber)(o.showhovereffect, o.usehovercolor, S ? u.showHoverEffect : isNaN(b) ? 0 : u.showHoverEffect),\n              _ = g.labelAlignment,\n              T = this.getFromEnv(\"colorManager\"),\n              I = void 0,\n              M = void 0,\n              P = void 0,\n              j = void 0,\n              D = void 0,\n              B = void 0,\n              R = void 0,\n              V = void 0,\n              G = void 0,\n              H = void 0,\n              W = void 0,\n              z = void 0,\n              X = void 0,\n              Y = void 0,\n              K = void 0,\n              J = void 0,\n              U = void 0;\n\n          if (t.hidden = !1, g.showLabel = (0, s.pluckNumber)(o.showlabel, u.showLabels), g.labelPadding = (0, s.pluckNumber)(o.labelpadding, u.labelPadding), g.fontFamily = (0, s.pluck)(o.font, A.fontFamily), g.fontSize = (0, s.pluckNumber)(parseInt(o.fontsize, 10), parseInt(A.fontSize, 10)), g.fontBold = (0, s.pluckNumber)(o.fontbold, 0), g.fontColor = (0, s.pluck)(o.fontcolor, A.color), g.connectorColor = (0, s.pluck)(o.labelconnectorcolor, u.connectorColor), g.connectorAlpha = (0, s.pluck)(o.labelconnectoralpha, u.connectorAlpha), g.hoverBorderThickness = (0, s.pluckNumber)(o.borderhoverthickness, o.hoverborderthickness, u.hoverBorderThickness), g.hoverBorderColor = (0, s.pluck)(o.borderhovercolor, o.hoverbordercolor, u.hoverBorderColor, g.borderColor), g.hoverBorderAlpha = (0, s.pluck)(o.borderhoveralpha, o.hoverborderalpha, u.hoverBorderAlpha, g.borderAlpha), g.connectorThickness = (0, s.pluckNumber)(o.labelconnectorthickness, u.connectorThickness), g.origConnectorThickness = g.connectorThickness, g.borderThickness = N, g.link = o.link, g.isVisible = !0, g.id = e, g.originalId = o.origId, null !== v && (I = T && T.getColor(v)) && !I.outOfRange && (z = I.code, I.oriAlpha !== f && (X = I.oriAlpha + \"\")), (0, s.pluck)(o.color, o.alpha, o.angle, o.ratio) !== f ? (j = (0, s.pluck)(o.color, z, u.fillColor), D = (0, s.pluck)(o.alpha, X, u.fillAlpha), B = (0, s.pluck)(o.angle, u.fillAngle), R = (0, s.pluck)(o.ratio, u.fillRatio), V = F({\n            color: j,\n            alpha: D,\n            angle: B,\n            ratio: R\n          })) : (H = F({\n            color: (0, s.pluck)(z, u.fillColor),\n            alpha: (0, s.pluck)(X, u.fillAlpha),\n            angle: (0, s.pluck)(u.fillAngle),\n            ratio: (0, s.pluck)(u.fillRatio)\n          }), G = F({\n            color: (0, s.pluck)(u.nullEntityColor),\n            alpha: (0, s.pluck)(u.nullEntityAlpha),\n            angle: (0, s.pluck)(u.nullEntityAngle),\n            ratio: (0, s.pluck)(u.nullEntityRatio)\n          }), j = (V = null === v ? G : H).FCcolor.color, D = V.FCcolor.alpha, B = V.FCcolor.angle, R = V.FCcolor.ratio), \"\" === E && (h.showTooltip = 0), g.visibleEntityAttr = {\n            stroke: (0, s.convertColor)(x, L),\n            fill: (g.fillColor = V).toString(),\n            \"fill-opacity\": D / 100\n          }, c = D.split(\",\"), g.alphaArr = c, O && ((0, s.pluck)(o.fillhovercolor, o.fillhoveralpha, o.fillhoverangle, o.fillhoverratio, o.hoverfillcolor, o.hoverfillalpha, o.hoverfillratio, o.hoverfillangle) !== f ? (j = (0, s.pluck)(o.fillhovercolor, o.hoverfillcolor, u.hoverFillColor), D = (0, s.pluck)(o.fillhoveralpha, o.hoverfillalpha, u.hoverFillAlpha), B = (0, s.pluck)(o.fillhoverangle, o.hoverfillangle, u.hoverFillAngle), R = (0, s.pluck)(o.fillhoverratio, o.hoverfillratio, u.hoverFillRatio), W = F({\n            color: j,\n            alpha: D,\n            angle: B,\n            ratio: R\n          })) : (u.hoverColorObject || (u.hoverColorObject = F({\n            color: u.hoverFillColor,\n            alpha: u.hoverFillAlpha,\n            angle: u.hoverFillAngle,\n            ratio: u.hoverFillRatio\n          })), W = u.hoverColorObject), g.hoverColor = W), !m && (m = t.labelConfig = {}), i = g.fontColor, n = g.fontFamily, l = g.fontBold, E = g.toolText, a = g.link, _ ? (M = _[0], P = _[1]) : (M = \"center\", P = \"middle\"), m.align = M, m.vAlign = P, m.bgColor = \"\", m.borderColor = \"\", m.fontColor = i, m.fontFamily = n, m.fontBold = l, m.toolText = E, m.link = a, \"object\" === r(g.options)) for (Y = g.entityLabels = g.entityLabels || [], U = (J = g.labels || []).length; U--;) {\n            Y[U] || (Y[U] = {\n              config: {}\n            }), m = Y[U].config, (_ = J[U].labelAlignment) ? (M = _[0], P = _[1]) : (M = \"center\", P = \"middle\"), m.align = M, m.vAlign = P, m.displayValue = this.getDisplayValue(t, J[U], g.options.isDataEnabled, !U, o), m.bgColor = \"\", m.borderColor = \"\", m.toolText = E, m.align = M, m.vAlign = P, m.bgColor = \"\", m.borderColor = \"\", m.fontColor = i, m.fontFamily = n, m.fontBold = l, m.toolText = E;\n          } else K = {\n            shortText: g.shortLabel,\n            text: g.label\n          }, m.displayValue = this.getDisplayValue(t, K, !0, !0, o);\n        }, t.prototype.getDisplayValue = function (e, t, o, r, a) {\n          var i = this.getFromEnv(\"chart\").config.entityOpts,\n              n = e.config,\n              l = n.cleanValue,\n              c = n.formattedValue,\n              d = i.labelSepChar,\n              h = void 0;\n          return o ? r && \"undefined\" != typeof a.displayvalue ? h = a.displayvalue : (h = (0, s.pluck)(i.includeNameInLabels ? i.useShortName ? t.shortText : t.text : \"\"), i.includeValueInLabels && null !== l && (h = h === f ? c : h + d + c)) : h = n.label, h;\n        }, t._sanitizeEntityOptions = function (e) {\n          return delete e.outlines, delete e.label, delete e.shortlabel, delete e.labelposition, delete e.labelalignment, delete e.labelconnectors, e;\n        }, t.prototype._redefineEntities = function (e) {\n          var t = this.config,\n              o = {},\n              r = {},\n              a = this.getFromEnv(\"chart\").config.entities,\n              i = t.useSNameAsId,\n              n = void 0,\n              l = void 0,\n              c = void 0,\n              d = void 0,\n              h = void 0,\n              p = void 0,\n              u = void 0,\n              f = void 0,\n              g = 0,\n              m = void 0,\n              b = void 0,\n              v = void 0,\n              k = void 0;\n\n          for (n = e.length; n--;) {\n            if (c = (l = e[n]).internalid, d = l.newid ? l.newid : c, h = l.sname, p = l.lname, k = a[c], c = (0, s.trimString)(c), d = (d = (0, s.trimString)(d)) && d.toLowerCase(), k) {\n              for (v in o[d] = f = {\n                origId: c\n              }, r[c] = !0, k) {\n                f[v] = k[v];\n              }\n\n              f.shortLabel = h || k.shortLabel, f.label = p || k.label, f.showhovereffect = l.showhovereffect, f.fillhovercolor = l.fillhovercolor, f.fillhoveralpha = l.fillhoveralpha, f.fillhoverangle = l.fillhoverangle, f.fillhoverratio = l.fillhoverratio, f.borderhoverthickness = l.borderhoverthickness;\n            }\n          }\n\n          for (u in (b = this.components.data) || (b = this.components.data = {}), o) {\n            b[u = u.toLowerCase()] || (b[u] = {\n              config: {}\n            }), b[u].config = o[u], g += 1;\n          }\n\n          for (u in m = b, a) {\n            if (f = a[u], !r[u = (0, s.trimString)(u)]) {\n              for (v in i ? ((k = m[f.shortLabel.toLowerCase()]) || (k = m[f.shortLabel.toLowerCase()] = {}), k.config = {}, k.origId = f.shortLabel) : ((k = m[u.toLowerCase()]) || (k = m[u.toLowerCase()] = {}), k.config = {}, k.config.origId = u), f) {\n                k.config[v] = f[v];\n              }\n\n              g += 1;\n            }\n          }\n\n          t.entityCount = g;\n        }, t.prototype.draw = function () {\n          var e = this.config,\n              t = this.getFromEnv(\"chart\"),\n              o = s.hasSVG ? 200 : 10;\n          this.createContainer(), this.config.ready = !1, e.BATCH_SIZE = o, e.labelBatchSize = s.hasSVG ? 200 : 20, this._batchRender()(0), t.config.entityFlag = !0, t.checkComplete();\n        }, t.prototype._batchRender = function () {\n          var e = this,\n              t = e.config,\n              o = e.getFromEnv(\"chart\").config.entities.firstEntity,\n              r = e.components.data,\n              a = t.BATCH_SIZE,\n              i = t.entityKeys = o ? e._getKeys(o, r) : Object.keys(r),\n              n = t.entityLength = i.length,\n              l = void 0,\n              s = void 0,\n              d = void 0,\n              h = void 0,\n              p = void 0;\n          return function u(t) {\n            for (l = t, d = 0; i[l] !== f;) {\n              if (s = r[i[l]], p = e.drawEntity(s, a), d += p, s.config.drawn && ((h = l === n - 1 ? s : r[i[l - 1]]) && (h.config.drawn = !1, h.config.outlineStartIndex = f), l++), d >= a) {\n                e.addJob(\"entityDraw\", u.bind(this, l), c.priorityList.entitydraw);\n                break;\n              }\n            }\n\n            l === n && (e._addEventListenersToEntities(0), e.initComplete());\n          };\n        }, t.prototype._addEventListenersToEntities = function (e) {\n          var t = this.components.data,\n              o = this.config,\n              r = o.BATCH_SIZE,\n              a = o.entityKeys,\n              i = void 0,\n              n = o.entityLength,\n              l = void 0,\n              s = 0,\n              d = void 0;\n\n          for (i = e; i < n; i++) {\n            if ((d = (l = t[a[i]]).config.options) && !1 === d.isDataEnabled || this.addMouseGestures(l), ++s === r) {\n              this.addJob(\"_addEventListenersToEntities\", this._addEventListenersToEntities.bind(this, i), c.priorityList.entitydraw);\n              break;\n            }\n          }\n        }, t._getKeys = function (e, t) {\n          for (var o = [e], r = e; t[r];) {\n            r = t[r].nextId, o.push(r);\n          }\n\n          return o;\n        }, t.prototype._getDefaultTooltip = function (e, t) {\n          var o = e.config.cleanValue,\n              a = e.config.formattedValue,\n              i = this.getFromEnv(\"chart\").config.entityOpts,\n              n = void 0,\n              l = void 0;\n\n          if (\"object\" === r(e.config.options)) {\n            if (!(l = t.labels && t.labels[0])) return f;\n            n = (i.useSNameInTooltip ? l.shortText : l.text) + (null === o ? \"\" : i.tooltipSepChar + a);\n          } else n = (i.useSNameInTooltip ? t.shortLabel : t.label) + (null === o ? \"\" : i.tooltipSepChar + a);\n\n          return n;\n        }, t.prototype.drawEntity = function (e, t) {\n          var o,\n              a,\n              i = this.getFromEnv(\"chart\"),\n              n = i.getFromEnv(\"animationManager\"),\n              l = e.config,\n              c = s.hasSVG || !m ? \"litepath\" : \"path\",\n              d = i.config.entityOpts,\n              h = l.outlines,\n              p = this.getFromEnv(\"toolTipController\"),\n              u = this.getLinkedParent().getChildContainer(\"plot\"),\n              g = this.getLinkedParent().getChildContainer(\"plotShadow\"),\n              b = l.toolText,\n              v = d.shadow,\n              k = void 0,\n              y = [],\n              C = void 0,\n              w = void 0,\n              F = void 0,\n              E = void 0,\n              x = void 0,\n              L = {};\n\n          if (this._configureEntityDrawingParams(e), C = (l = e.config).visibleEntityAttr, a = l.shadowOptions, k = l.outlineStartIndex === f ? h.length : l.outlineStartIndex, e.graphics || (e.graphics = {}), x = 0, y = l.outlinePath || (l.outlinePath = []), o = l.customStrokeWidthModifier, \"object\" === r(l.options)) {\n            for (; k--;) {\n              if (y = h[k].outline, w = !0 === l.options.isDataEnabled ? C : (0, s.extend2)((0, s.extend2)({}, C), A(h[k].style, o)), (F = e.graphics.outlines) || (F = e.graphics.outlines = []), !F[k] && (F[k] = {}), E = F[k].outline, w[c] = y, (E = F[k].outline = n.setAnimation({\n                el: c,\n                container: u,\n                attr: w,\n                component: this,\n                label: \"path\"\n              })).shadow(!!v && a, g), p.enableToolTip(E, b), x++, l.outlineStartIndex = k, x === t) return x;\n            }\n\n            return l.drawn = !0, x;\n          }\n\n          for (; k--;) {\n            if (y = h[k].concat(y), x++, l.outlineStartIndex = k, x === t) return l.outlinePath = y, x;\n          }\n\n          return !e.graphics.outlines && (C[c] = y), Object.assign(L, C, e.hidden && {\n            \"fill-opacity\": 0\n          } || {}), e.graphics.outlines = n.setAnimation({\n            el: e.graphics.outlines || c,\n            container: u,\n            attr: L,\n            component: this,\n            label: \"path\"\n          }), l.drawn = !0, l.outlineStartIndex = 0, l.outlinePath = [], e.graphics.outlines.shadow(!!v && a, g), p.enableToolTip(e.graphics.outlines, b), x;\n        }, t.prototype._configureEntityDrawingParams = function (e) {\n          var t = this.getFromEnv(\"chart\"),\n              o = e.config,\n              r = t.config.entityOpts,\n              a = t.config.scalingParams,\n              i = !m || s.hasSVG,\n              n = a.scaleFactor,\n              l = a.strokeWidth,\n              c = (i ? t.baseScaleFactor : 1) * l,\n              d = 1 === r.scaleBorder,\n              h = o.borderThickness,\n              p = o.alphaArr,\n              u = o.origConnectorThickness,\n              f = o.hoverBorderThickness,\n              g = o.visibleEntityAttr,\n              v = g[\"fill-opacity\"],\n              y = void 0;\n          o.shadowOptions = {\n            scalefactor: [n, n * t.config.baseScaleFactor],\n            opacity: k.apply(b, p) / 100,\n            useFilter: 0\n          }, o.fillOpacity = e.hidden ? 0 : v, i ? (h = o.entityBorderThickness = d ? h * c : h / n, u /= n, y = d ? n : a.sFactor, f && (f = o.hoverBorderThickness = d ? f * c : f / n)) : (h = d ? h * l : h, y = d ? a.scaleFactor : t.baseScaleFactor), o.entityBorderThickness = h, o.connectorThickness = u, o.customStrokeWidthModifier = y, g[\"stroke-width\"] = h, g.transform = s.hasSVG || !m ? \"\" : a.transformStr;\n        }, t.prototype.drawLabels = function (e) {\n          var t = e,\n              o = this.getFromEnv(\"chart\"),\n              r = this.config,\n              a = r.labelBatchSize,\n              n = r.entityLength,\n              l = [],\n              s = void 0,\n              c = void 0,\n              d = o.getChildContainer(\"upperAnnotationGroup\"),\n              h = void 0,\n              p = void 0,\n              u = 0,\n              f = this.getChildren(\"mapLabelAnnotations\") && this.getChildren(\"mapLabelAnnotations\")[u],\n              g = 0,\n              m = 0,\n              b = o.config.annotationConfig;\n\n          for (s in f || (p = new i[\"default\"](), this.attachChild(p, \"mapLabelAnnotations\"), (f = this.getChildren(\"mapLabelAnnotations\")[u]).addCustomGroup(d)), f.destroy(), f._renderer && (f._renderer = null), b.showbelow = 0, t) {\n            if (this.drawLabel(t[s], l), ++g === a) {\n              for (c = 0; c < l.length; c++) {\n                l[c].animationLabel = \"entityLabel\";\n              }\n\n              for (h = f.addGroup(Object.assign(b, {\n                id: \"entityLabels\" + u,\n                items: l,\n                animationLabel: \"entityLabelGroup\"\n              }), this), c = 0; c < h.items.length; c++) {\n                h.items[c].addEventListener(\"fc-mouseover\", l[c].onmouseover), h.items[c].addEventListener(\"fc-mouseout\", l[c].onmouseout), h.items[c].addEventListener(\"fc-click\", l[c].onclick);\n              }\n\n              u++, (f = this.getChildren(\"mapLabelAnnotations\") && this.getChildren(\"mapLabelAnnotations\")[u]) || (p = new i[\"default\"](), this.attachChild(p, \"mapLabelAnnotations\"), (f = this.getChildren(\"mapLabelAnnotations\")[u]).addCustomGroup(d)), f.destroy(), f._renderer && (f._renderer = null), g = 0, l = [];\n            } else if (m === n - 1) {\n              for (c = 0; c < l.length; c++) {\n                l[c].animationLabel = \"entityLabel\";\n              }\n\n              for (h = f.addGroup(Object.assign(b, {\n                id: \"entityLabels\" + u,\n                items: l,\n                animationLabel: \"entityLabelGroup\"\n              }), this), c = 0; c < h.items.length; c++) {\n                h.items[c].addEventListener(\"fc-mouseover\", l[c].onmouseover), h.items[c].addEventListener(\"fc-mouseout\", l[c].onmouseout), h.items[c].addEventListener(\"fc-click\", l[c].onclick);\n              }\n            }\n\n            m++;\n          }\n\n          this.drawLabelConnFn(0);\n        }, t.prototype.drawLabelConnFn = function (e) {\n          var t = this.config,\n              o = this.components.data,\n              a = t.BATCH_SIZE,\n              i = t.entityKeys,\n              n = void 0,\n              l = void 0,\n              s = i.length,\n              d = void 0,\n              h = void 0,\n              p = void 0,\n              u = 0;\n\n          for (l = e; l < s; l++) {\n            if (h = (p = o[i[l]]).config, \"object\" === r(h.options)) for (n = (d = h.labels) && d.length || 0; n--;) {\n              d[n].labelConnectors && (this.drawLabelConnectors(p, d[n].labelConnectors, this), u++);\n            } else h.labelConnectors && (this.drawLabelConnectors(p, h.labelConnectors, this), u++);\n\n            if (u === a) {\n              this.addJob(\"drawLabelConnectors\", this.drawLabelConnFn.bind(this, l), c.priorityList.entitydraw);\n              break;\n            }\n          }\n        }, t.prototype._getLabelObject = function (e, t, o) {\n          var r = this,\n              a = r.getFromEnv(\"chart\"),\n              i = e.config,\n              n = void 0,\n              l = a.config.scalingParams,\n              s = void 0,\n              c = void 0,\n              d = e.graphics && e.graphics.outlines,\n              h = void 0,\n              p = i.fontSize,\n              u = i.labelPadding,\n              g = i.labels || [],\n              m = i.entityLabels || [],\n              b = void 0,\n              v = void 0,\n              k = void 0,\n              y = void 0,\n              C = void 0,\n              w = void 0,\n              F = void 0;\n          return t !== f ? (F = g[t], h = (n = m[t].config).style = F.style, s = F.labelPosition, c = F.labelAlignment) : (n = e.labelConfig, s = i.labelPosition, c = i.labelAlignment), s ? (b = s[0], v = s[1]) : (b = (k = d.getBBox()).x + k.width / 2, v = k.y + k.height / 2), c ? (y = c[0], C = c[1], \"right\" === y ? b -= u : \"left\" === y && (b += u), \"top\" === C ? v -= u : \"bottom\" === C && (v += u)) : (y = \"center\", C = \"middle\"), w = parseFloat(p) / l.sFactor, !o && h && (h.color && (n.fontColor = h.color), h[\"font-size\"] && (w = parseFloat(h[\"font-size\"]) / l.sFactor), h[\"font-family\"] && (n.fontFamily = h[\"font-family\"]), h[\"font-weight\"] !== f && (n.fontBold = \"bold\" === h[\"font-weight\"])), n.x = b.toString(), n.y = v.toString(), n.wrap = 1, n.type = \"text\", n.fontSize = w, {\n            x: b.toString(),\n            y: v.toString(),\n            wrapwidth: E[y](void 0, b + void 0) - u,\n            wrapheight: x[C](void 0, v + void 0) - u,\n            wrap: 1,\n            type: \"text\",\n            align: n.align,\n            valign: n.vAlign,\n            text: n.displayValue,\n            tooltext: n.toolText,\n            css: n.link !== f && {\n              cursor: \"pointer\",\n              _cursor: \"hand\"\n            },\n            bgcolor: n.bgColor,\n            bordercolor: n.borderColor,\n            fillcolor: n.fontColor,\n            fontsize: n.fontSize,\n            font: n.fontFamily,\n            bold: n.fontBold,\n            onclick: function onclick(t) {\n              var o = e.graphics.outlines,\n                  a = void 0,\n                  i = void 0;\n              if (o instanceof Array) for (a = 0, i = o.length; a < i; a++) {\n                r.entityClick(o[a].outline, t);\n              } else r.entityClick(o, t);\n            },\n            onmouseover: function onmouseover(t) {\n              var o = e.graphics.outlines,\n                  a = void 0,\n                  i = void 0;\n              if (o instanceof Array) for (a = 0, i = o.length; a < i; a++) {\n                r.entityRollOver(o[a].outline, t);\n              } else r.entityRollOver(o, t);\n            },\n            onmouseout: function onmouseout(t) {\n              var o = e.graphics.outlines,\n                  a = void 0,\n                  i = void 0;\n              if (o instanceof Array) for (a = 0, i = o.length; a < i; a++) {\n                r.entityRollOut(o[a].outline, t);\n              } else r.entityRollOut(o, t);\n            },\n            ontouchstart: function ontouchstart(t) {\n              var o = e.graphics.outlines,\n                  a = void 0,\n                  i = void 0;\n              if (o instanceof Array) for (a = 0, i = o.length; a < i; a++) {\n                r.entityRollOver(o[a].outline, t);\n              } else r.entityRollOver(o, t);\n              r.entityRollOver(o, t);\n            }\n          };\n        }, t.prototype.drawLabel = function (e, t) {\n          var o = e.config,\n              a = void 0,\n              i = void 0,\n              n = void 0;\n          if (o.showLabel) if (\"object\" === r(o.options)) for (i = (n = o.labels) && n.length || 0, a = o.options.isDataEnabled; i--;) {\n            t.push(this._getLabelObject(e, i, a, !i));\n          } else t.push(this._getLabelObject(e, f, !0, !0));\n        }, t.prototype.drawLabelConnectors = function (e, t, o) {\n          for (var r = e.config, a = this.getFromEnv(\"chart\"), i = a.getFromEnv(\"animationManager\"), n = a.config.scalingParams, l = o.getLinkedParent().getChildContainer(\"plot\"), c = t && t.length || 0, d = void 0, h = void 0, p = r.showLabel; c--;) {\n            h = t[c], d = e.graphics.connectorElem, p ? e.graphics.connectorElem = d = i.setAnimation({\n              el: e.graphics.connectorElem || \"path\",\n              attr: {\n                path: h,\n                opacity: 1,\n                transform: s.hasSVG || !m ? \"\" : n.transformStr,\n                stroke: (0, s.convertColor)(r.connectorColor, r.connectorAlpha),\n                \"shape-rendering\": \"crisp\",\n                \"stroke-width\": r.connectorThickness\n              },\n              container: l,\n              component: this,\n              label: \"labelConnectors\"\n            }) : d && d.hide();\n          }\n        }, t.prototype.entityClick = function (e, t) {\n          var o = e.node.__entity,\n              r = this.getFromEnv(\"chart\"),\n              a = r.config.scalingParams,\n              i = e.getBBox(),\n              n = r.getFromEnv(\"linkClickFN\"),\n              l = o.config,\n              s = l.link;\n          i.width = i.width * a.scaleFactor, i.height = i.height * a.scaleFactor, i.x = i.x * a.scaleFactor + a.translateX, i.y = i.y * a.scaleFactor + a.translateY, i.x2 = i.x + i.width, i.y2 = i.y + i.height, r.fireChartInstanceEvent(\"entityclick\", l.eventArgs, t), s !== f && n.call({\n            link: s,\n            entity: o,\n            entityBox: i\n          }, !0);\n        }, t.prototype.entityRollOver = function (e, t) {\n          var o = e.node.__entity,\n              r = o.config,\n              a = this.getFromEnv(\"chart\"),\n              i = a.getFromEnv(\"animationManager\"),\n              n = r.hoverAttr;\n          a.plotEventHandler(e, t, \"entityRollOver\"), e.data(\"hovered\") ? clearTimeout(o.config.timer) : r.useHoverColor && r.isVisible && !o.hidden && n && (a.config.hoverEntity = e, i.setAnimation({\n            el: e,\n            attr: n,\n            component: this,\n            state: \"updating\",\n            label: \"path\"\n          }), e.data(\"hovered\", !0));\n        }, t.prototype.entityRollOut = function (e, t) {\n          var o = e.node.__entity,\n              r = this,\n              a = r.getFromEnv(\"chart\"),\n              i = a.getFromEnv(\"animationManager\"),\n              n = o.config.revertAttr;\n          a.plotEventHandler(e, t, \"entityRollOut\"), o.config.timer = setTimeout(function () {\n            !0 !== o.hidden && n && (i.setAnimation({\n              el: e,\n              attr: n,\n              component: r,\n              state: \"updating\",\n              label: \"path\"\n            }), e.data(\"hovered\", !1));\n          }, 100);\n        }, t.prototype.addMouseGestures = function (e) {\n          var t = e.config,\n              o = t.originalId,\n              r = this,\n              a = e.graphics,\n              i = t.useHoverColor,\n              n = t.hoverBorderThickness,\n              l = t.hoverBorderColor,\n              c = t.hoverBorderAlpha,\n              d = t.entityBorderThickness,\n              h = t.borderColor,\n              p = t.borderAlpha,\n              u = t.link,\n              g = t.visibleEntityAttr,\n              m = \"groupId\" + o,\n              b = void 0,\n              v = void 0,\n              k = void 0,\n              y = void 0,\n              C = function C(o) {\n            u !== f && o.css({\n              cursor: \"pointer\",\n              _cursor: \"hand\"\n            }), o.data(\"eventArgs\", t.eventArgs), o.data(\"groupId\", m), o.node.__entity = e, e._listenersBinded || o.on(\"fc-click\", r.entityClick.bind(r, o)).hover(r.entityRollOver.bind(r, o), r.entityRollOut.bind(r, o));\n          };\n\n          for (b in t.eventArgs = {\n            value: t.cleanValue,\n            label: t.label,\n            shortLabel: t.shortLabel,\n            originalId: t.origId,\n            id: t.id || t.origId\n          }, t.legacyEventArgs = {\n            value: t.value,\n            lName: t.label,\n            sName: t.shortLabel,\n            id: t.originalId || t.id\n          }, i && (t.hoverAttr = {\n            fill: (0, s.toRaphaelColor)(t.hoverColor)\n          }, t.revertAttr = {\n            fill: (0, s.toRaphaelColor)(t.fillColor),\n            stroke: (0, s.toRaphaelColor)(t.borderColor, t.borderAlpha)\n          }, t.revertAttr[\"fill-opacity\"] = g[\"fill-opacity\"], n !== d && (t.hoverAttr[\"stroke-width\"] = (0, s.pluckNumber)(n, d), t.revertAttr[\"stroke-width\"] = d), l === h && c === p || (t.hoverAttr.stroke = (0, s.convertColor)(l, c), t.revertAttr.stroke = (0, s.convertColor)(h, p))), a) {\n            if (a.hasOwnProperty(b)) if (a[b] instanceof Array) {\n              for (v = 0, k = (y = a[b]).length; v < k; v++) {\n                C(y[v].outline);\n              }\n\n              e._listenersBinded = !0;\n            } else C(a[b]), e._listenersBinded = !0;\n          }\n        }, t.prototype.getDataLimits = function () {\n          var e = this.config;\n          return {\n            max: e.max,\n            min: e.min\n          };\n        }, t.prototype.createContainer = function () {\n          var e = this.getLinkedParent(),\n              t = this.getFromEnv(\"animationManager\"),\n              o = e.getChildContainer(\"layer0\");\n          !this.getChildContainer(\"abovePlotGroup\") && this.addChildContainer(\"abovePlotGroup\", t.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"abovePlotGroup\",\n              opacity: 1\n            },\n            container: o,\n            component: this,\n            label: \"group\"\n          })), !this.getChildContainer(\"belowPlotGroup\") && this.addChildContainer(\"belowPlotGroup\", t.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"belowPlotGroup\",\n              opacity: 1\n            },\n            container: o,\n            component: this,\n            label: \"group\"\n          }));\n        }, t.prototype.initComplete = function () {\n          var e = this.getFromEnv(\"chart\"),\n              t = this.components.data;\n          this.drawLabels(t), e.config.entitiesReady = !0, e.checkComplete();\n        }, t;\n      }(a.ComponentInterface);\n\n      t[\"default\"] = L;\n    },\n    1110: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var r = [{\n        initialAttr: function initialAttr() {\n          return {\n            opacity: 0\n          };\n        },\n        finalAttr: function finalAttr() {\n          return {\n            opacity: 1\n          };\n        }\n      }];\n      t[\"default\"] = {\n        \"initial.dataset.entities\": function initialDatasetEntities() {\n          return {\n            \"path.appearing\": function pathAppearing() {\n              return r[0].slot = \"plot\", r;\n            },\n            \"path.updating\": function pathUpdating(e) {\n              return [{\n                finalAttr: function finalAttr() {\n                  return e.finalAttr;\n                }\n              }];\n            },\n            \"labelConnectors.appearing\": function labelConnectorsAppearing() {\n              return r[0].slot = \"final\", r;\n            },\n            \"labelConnectors.updating\": null,\n            \"entityLabel.appearing\": function entityLabelAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }];\n            },\n            \"*\": null\n          };\n        },\n        \"initial.dataset.markers\": function initialDatasetMarkers() {\n          return {\n            markers: null,\n            \"markerItem.appearing\": function markerItemAppearing() {\n              return r[0].slot = \"final\", r;\n            },\n            \"markerItem.updating\": function markerItemUpdating(e) {\n              return [{\n                finalAttr: function finalAttr() {\n                  return e.finalAttr;\n                }\n              }];\n            }\n          };\n        },\n        \"initial.group.mapGroup\": function initialGroupMapGroup() {\n          return {\n            \"group.appearing\": function groupAppearing(e) {\n              return [{\n                initialAttr: function initialAttr() {\n                  return Object.assign({\n                    opacity: 0\n                  }, e.attr);\n                },\n                finalAttr: function finalAttr() {\n                  return e.attr;\n                },\n                slot: \"plot\"\n              }];\n            },\n            \"group.updating\": function groupUpdating(e) {\n              return [{\n                initialAttr: function initialAttr() {\n                  return Object.assign({\n                    opacity: 0\n                  }, e.attr);\n                },\n                finalAttr: function finalAttr() {\n                  return e.attr;\n                },\n                slot: \"plot\"\n              }];\n            },\n            \"*\": null\n          };\n        }\n      };\n    },\n    1111: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var r = h(o(1109)),\n          a = h(o(539)),\n          i = h(o(193)),\n          n = o(132),\n          l = h(o(1110)),\n          s = o(125),\n          c = o(131),\n          d = o(136);\n\n      function h(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), r = 0; r < o.length; r++) {\n            var a = o[r],\n                i = Object.getOwnPropertyDescriptor(t, a);\n            i && i.configurable && e[a] === undefined && Object.defineProperty(e, a, i);\n          }\n        }(e, t));\n      }\n\n      var u = void 0,\n          f = \"top\",\n          g = \"bottom\",\n          m = \"right\",\n          b = \"left\",\n          v = \"middle\",\n          k = \"center\",\n          y = window.Math,\n          C = y.min,\n          w = y.max,\n          F = function F() {\n        var e = this.dataset.getFromEnv(\"chart\"),\n            t = this.dataset.getChildren(\"mapAnnotations\")[0],\n            o = this.markerShape,\n            r = o.groupConfig,\n            a = o.data(\"unfilteredConfig\"),\n            i = a._markerEventArgs,\n            n = void 0,\n            l = this.config;\n        a.hovereffect && (\"circle\" === o.config.type && (n = (0, s.extend2)({\n          fillcolor: a.hoverfillcolor,\n          fillalpha: a.hoverfillalpha,\n          fillangle: a.hoverfillangle,\n          fillratio: a.hoverfillratio,\n          gradientUnits: \"objectBoundingBox\",\n          radialGradient: 1\n        }, a._hoverattrs)), n = (0, s.extend2)({}, a._hoverattrs), t.update(o.getId(), n)), i || (i = a._markerEventArgs = {\n          x: +a.x,\n          y: +a.y,\n          scaledX: a.x * r.scaleX,\n          scaledY: a.y * r.scaleY,\n          chartX: a.x * r.scaleX + r.grpXShift,\n          chartY: a.y * r.scaleY + r.grpYShift,\n          id: a.id,\n          label: a.label\n        }), (0, c.raiseEventGroup)(l.options.id, \"markerRollOver\", i, e.getFromEnv(\"chartInstance\"), l, u, u, u);\n      },\n          A = function A() {\n        var e = this.dataset.getFromEnv(\"chart\"),\n            t = this.dataset.getChildren(\"mapAnnotations\")[0],\n            o = this.markerShape,\n            r = o.getElement(),\n            a = this.config,\n            i = o.data(\"unfilteredConfig\"),\n            n = void 0;\n        r && i.hovereffect && (\"circle\" === o.config.type && (n = (0, s.extend2)({\n          fillcolor: o.config.rawColor,\n          fillalpha: o.config.rawAlpha,\n          fillangle: o.config.rawAngle,\n          fillratio: o.config.rawRatio,\n          gradientUnits: \"objectBoundingBox\",\n          radialGradient: \"radial\" === o.config.rawFillPattern\n        }, i._defaultattrs)), n = (0, s.extend2)({}, i._defaultattrs), t.update(o.getId(), n)), (0, c.raiseEventGroup)(a.id, \"markerRollOut\", i._markerEventArgs, e.getFromEnv(\"chartInstance\"), u, u, u);\n      },\n          E = function E(e) {\n        var t = this.config.options,\n            o = this.dataset,\n            r = o.getFromEnv(\"chart\"),\n            a = this.markerShape,\n            i = a.config,\n            n = a.groupConfig,\n            l = o.getFromEnv(\"linkClickFN\"),\n            s = a.config.link,\n            c = i._markerEventArgs;\n        s && l && l.call({\n          link: s\n        }, !0), c || (c = i._markerEventArgs = {\n          x: +i.x,\n          y: +i.y,\n          scaledX: i.x * n.scaleX,\n          scaledY: i.y * n.scaleY,\n          chartX: i.x * n.scaleX + n.grpXShift,\n          chartY: i.y * n.scaleY + n.grpYShift,\n          id: t.id,\n          label: t.label\n        }), r.fireChartInstanceEvent(\"markerClick\", c, e);\n      },\n          x = function x(e, t) {\n        var o = e && e.length || !1,\n            r = t || \"id\",\n            a = {},\n            i = void 0;\n        if (!e) return e;\n\n        for (; o--;) {\n          (i = e[o])[r] !== u && (a[i[r].toLowerCase()] = i);\n        }\n\n        return a;\n      };\n\n      (0, n.addDep)({\n        name: \"mapsAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      });\n\n      var L = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.components = {}, o.getLabelAlignment = {\n            top: function top(e, t, o) {\n              return {\n                x: e.toString(),\n                y: (t - o).toString(),\n                align: k,\n                valign: f\n              };\n            },\n            left: function left(e, t, o) {\n              return {\n                x: (e - o).toString(),\n                y: t.toString(),\n                align: m,\n                valign: v\n              };\n            },\n            right: function right(e, t, o) {\n              return {\n                x: (e + o).toString(),\n                y: t.toString(),\n                align: b,\n                valign: v\n              };\n            },\n            bottom: function bottom(e, t, o) {\n              return {\n                x: e.toString(),\n                y: (t + o).toString(),\n                align: k,\n                valign: g\n              };\n            },\n            center: function center(e, t) {\n              return {\n                x: e.toString(),\n                y: t.toString(),\n                align: k,\n                valign: v\n              };\n            }\n          }, o.getWrapWidth = {\n            right: function right() {\n              return arguments[1];\n            },\n            left: function left(e, t) {\n              return e - t;\n            },\n            center: function center(e, t) {\n              return 2 * C(t, e - t);\n            }\n          }, o.getWrapHeight = {\n            top: function top() {\n              return arguments[1];\n            },\n            middle: function middle(e, t) {\n              return 2 * C(t, e - t);\n            },\n            bottom: function bottom(e, t) {\n              return e - t;\n            }\n          }, o.hoverFn = F, o.hoverOutFn = A, o.clickFn = E, o;\n        }\n\n        return p(t, e), t.prototype.getName = function () {\n          return \"markers\";\n        }, t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.configureAttributes = function (e) {\n          if (e) {\n            this.JSONData = e;\n            var t = void 0,\n                o = this.getChildren(\"mapAnnotations\") && this.getChildren(\"mapAnnotations\")[0],\n                r = this.getFromEnv(\"chart\").config.markerOpts;\n            o || (t = new i[\"default\"](), this.attachChild(t, \"mapAnnotations\"), o = this.getChildren(\"mapAnnotations\")[0]), o.destroy(), this.calculateDataLimits(), r.dataEnabled ? this._parseMarkers() : this.defineMarkersNShapes(), this.configureConnectors();\n          }\n        }, t.prototype.calculateMarkerRadiusLimits = function () {\n          if (this.JSONData) {\n            var e = this.JSONData,\n                o = this.config,\n                r = this.getFromEnv(\"chart\"),\n                a = r.config.width,\n                i = r.config.height,\n                n = e.markermaxradius,\n                l = e.markerminradius,\n                s = t.getMarkerRadiusLimits(a, i, n, l);\n            o.minRadius = s.min, o.maxRadius = s.max;\n          }\n        }, t.prototype.calculateDataLimits = function () {\n          var e,\n              t = this.getFromEnv(\"chart\"),\n              o = this.config,\n              r = (t.jsonData.markers || {}).items || [],\n              a = this.getFromEnv(\"number-formatter\"),\n              i = +Infinity,\n              n = -Infinity,\n              l = void 0,\n              s = void 0,\n              c = void 0;\n\n          for (c = 0, e = r.length; c < e; c++) {\n            s = r[c].value, null !== (l = a.getCleanValue(s)) && (i = C(l, i), n = w(l, n));\n          }\n\n          o.min = i, o.max = n;\n        }, t.prototype._parseMarkers = function () {\n          var e = this.getFromEnv(\"chart\"),\n              o = e.jsonData.markers,\n              r = o.items,\n              a = o.shapes,\n              i = e.config.markerOpts,\n              n = this.getFromEnv(\"number-formatter\"),\n              l = this.components.shapeObjs = {},\n              c = this.components.markerObjs = {},\n              d = void 0,\n              h = void 0,\n              p = void 0,\n              f = void 0,\n              g = void 0,\n              m = void 0,\n              b = void 0,\n              v = void 0;\n\n          if (r && r.length) {\n            if (a && a.length) for (h = a.length; h; h -= 1) {\n              (v = (f = a[h - 1]).id.toLowerCase()) && (l[v] = f);\n            }\n\n            for (h = r.length; h--;) {\n              (v = (f = r[h]).id && f.id.toLowerCase()) && ((d = f.value) !== u && \"\" !== d && (d = parseFloat(d)), (g = (p = t._initializeMarkerItem(v, f, null, e)).config.options.shapeid) && \"string\" == typeof g && (g = g.toLowerCase()), b = (m = p.config).options, m.cleanValue = n.getCleanValue(d), null !== m.cleanValue ? m.formattedValue = n.dataLabels(d) : m.formattedValue = u, m.fillColor = (0, s.pluck)(b.fillcolor, b.color, i.fillColor), m.fillAlpha = (0, s.pluck)(b.fillalpha, b.alpha, i.fillAlpha), m.fillRatio = (0, s.pluck)(b.fillratio, i.fillRatio), m.fillAngle = (0, s.pluck)(b.fillangle, i.fillAngle), m.borderThickness = (0, s.pluckNumber)(b.borderthickness, i.borderThickness), m.borderColor = (0, s.pluck)(b.bordercolor, i.borderColor), m.borderAlpha = (0, s.pluck)(b.borderalpha, i.borderAlpha), m.labelPadding = b.labelpadding || i.labelPadding, p.dataset = this, f.__hideMarker && (p._isHidden = !0), g && (p.shapeObj = l[g]), c[v] = p);\n            }\n          }\n        }, t.prototype.defineMarkersNShapes = function () {\n          var e = this.getFromEnv(\"chart\"),\n              o = e.jsonData.markers,\n              r = o.definition,\n              a = this.getFromEnv(\"number-formatter\"),\n              i = e.config.markerOpts,\n              n = x(r) || {},\n              l = x(o.application) || {},\n              c = o.shapes,\n              d = this.components.shapeObjs = this.components.shapeObjs || (this.components.shapeObjs = {}),\n              h = this.components.markerObjs = this.components.markerObjs || (this.components.markerObjs = {}),\n              p = {},\n              f = {},\n              g = void 0,\n              m = void 0,\n              b = void 0,\n              v = void 0,\n              k = void 0,\n              y = void 0,\n              C = void 0,\n              w = void 0;\n\n          if (r && r.length) {\n            for (v in d) {\n              p[v] = !1;\n            }\n\n            for (v in h) {\n              f[v] = !1;\n            }\n\n            if (c && c.length) for (v = c.length; v; v -= 1) {\n              (w = (y = c[v - 1]).id.toLowerCase()) && (d[w] = y, p[w] = !0);\n            }\n\n            for (w in n) {\n              y = n[w], k = h[w] = t._initializeMarkerItem(w, y, l[w], e), f[w] = !0, k.dataset = this, C = k.config.options.shapeid, m = k.config, b = y.value, m.cleanValue = a.getCleanValue(b), g = m.options, null !== m.cleanValue ? m.formattedValue = a.dataLabels(b) : m.formattedValue = u, m.fillColor = (0, s.pluck)(g.fillcolor, g.color, i.fillColor), m.fillAlpha = (0, s.pluck)(g.fillalpha, g.alpha, i.fillAlpha), m.fillRatio = (0, s.pluck)(g.fillratio, i.fillRatio), m.fillAngle = (0, s.pluck)(g.fillangle, i.fillAngle), m.borderThickness = (0, s.pluckNumber)(g.borderthickness, i.borderThickness), m.borderColor = (0, s.pluck)(g.bordercolor, i.borderColor), m.borderAlpha = (0, s.pluck)(g.borderalpha, i.borderAlpha), m.labelPadding = g.labelpadding || i.labelPadding, m.options.tooltext = (0, s.pluck)(g.tooltext, i.tooltext), m.link = g.link, C && (k.shapeObj = d[C.toLowerCase()]);\n            }\n\n            for (v in p) {\n              p[v] || delete d[v];\n            }\n\n            for (v in h) {\n              f[v] || delete h[v];\n            }\n          }\n        }, t.getMarkerRadiusLimits = function (e, t, o, r) {\n          var a = C(e, t),\n              i = .02 * a,\n              n = .07 * a;\n          return r = parseFloat(r), o = parseFloat(o), isNaN(r) || isNaN(o) ? isNaN(r) ? isNaN(o) ? {\n            min: i,\n            max: n\n          } : {\n            min: parseInt(o / 10, 10),\n            max: o\n          } : {\n            min: r,\n            max: 10 * r\n          } : r < o ? {\n            min: r,\n            max: o\n          } : {\n            min: o,\n            max: r\n          };\n        }, t.prototype.getDataLimits = function () {\n          var e = this.config;\n          return {\n            min: e.min,\n            max: e.max\n          };\n        }, t._initializeMarkerItem = function (e, t, o) {\n          var r,\n              a = {},\n              i = a.config;\n          return i || (i = a.config = {}), i.id = e, i.definition = t, i.application = o, i.hasValue = null, i.value = null, i.options = null, i.label = null, i.markerShape = null, i.markerLabel = null, i.drawOptions = {\n            shape: null,\n            label: null\n          }, i.drawComplete = !1, r = a.config.options = (0, s.extend2)({}, i.definition), i.dataEnabled ? isNaN(r.value) || \"\" === r.value || (a.value = parseFloat(r.value), a.hasValue = !0) : i.applyAll ? i.options = (0, s.extend2)(r, i.application) : o && (i.options = (0, s.extend2)(r, i.application)), a;\n        }, t.prototype.configureConnectors = function () {\n          var e = this.getFromEnv(\"chart\"),\n              t = this.getChildren(\"mapAnnotations\")[0],\n              o = e.jsonData,\n              r = this.components,\n              a = o.markers || {},\n              i = a.connector || a.connectors || [],\n              n = r.markerObjs,\n              l = i.length,\n              c = this.components.connectors,\n              d = function d(o) {\n            return function (r) {\n              var a = this.data(\"unfilteredConfig\");\n              a.hoverEffect && t.update(this.getId(), a._hoverAttrs), e.fireChartInstanceEvent(\"connectorrollover\", o, r);\n            };\n          },\n              h = function h(o) {\n            return function (r) {\n              var a = this.data(\"unfilteredConfig\");\n              a.hoverEffect && t.update(this.getId(), a._defaultAttrs), e.fireChartInstanceEvent(\"connectorrollout\", o, r);\n            };\n          },\n              p = function p(t) {\n            return function (o) {\n              e.fireChartInstanceEvent(\"connectorClick\", t, o);\n            };\n          },\n              u = e.config.connectorOpts,\n              f = {},\n              g = void 0,\n              m = void 0,\n              b = void 0,\n              y = void 0,\n              C = void 0,\n              w = void 0,\n              F = void 0,\n              A = void 0,\n              E = void 0,\n              x = void 0,\n              L = void 0,\n              N = void 0,\n              S = void 0,\n              O = void 0;\n\n          for (c = this.components.connectors = [], O = 0; O < l; O++) {\n            ((S = i[O]).from || S.to) && (m = n[S.from.toLowerCase()], b = n[S.to.toLowerCase()], m && b && (y = i[O].label, !(f = c[O]) && (f = c[O] = {}), !f.config && (g = f.config = {}), !f.graphics && (f.graphics = {}), (g = f.config = (0, s.extend2)({}, S)).fromMarker = m, g.toMarker = b, g.link = S.link, g.showTooltip = (0, s.pluckNumber)(S.showtooltip, u.showTooltip), C = g.tooltext = g.showTooltip ? (0, s.pluck)(S.tooltext, u.tooltext) : \"\", w = g.thickness = (0, s.pluck)(S.thickness, u.thickness), F = g.color = (0, s.pluck)(S.color, u.color), A = g.alpha = (0, s.pluck)(S.alpha, u.alpha), g.hoverEffect = (0, s.pluckNumber)(S.showhovereffect, u.showHoverEffect), E = (0, s.pluck)(S.hovercolor, u.hoverColor, F), x = (0, s.pluck)(S.hoveralpha, u.hoverAlpha, A), L = (0, s.pluck)(S.hoverthickness, u.hoverThickness, w), g.dashed = (0, s.pluck)(S.dashed, u.dashed), g.dashLen = (0, s.pluckNumber)(S.dashlen, u.dashlen), g.dashGap = (0, s.pluckNumber)(S.dashgap, u.dashgap), C && (g.tooltext = C = (0, s.parseUnsafeString)((0, s.parseTooltext)(C, [3, 40, 41, 42, 43], {\n              label: y,\n              fromId: m.config.definition.id,\n              toId: b.config.definition.id,\n              fromLabel: m.config.definition.label,\n              toLabel: b.config.definition.label\n            }, void 0))), g.eventArgs = {\n              fromMarkerId: m.config.id,\n              toMarkerId: b.config.id,\n              label: y\n            }, g._hoverAttrs = {\n              color: E,\n              alpha: x,\n              thickness: L\n            }, g._defaultAttrs = {\n              color: F,\n              alpha: A,\n              thickness: w\n            }, g.type = \"line\", g.onclick = p(g.eventArgs), g.onmouseover = d(g.eventArgs), g.onmouseout = h(g.eventArgs), y && (!(N = f.labelConfig) && (N = f.labelConfig = {}), N.type = \"text\", N.text = y, N.align = k, N.valign = v, N.font = u.font, N.fillcolor = u.fontColor, N.bgcolor = u.labelBgColor, N.bordercolor = u.labelBorderColor, N.tooltext = g.tooltext)));\n          }\n        }, t.prototype.draw = function () {\n          var e = this.getFromEnv(\"chart\"),\n              t = this.config,\n              o = this.getChildren(\"mapAnnotations\")[0],\n              r = this.components.markerObjs,\n              a = e.config,\n              i = a.markerOpts,\n              n = a.scalingParams,\n              l = e.config.annotationConfig,\n              s = [],\n              c = [],\n              h = {},\n              p = void 0,\n              u = void 0,\n              f = void 0,\n              g = void 0,\n              m = void 0,\n              b = void 0,\n              v = void 0;\n\n          for (m in this.createContainer(), this._drawConnectors(), this.imageLoadCount = 0, this.imageCount = 0, v = o.addGroup(Object.assign(l, {\n            id: \"markers\",\n            fillalpha: \"100\",\n            items: s,\n            scaleimages: 1\n          }), this), b = o.addGroup(Object.assign(l, {\n            id: \"markerLabels\",\n            items: c,\n            scaleimages: 1\n          }), this), this.components.markerGroup = v, this.components.markerLabelGroup = b, t.autoScale = i.autoScale ? n.sFactor : 1, r) {\n            p = null, (g = (u = r[m]).config).conIsHidden || (p = this._drawMarkerItem.call(u)), p && (g._annotationIndex = s.length, h[m] = u, p.markerShape && (f = Object.assign({\n              align: \"center\",\n              valign: \"middle\",\n              animationLabel: \"markerItem\",\n              autoscale: \"image\" === p.markerShape.type ? 0 : 1\n            }, p.markerShape), u.markerShape = o.addItem(v.getId(), f, this)), u.markerShape.data(\"unfilteredConfig\", f), s.push(u.markerShape), p.markerLabel && (f = Object.assign({\n              animationLabel: \"markerItem\"\n            }, p.markerLabel), u.markerLabel = o.addItem(b.getId(), f, this), u.markerLabel.data(\"unfilteredConfig\", f)), c.push(u.markerLabel));\n          }\n\n          this.addJob(\"buildKdtree\", this._buildKdTree.bind(this), d.priorityList.kdTree);\n        }, t.prototype._buildKdTree = function () {\n          var e = this.components.kdArrayMap,\n              t = this.components.markerGroup,\n              o = [],\n              r = void 0,\n              i = void 0,\n              n = t && t.items,\n              l = n && n.length || 0;\n\n          for (i = 0; i < l; i++) {\n            e[r = n[i].config.id] && o.push(e[r]);\n          }\n\n          this.components.kDTree || (this.components.kDTree = new a[\"default\"](!0)), this.components.kDTree._setSearchLimit(Infinity, Infinity), this.components.kDTree.buildKdTree(o);\n        }, t.prototype._drawMarkerItem = function () {\n          var e,\n              t,\n              o,\n              r,\n              a,\n              i,\n              n,\n              l,\n              c = this,\n              d = c.dataset,\n              h = d.getFromEnv(\"chart\"),\n              p = h.config,\n              g = d.config,\n              m = p.scalingParams,\n              b = c.config,\n              v = b.options,\n              k = b.definition,\n              y = p.markerOpts,\n              C = y.dataLabels.style,\n              w = v.shapeid,\n              F = v.scale || 1,\n              A = v.label || \"\",\n              E = h.config.scalingParams.scaleFactor * h.config.baseScaleFactor,\n              x = (v.labelpos || f).toLowerCase(),\n              L = b.formattedValue === u ? u : b.formattedValue,\n              N = v.tooltext || y.tooltext,\n              S = (0, s.pluckNumber)(k.radius, b.radius, y.radius) * F * g.autoScale || 1e-4,\n              O = b.fillColor,\n              _ = b.fillAlpha,\n              T = b.fillRatio,\n              I = b.fillAngle,\n              M = b.borderThickness,\n              P = b.borderColor,\n              j = b.borderAlpha,\n              D = d.getChildren(\"mapAnnotations\")[0],\n              B = void 0,\n              R = void 0,\n              V = void 0,\n              G = void 0,\n              H = void 0,\n              W = void 0,\n              z = void 0,\n              X = void 0,\n              Y = void 0,\n              K = void 0,\n              J = d.components.kdArrayMap || (d.components.kdArrayMap = {}),\n              U = c.config.id;\n          if (b.autoScale = y.autoScale ? E : 1, w) return N = N ? (0, s.parseUnsafeString)((0, s.parseTooltext)(N, [1, 2, 3], {\n            formattedValue: L,\n            label: A\n          }, v)) : L ? A + y.tooltipSepChar + L : A, L !== u && null !== L ? A = A + y.labelSepChar + L : isNaN(F) ? F = 1 : F < 0 ? F = 0 : F > 5 && (F = 5), (0, s.extend2)(v, {\n            x: v.x && v.x.toString(),\n            y: v.y && v.y.toString(),\n            fillcolor: O,\n            fillalpha: _,\n            fillratio: T,\n            fillangle: I,\n            borderthickness: M,\n            bordercolor: P,\n            borderalpha: j,\n            hovereffect: (0, s.pluck)(y.showHoverEffect),\n            radius: S && S.toString(),\n            link: v.link,\n            showshadow: (0, s.pluckNumber)(v.showshadow, b.shadow),\n            _markerLabel: A,\n            _markerId: v.id,\n            id: (v.id + \"\").toLowerCase()\n          }), delete v.tooltext, b.tooltext = !!y.showTooltip && N, H = Number(v.x) * m.sFactor + m.translateX, W = Number(v.y) * m.sFactor + m.translateY, S = v.radius, \"triangle\" === w ? ((0, s.extend2)(v, {\n            type: \"polygon\",\n            sides: 3,\n            startangle: y.startAngle\n          }), K = \"polygon\", Y = 3) : \"diamond\" === w ? ((0, s.extend2)(v, {\n            type: \"polygon\",\n            sides: 4,\n            startangle: y.startAngle\n          }), K = \"polygon\", Y = 4) : \"arc\" === w ? (X = .6 * S, (0, s.extend2)(v, {\n            type: \"arc\",\n            startangle: 0,\n            endangle: 360,\n            innerradius: X\n          }), K = \"arc\") : \"circle\" === w ? (v.type = \"circle\", K = \"circle\") : (V = d.getShapeArgs.call(c), y.dataEnabled && y.valueToRadius && v.radius !== u ? delete V.radius : (!V.radius && (V.radius = y.radius), V.radius *= F * b.autoScale), (0, s.extend2)(v, V), v.id = v._markerId && v._markerId.toLowerCase(), X = V.innerradius, V.radius && (S = V.radius), K = V.type && V.type.toLowerCase(), Y = V.sides, (S = Number(S)) && X && S < X && (G = S, v.radius = S = X, v.innerradius = X = G)), v.type = v.type && v.type.toLowerCase(), (0, s.extend2)(v, {\n            hoverfillcolor: (0, s.pluck)(v.fillhovercolor, y.hoverFillColor, v.fillcolor),\n            hoverfillalpha: (0, s.pluck)(v.fillhoveralpha, y.hoverFillAlpha, v.fillalpha),\n            hoverfillratio: (0, s.pluck)(v.fillhoverratio, y.hoverFillRatio, v.fillratio),\n            hoverfillangle: (0, s.pluck)(v.fillhoverangle, y.hoverFillAngle, v.fillangle),\n            hoverborderthickness: (0, s.pluckNumber)(v.borderhoverthickness, y.hoverBorderThickness, v.borderthickness),\n            hoverbordercolor: (0, s.pluck)(v.borderhovercolor, y.hoverBorderColor, v.bordercolor),\n            hoverborderalpha: (0, s.pluck)(v.borderhoveralpha, y.hoverBorderAlpha, v.borderalpha)\n          }), v._hoverattrs = {\n            fillalpha: v.hoverfillalpha,\n            fillcolor: v.hoverfillcolor,\n            fillangle: v.hoverfillangle,\n            fillratio: v.hoverfillratio,\n            borderThickness: \"0\" !== v.showborder ? v.hoverborderthickness : 0,\n            borderColor: v.hoverbordercolor,\n            borderAlpha: v.hoverborderalpha\n          }, v._defaultattrs = {\n            fillalpha: v.fillalpha,\n            fillcolor: v.fillcolor,\n            fillangle: v.fillangle,\n            fillratio: v.fillratio,\n            borderThickness: \"0\" !== v.showborder ? v.borderthickness : 0,\n            borderColor: v.bordercolor,\n            borderAlpha: v.borderalpha\n          }, \"image\" === v.type ? (v.borderthickness = v.borderthickness || 0, v.onload = function (e) {\n            var t = e.width,\n                o = e.height;\n            z = {}, v = this.config, H = (Number(v.derivedX) - t / (2 * m.sFactor)) * m.sFactor, W = (Number(v.derivedY) - o / (2 * m.sFactor)) * m.sFactor, (z = J[U] || (J[U] = {})).x = H + m.translateX, z.y = W + m.translateY, z.element = c, z.shapeInfo = {\n              type: \"rect\",\n              width: t,\n              height: o\n            }, t && o && D.update(this.getId(), {\n              x: H,\n              y: W,\n              width: t,\n              height: o,\n              autoscale: 0\n            }), d.imageLoadCount++, d.imageLoadCount === d.imageCount && d._buildKdTree();\n          }, v.onerror = function () {\n            d.imageLoadCount++, d.imageLoadCount === d.imageCount && d._buildKdTree();\n          }, d.imageCount++) : ((z = J[U] || (J[U] = {})).x = H, z.y = W, z.element = c, z.shapeInfo = {\n            type: K,\n            sides: Y,\n            radius: Number(S) + v.borderthickness / 2,\n            innerradius: X\n          }), b.drawOptions.shape = v, y.showLabels ? (l = v.labelpadding || y.labelPadding, t = (e = d._getLabelOptions(x, l, v)).align, o = e.valign, r = b._labelBaseWidth, a = b._labelBaseHeight, i = b._labelXOffset, n = b._labelYOffset, B = y.labelWrapWidth ? y.labelWrapWidth : d.getWrapWidth[t](r, Number(e.x) + i), R = y.labelWrapHeight ? y.labelWrapHeight : d.getWrapHeight[o](a, Number(e.y) + n), B > l && (B -= l), R > l && (R -= l), b.drawOptions.label = (0, s.extend2)({\n            type: \"text\"\n          }, {\n            text: A,\n            tooltext: v.tooltext,\n            x: e.x,\n            y: e.y,\n            align: t,\n            valign: e.valign,\n            wrap: 1,\n            wrapwidth: B,\n            wrapheight: R,\n            fontsize: C.fontSize / m.sFactor,\n            font: C.fontFamily,\n            fillcolor: C.fontColor\n          }), {\n            markerShape: v,\n            markerLabel: b.drawOptions.label\n          }) : {\n            markerShape: v\n          };\n        }, t.prototype.highlightPoint = function (e, t) {\n          var o = e.element,\n              r = t.originalEvent,\n              a = this.getFromEnv(\"chart\"),\n              i = this.getFromEnv(\"toolTipController\"),\n              n = this.config.currentToolTip,\n              l = a.config.lastHoveredPoint;\n          l && l !== e && (l && this.hoverOutFn.call(l.element), a.config.lastHoveredPoint = null, i.hide(n)), !1 !== e && (\"click\" === t.type || \"touchstart\" === t.type ? (a.config.lastHoveredPoint !== e && this.hoverFn.call(o), this.clickFn.call(o, t)) : \"mousemove\" === t.type && a.config.lastHoveredPoint !== e && this.hoverFn.call(o), o.config.tooltext && (n ? i.draw(r, o.config.tooltext, n) : n = this.config.currentToolTip = i.draw(r, o.config.tooltext)), a.config.lastHoveredPoint = e);\n        }, t.prototype._drawConnectors = function () {\n          var e = this.getFromEnv(\"chart\"),\n              t = e.config.annotationConfig,\n              o = this.components.connectors || (this.components.connectors = []),\n              r = void 0,\n              a = void 0,\n              i = o.length,\n              n = e.config.scalingParams,\n              l = e.config.connectorOpts,\n              s = l.showLabels,\n              c = this.getChildren(\"mapAnnotations\")[0],\n              d = void 0,\n              h = [],\n              p = [],\n              u = void 0,\n              f = void 0,\n              g = void 0,\n              m = void 0,\n              b = void 0,\n              v = void 0,\n              k = void 0,\n              y = [];\n\n          for (y.push({\n            id: \"connectorLabels\",\n            fillalpha: \"100\",\n            items: p\n          }), y.push({\n            id: \"connectors\",\n            fillalpha: \"100\",\n            items: h\n          }), c.addGroup(Object.assign(t, y[1]), this), c.addGroup(Object.assign(t, y[0]), this), d = 0; d < i; d++) {\n            o[d] && (b = o[d].config.fromMarker.config, v = o[d].config.toMarker.config, u = b.options.x, f = b.options.y, g = v.options.x, m = v.options.y, o[d].config.x = u, o[d].config.y = f, o[d].config.tox = g, o[d].config.toy = m, h.push(o[d].config), k = Object.assign({\n              animationLabel: \"markerItem\"\n            }, o[d].config), (r = c.addItem(\"connectors\", k, this)) && r.data(\"unfilteredConfig\", k), r.addEventListener(\"fc-mouseover\", o[d].config.onmouseover), r.addEventListener(\"fc-mouseout\", o[d].config.onmouseout), r.addEventListener(\"fc-click\", o[d].config.onclick), o[d].labelConfig && s && (o[d].labelConfig.x = ((Number(u) + Number(g)) / 2).toString(), o[d].labelConfig.y = ((Number(f) + Number(m)) / 2).toString(), o[d].labelConfig.fontsize = l.fontSize / (n.scaleFactor * e.config.baseScaleFactor), p.push(o[d].labelConfig), k = Object.assign({\n              animationLabel: \"markerItem\"\n            }, o[d].labelConfig), (a = c.addItem(\"connectorLabels\", k, this)) && a.data(\"unfilteredConfig\")));\n          }\n        }, t.prototype.getShapeArgs = function () {\n          var e = this.config,\n              t = (0, s.extend2)({}, this.shapeObj),\n              o = void 0;\n          return e.autoScale = 1, t ? (\"polygon\" === t.type ? t.sides < 3 ? t.type = \"circle\" : t.startangle = e.startAngle : \"arc\" === t.type && (o = (t.radius || e.markerRadius) * e.autoScale, t.radius = o, t.innerradius = t.innerradius && t.innerradius * e.autoScale || .6 * o), t) : null;\n        }, t.prototype._getLabelOptions = function (e, t, o, r, a) {\n          var i,\n              n,\n              l = void 0,\n              s = e && e.toLowerCase();\n          return this.getLabelAlignment[s] || (s = \"center\"), i = Number(o.x), n = Number(o.y), l = r === u || a === u ? o.radius || 0 : /^(top|bottom)$/gi.test(s) && .5 * a || /^(left|right)$/gi.test(s) && .5 * r || 0, l = Number(l) + Number(t), this.getLabelAlignment[s](i, n, l);\n        }, t.prototype.addMarkerItem = function (e) {\n          var o,\n              r = this.getFromEnv(\"chart\"),\n              a = e,\n              i = void 0,\n              n = this.components.markerObjs,\n              l = this.components.shapeObjs,\n              c = this.components.markerGroup,\n              d = this.components.markerLabelGroup,\n              h = this.getChildren(\"mapAnnotations\")[0],\n              p = this.getFromEnv(\"number-formatter\"),\n              f = r.config.markerOpts,\n              g = void 0,\n              m = void 0,\n              b = void 0,\n              v = void 0,\n              k = void 0;\n\n          if (o = a.id.toLowerCase()) {\n            if (n[o]) return;\n            delete a.value, this.imageLoadCount = 0, (i = t._initializeMarkerItem(o, a, null)).dataset = this, k = i.config.options.shapeid, m = i.config, v = a.value, m.cleanValue = p.getCleanValue(v), e = m.options, null !== m.cleanValue ? m.formattedValue = p.dataLabels(v) : m.formattedValue = u, m.fillColor = (0, s.pluck)(e.fillcolor, e.color, f.fillColor), m.fillAlpha = (0, s.pluck)(e.fillalpha, e.alpha, f.fillAlpha), m.fillRatio = (0, s.pluck)(e.fillratio, f.fillRatio), m.fillAngle = (0, s.pluck)(e.fillangle, f.fillAngle), m.borderThickness = (0, s.pluckNumber)(e.borderthickness, f.borderThickness), m.borderColor = (0, s.pluck)(e.bordercolor, f.borderColor), m.borderAlpha = (0, s.pluck)(e.borderalpha, f.borderAlpha), m.labelPadding = e.labelpadding || f.labelPadding, m.options.tooltext = (0, s.pluck)(e.tooltext, f.tooltext), m.link = e.link, k && (i.shapeObj = l[k && k.toLowerCase()]), n[o] = i, g = this._drawMarkerItem.call(i), c && d && (g.markerShape && (b = Object.assign({\n              align: \"center\",\n              valign: \"middle\",\n              animationLabel: \"markerItem\",\n              autoscale: \"image\" === g.markerShape.type ? 0 : 1\n            }, g.markerShape), i.markerShape = h.addItem(c.getId(), b, this), i.markerShape.data(\"unfilteredConfig\", b)), g.markerLabel && (b = Object.assign({\n              animationLabel: \"markerItem\"\n            }, g.markerLabel), i.markerLabel = h.addItem(d.getId(), b, this), i.markerLabel.data(\"unfilteredConfig\", b))), this._buildKdTree();\n          }\n        }, t.prototype.updateMarkerItem = function (e, t) {\n          var o = this.getFromEnv(\"chart\"),\n              r = this.getChildren(\"mapAnnotations\")[0],\n              a = this.components.markerObjs,\n              i = o.config.markerOpts,\n              n = void 0,\n              l = void 0,\n              c = void 0,\n              d = {},\n              h = a[e],\n              p = void 0;\n\n          if (h) {\n            for (l in n = h.config.options, (0, s.extend2)(n, t), this.imageLoadCount = 0, c = h.config, t) {\n              d[l.toLowerCase()] = t[l] && t[l].toString();\n            }\n\n            c.fillColor = (0, s.pluck)(d.fillcolor, d.color, i.fillColor), c.fillAlpha = (0, s.pluck)(d.fillalpha, d.alpha, i.fillAlpha), c.fillRatio = (0, s.pluck)(d.fillratio, i.fillRatio), c.fillAngle = (0, s.pluck)(d.fillangle, i.fillAngle), c.borderThickness = (0, s.pluckNumber)(d.borderthickness, i.borderThickness), c.borderColor = (0, s.pluck)(d.bordercolor, i.borderColor), c.borderAlpha = (0, s.pluck)(d.borderalpha, i.borderAlpha), c.labelPadding = d.labelpadding || i.labelPadding, c.options.tooltext = (0, s.pluck)(d.tooltext, i.tooltext), c.link = d.link, p = this._drawMarkerItem.call(h).markerShape, this._buildKdTree(), r.update(e, p);\n          }\n        }, t.prototype.createContainer = function () {\n          var e = this.getLinkedParent(),\n              t = this.getFromEnv(\"animationManager\"),\n              o = e.getChildContainer(\"layer1\");\n          !this.getChildContainer(\"abovePlotGroup\") && this.addChildContainer(\"abovePlotGroup\", t.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"abovePlotGroup\",\n              opacity: 1\n            },\n            container: o,\n            component: this,\n            label: \"group\"\n          })), !this.getChildContainer(\"belowPlotGroup\") && this.addChildContainer(\"belowPlotGroup\", t.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"belowPlotGroup\",\n              opacity: 1\n            },\n            container: o,\n            component: this,\n            label: \"group\"\n          }));\n        }, t.prototype._removeMarkerItem = function (e) {\n          var t = this.components,\n              o = t.markerObjs,\n              r = o[e],\n              a = t.kdArrayMap,\n              i = void 0,\n              n = void 0;\n          r && (i = r.markerShape, n = r.markerLabel, i && i.dispose(), n && n.dispose(), delete a[e], this._buildKdTree()), delete o[e];\n        }, t.prototype.getElement = function (e) {\n          if (this.components.kDTree) return this.components.kDTree.getNeighbour(e);\n        }, t;\n      }(r[\"default\"]);\n\n      t[\"default\"] = L;\n    },\n    1112: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var r,\n          a = o(138),\n          i = o(125),\n          n = o(132),\n          l = o(1110),\n          s = (r = l) && r.__esModule ? r : {\n        \"default\": r\n      };\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), r = 0; r < o.length; r++) {\n            var a = o[r],\n                i = Object.getOwnPropertyDescriptor(t, a);\n            i && i.configurable && e[a] === undefined && Object.defineProperty(e, a, i);\n          }\n        }(e, t));\n      }\n\n      (0, n.addDep)({\n        name: \"mapsAnimation\",\n        type: \"animationRule\",\n        extension: s[\"default\"]\n      });\n\n      var d = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.getType = function () {\n          return \"group\";\n        }, t.prototype.getName = function () {\n          return \"mapGroup\";\n        }, t.prototype.configure = function () {\n          this._mapChildren(function (e) {\n            e.configure && e.configure();\n          });\n        }, t.prototype.createContainer = function () {\n          var e,\n              t = this.getLinkedParent(),\n              o = this.getFromEnv(\"animationManager\"),\n              r = t.getChildContainer();\n          e = r.plotGroup, !this.getChildContainer(\"plotShadow\") && this.addChildContainer(\"plotShadow\", o.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"manager-plot-shadow\",\n              opacity: 1\n            },\n            container: e,\n            component: this,\n            label: \"group\"\n          })), !this.getChildContainer(\"plot\") && this.addChildContainer(\"plot\", o.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"manager-plot\",\n              opacity: 1\n            },\n            container: e,\n            component: this,\n            label: \"group\"\n          })), !this.getChildContainer(\"layer0\") && this.addChildContainer(\"layer0\", o.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"ann-layer0\",\n              opacity: 1\n            },\n            container: r.abovePlotGroup,\n            component: this,\n            label: \"group\"\n          })), !this.getChildContainer(\"layer1\") && this.addChildContainer(\"layer1\", o.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"ann-layer1\",\n              opacity: 1\n            },\n            container: r.abovePlotGroup,\n            component: this,\n            label: \"group\"\n          })), t.config.labelsOnTop ? this.getChildContainer(\"layer0\").toFront() : this.getChildContainer(\"layer0\").toBack();\n        }, t.prototype._transformGroup = function () {\n          var e = this,\n              t = this.getFromEnv(\"chart\"),\n              o = t.getFromEnv(\"chartInstance\"),\n              r = e.getFromEnv(\"animationManager\"),\n              a = t.jsonData,\n              n = e.getChildContainer(\"plot\"),\n              l = e.getChildContainer(\"plotShadow\"),\n              s = t.config.scalingParams;\n          n.hide(), l.hide(), t.config.entitiesReady = !1, o.addEventListener(\"internal.mapdrawingcomplete\", function (t) {\n            t.detachHandler(), i.hasSVG && (o.args.link && o.args.clickedEntityBox && a.chart.linkedcharttransition, n && r.setAnimation({\n              el: n,\n              attr: {\n                transform: s.transformStr\n              },\n              component: e,\n              label: \"group\"\n            }), l && r.setAnimation({\n              el: l,\n              attr: {\n                transform: s.transformStr\n              },\n              component: e,\n              label: \"group\"\n            })), n.show(), l.show();\n          }), t.checkComplete();\n        }, t.prototype.draw = function () {\n          this.createContainer(), this._transformGroup();\n        }, t.prototype.getDataLimits = function (e) {\n          var t = +Infinity,\n              o = -Infinity,\n              r = void 0,\n              a = 0,\n              i = function i(e) {\n            o = Math.max(o, e.max), t = Math.min(t, e.min);\n          };\n\n          return this._mapChildren(function (t) {\n            t.getState(\"removed\") || !1 === t.getState(\"visible\") ? e && (r = t.getDataLimits(e), i(r)) : (a++, r = t.getDataLimits(e), i(r));\n          }), a ? this.setState(\"visible\", !0) : this.setState(\"visible\", !1), this.config.range || (this.config.range = {}, this.config.range.min = this.config.dataMin, this.config.range.max = this.config.dataMax), {\n            max: o,\n            min: t\n          };\n        }, t;\n      }(a.ComponentInterface);\n\n      t[\"default\"] = d;\n    }\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}