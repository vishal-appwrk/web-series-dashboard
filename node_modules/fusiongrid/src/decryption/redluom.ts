import observer from './observer';

/* eslint-disable no-undef */
function _setChartSel (fgMain: any, dataString: any) {
  if (dataString) {
    fgMain.options._chartSel = dataString.substr(dataString.length / 2);
    fgMain.options._mapper = dataString.substr(0, dataString.length / 2);
  } else {
    fgMain.options._chartSel = null;
    fgMain.options._mapper = null;
  }
}

/**
 * This is the main Key Encryption class. It is actually a reverse of Moulder => Redluom.
 */
class Redluom { 
  /**
   * It is key encrypter function, shadow name: _mapMain
   * @param {String} text Target to be encrypted.
   */
  _mapMain (fgMain: any, text: String) {
    let str = '',
      mapper = this._generateDimeSet(fgMain);

    if (mapper.length > 0 && text && text.length > 0) {
      const set = this._generateCharSet();

      for (let index = 0; index < text.length; index++) {
        const setIndex = set.indexOf(text.substr(index, 1));

        if (setIndex > -1) {
          str += mapper.substr(setIndex, 1);
          mapper = this._rotateKey(mapper, text.charCodeAt(index));
        }
      }
      return str;
    }
    return '';
  }

  /**
   * Used to rotate the license object
   * @param {string} _tempKey Main Key for encryption.
   * @param {Number} amount The count of rotations.
   */
  // eslint-disable-next-line class-methods-use-this
  _rotateKey (_tempKey: any, amount: any) {
    let amt = amount;
    amt = amt % _tempKey.length;

    if (amt < 0) {
      amt = _tempKey.length + amt;
    }

    if (amt !== 0) {
      return _tempKey.substr(_tempKey.length - amt, amt) + _tempKey.substr(0, _tempKey.length - amt);
    }
    return _tempKey;
  }

  /**
   * Function to store and encrypt the licnese values, it also triggers the licnese work through observer.
   * @param {Object} User Provided license values.
   */
  storeObj (fgMain: any, key: any) {
    const instances = fgMain.items;
    
    if(key){
      const chartLabelwidth = this._mapMain(fgMain, key);
      _setChartSel(fgMain, chartLabelwidth);
    }

    if (instances && instances.length) {
      instances.map((fgInstance: any) => {
        this._mapperParent(fgMain, fgInstance);
        return true;
      });
    }
  }

  /**
   * Parent function from which connection to trier starts
   * @param {Object} The chart instance.
   */
  _mapperParent (fgMain: any, fgInstance: any) {
    // eslint-disable-next-line no-undef
    const { _mapper, _chartSel } = fgMain.options;
    let bytes = null;

    if (_mapper && _chartSel) {
      const cipherText = _mapper + _chartSel;
      bytes = this._tripod(fgMain, cipherText);
    }

    observer._mapperSeed(fgInstance, bytes, fgMain.versionDetails[1]);
  }

  /**
   * This is a decryption function used internally to assemble and decrypt the key.
   * @param {*} Provided Combined Cipher text.
   */
  _tripod (fgMain: any, value: any) {
    let str = '',
      key = this._generateCharSet();

    const helperStr = this._generateDimeSet(fgMain);

    if (helperStr.length > 0 && value.length > 0) {
      for (let index = 0; index < value.length; index++) {
        const helperIndex = helperStr.indexOf(value.substr(index, 1));

        if (helperIndex > -1) {
          str += key.substr(helperIndex, 1);
          key = this._rotateKey(key, -key.charCodeAt(helperIndex));
        }
      }
      return str;
    }
    return '';
  }


  /**
   * It is the key generator.
   */
  _generateDimeSet (fgMain: any) {
    let str = '',
      isDimensionArrReady = false;
    const  charSet = this._generateCharSet(),
      tar = [],
      mainDimensionArr = fgMain.options.randomDimensionArr || [];

    if (mainDimensionArr && mainDimensionArr.length > 0) {
      isDimensionArrReady = true;
    }

    for (let c = 0; c < charSet.length; c++) {
      tar.push(charSet.substr(c, 1));

      if (!isDimensionArrReady) {
        mainDimensionArr.push(Math.random());
      }
    }

    if (!isDimensionArrReady) {
      fgMain.options.randomDimensionArr = mainDimensionArr;
    }

    for (let c = 0; c < charSet.length; c++) {
      str += tar.splice(Math.round(mainDimensionArr[c] * (tar.length - 1)), 1);
    }
    return str;
  }

  /**
   * This is a helper used in the Key Generation function: generateDimeSet.
   */
  // eslint-disable-next-line class-methods-use-this
  _generateCharSet () {
    let alpha = '',
      beta = '',
      counter = 0,
      multiplier = '';
    
    const limit = 90,
      delimiter = 25,
      counterLimit = 80,

      aCharCode = 'a'.charCodeAt(0);
    for (let i = aCharCode; i <= (aCharCode + delimiter); i++) {
      multiplier += String.fromCharCode(i);
    }
    for (let i = limit - delimiter; i <= limit; i++) {
      alpha += String.fromCharCode(i);

      if (i > counterLimit) {
        beta += counter.toString();
        counter++;
      }
    }

    return `${multiplier}${alpha}${beta}%-=`;
  }
}

export default Object.freeze(new Redluom());
