/**
 * This component is used to validate the license key provided by the user
 * and draw watermark accordingly.
 */
export default class Trier {
  /**
     * First check of license attribute and creditLabel attribute
     * @param fgInstance: {Object} The grid instance.
     * @param trierKey: {string} The license hash key.
     * @param utilityArrSet: {Array} The modules to chart map array.
     */
  trierFirst (fgInstance: any, trierKey: String, utilityArrSet: Array<any>, releaseDate: Date) {
    const trierObj = this._trierStraightner(trierKey);
    if (trierObj) {
      const mapObjArr = utilityArrSet.filter(utilityModel => utilityModel.utility_version === trierObj.luv);
      if (mapObjArr && mapObjArr.length > 0) {
        const mapObj = mapObjArr[0],
          isTrierDateValid = this._trierDateMapper(trierObj, mapObj, releaseDate);
        if (isTrierDateValid) {
          const validProductObj = this._trierProductMapper(trierObj, mapObj);
          if (validProductObj) {
            let isDomainValid = false;
            const isMobileDevice = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent),
              match = window.location.href.match(/:\/\/(www[0-9]?\.)?(.[^/:]+)/u);
            if (isMobileDevice && !match) {
              isDomainValid = true;
            } else {
              isDomainValid = this._trierDomainMapper(trierObj, mapObj);
            }
            if (isDomainValid) {
              this._trierValidator(fgInstance);
              return;
            }
          }
          
        }
      }
    }
    this._trierVerifier(fgInstance);
    // eslint-disable-next-line consistent-return
    return false;
  }

  /**
   * Function to call the create credit label method for post-render / set the credit label config to true for pre-render
   * @param fgInstance 
   */
  // eslint-disable-next-line class-methods-use-this
  _trierVerifier(fgInstance: any) {
    let hasRendered;
    fgInstance._stores.hasRendered.subscribe((newValue: any) => {
      hasRendered = newValue;
    });
    if(hasRendered){
      fgInstance.addCreditLabel();
    } else {
      fgInstance._stores.hasCreditLabel.set(true);
    }
  }

  /**
   *  Main function to impact the watermark.
   * @param {Object} The chart instance.
   */
  // eslint-disable-next-line class-methods-use-this
  _trierValidator (fgInstance: any) {
    let hasRendered;
    fgInstance._stores.hasRendered.subscribe((newValue: any) => {
      hasRendered = newValue;
    });
    if(hasRendered){
      fgInstance.removeCreditLabel();
    } else {
      fgInstance._stores.hasCreditLabel.set(false);
    }
  }

  /**
   * One of the decryption step/
   */
  // eslint-disable-next-line class-methods-use-this
  _sumDigits(number: number) {
    const str = number.toString();
    let sum = 0;
  
    for (let i = 0; i < str.length; i++) {
      sum += parseInt(str.charAt(i), 10);
    }
  
    if (sum > 10) {
      // eslint-disable-next-line no-magic-numbers
      return sum % 9 + 1;
    }
  
    return sum;
  }

  /**
   * One of the decryption step/
   */
  // eslint-disable-next-line class-methods-use-this
  _fromRange (charCode: number, ks: number, i: String) {
    let param = Math.abs(Number(i)), cCode = charCode;
  
    while (param-- > 0) {
      cCode -= ks;
    }
  
    if (Number(i) < 0) {
      // eslint-disable-next-line no-magic-numbers
      cCode += 123;
    }
  
    return cCode;
  }

  _foo = function (x: any) {
    return x;
  };

  /**
   * Helper function to decrypt key
   * @param {string} str - hash key
   * @return {object} - JSON with license details or null
   */
  _trierStraightner (str: any) {
    if (!str) {
      return str;
    }

    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
      _bar = this._foo('charCodeAt'),
      _car = this._foo('fromCharCode');
    let decrypted = '', key = chars.indexOf(str[0]);

    for (let i = 1; i < str.length - 2; i++) {
      const ks = this._sumDigits(++key);
      let charCode = str[_bar](i),
        t = '';

      while (/[0-9-]/.test(str[i + 1])) {
        t += str[++i];
      }
      t = String(parseInt(t, 10) || 0);

      charCode = this._fromRange(charCode, ks, t);
      charCode ^= key - 1 & 31;
      decrypted += String.fromCharCode(charCode);
    }

    try {
      return JSON.parse(decrypted);
    } catch {
      return null;
    }
    /* eslint-enable */
  }

  /**
   * Function to check the license date.
   * @param {Object} trierObj : The passed license object.
   * @param {Object} mapObj : Map Object fetched on the basis of LUV.
   */
  // eslint-disable-next-line class-methods-use-this
  _trierDateMapper (trierObj: any, mapObj: any, releaseDt: Date) {
    const trierEndDate = trierObj[mapObj.map.endDate],
      currentDomain = window.location.hostname,
      minimuDateCheck = 45,
      currentDate = new Date();

    let isLocalHost = false;

    if (currentDomain === 'localhost' || currentDomain === '127.0.0.1' || currentDomain === '0.0.0.0') {
      isLocalHost = true;
    }

    if (trierObj[mapObj.map.startDate] && trierEndDate && !trierObj[mapObj.map.isUpgrade]) {
      const releaseDate = new Date(releaseDt),
        endDate = new Date(trierEndDate);

      if (releaseDate > endDate) {
        return false;
      }

      if (isLocalHost && currentDate < endDate) {
        const daysDiff = Math.round((endDate.getTime() - currentDate.getTime()) / (24 * 60 * 60 * 1000));

        if (daysDiff <= minimuDateCheck) {
        // eslint-disable-next-line no-console
          console.warn(`Your FusionGrid license is expiring in ${daysDiff} day(s), please renew to get upgrades and support.`);
        }
      }

      return true;
    } else if (trierObj[mapObj.map.startDate] && trierEndDate && trierObj[mapObj.map.isUpgrade]) {
      return true;
    } else if (trierEndDate) {
      const endDate = new Date(trierEndDate);
      if (currentDate > endDate) {
        return false;
      }

      if (isLocalHost && currentDate < endDate) {
      // eslint-disable-next-line no-magic-numbers
        const daysDiff = Math.round((endDate.getTime() - currentDate.getTime()) / (24 * 60 * 60 * 1000));

        if (daysDiff <= minimuDateCheck) {
        // eslint-disable-next-line no-console
          console.warn(`Your FusionGrid license is expiring in ${daysDiff} day(s), please renew.`);
        }
      }

      return true;
    }

    return false;
  }

  /**
   * Function to check the license product.
   * @param {Object} trierObj : The passed license object.
   * @param {Object} mapObj : Map Object fetched on the basis of LUV.
   */
  _trierProductMapper = function (trierObj: any, mapObj: any) {
    const trierProductName = trierObj[mapObj.map.products];
  
    if (trierProductName) {
  
      if (trierProductName === mapObj.products) {
        return true;
      }
  
      return null;
    }
  
    return null;
  };

  /**
   * Function to check the running domain.
   * @param {Object} trierObj : The passed license object.
   * @param {Object} mapObj : Map Object fetched on the basis of LUV.
   */
  _trierDomainMapper (trierObj: any, mapObj: any) {
    const trierDomain = trierObj[mapObj.map.domain] || 'a',
      currentDomain = this._hostFetcher();
  
    if (!currentDomain) {
      return false;
    }
  
    if (currentDomain === 'localhost' || currentDomain === '127.0.0.1' || currentDomain === '0.0.0.0') {
      return true;
    }
  
    if (trierDomain && trierDomain !== 'a') {
      const trierDomainArr = trierDomain.split(',');
      let isValidDomain = false;
  
      for (let index = 0; index < trierDomainArr.length; index++) {
        const domainItem = trierDomainArr[index].trim().toLowerCase();
  
        if (currentDomain.indexOf(domainItem) > -1) {
          isValidDomain = true;
          break;
        }
      }
  
      return isValidDomain;
    } else if (trierDomain === 'a') {
      return true;
    }
  
    return false;
  }

  /**
   * Function to provide clean host names.
   */
  // eslint-disable-next-line class-methods-use-this
  _hostFetcher () {
    const match = window.location.href.match(/:\/\/(www[0-9]?\.)?(.[^/:]+)/u);
  
    if (match != null && match.length > 2 && typeof match[2] === 'string' && match[2].length > 0) {
      return match[2].toLowerCase();
    }
  
    return null;
  }
}
  