import { DataTable, DataSchema, Schema } from '@fusioncharts/datastore';
import { ColumnType } from '../public-api/interfaces';
import { deriveColumnTypeFromSchema } from '../utils/column-type';
import { GridColumnExtents } from '../globals/helpers/helpers';
export interface GridSchemaIndex extends Schema {
  index: number
}

export default class GridDataTable {

  private _dataTable!: DataTable;
  private _data!: Array<Array<any>>;
  private _schema!: Schema[];  
  private _viewData!: Array<Array<any>>;
  private _quickSearchBase!: Array<Array<any>>;
  private _valueFilterBase!: Array<Array<any>>;

  constructor(dataTable: DataTable) {
    this.setDataTable(dataTable);  
  }

  /**
   * Schema of the datatable used in grid
   */
  get gridSchema(): Schema[] {
    return this._schema;
  }

  get gridData(): Array<Array<any>> {
    return this._data;
  }

  get dataTable(): DataTable {
    return this._dataTable;
  }

  get viewData(): Array<Array<any>> {
    return this._viewData;
  }

  get quickSearchBase(): Array<Array<any>> {
    return this._quickSearchBase;
  }

  get valueFilterBase(): Array<Array<any>> {
    return this._valueFilterBase;
  }

  syncDataTable() {
    this._data = this._viewData;
  }

  /**
   * Set the datatable object for grid
   * @param dataTable DataTable object
   */
  setDataTable(dataTable: DataTable) {
    this._dataTable = dataTable;
    const dataSchema: DataSchema = this._dataTable.getData();
    this._data = dataSchema.data;
    this._viewData = dataSchema.data;
    this._quickSearchBase = dataSchema.data;
    this._valueFilterBase = dataSchema.data;
    this._schema = dataSchema.schema;    
  }

  setViewData(data: Array<Array<any>>){
    this._viewData = data;
  }

  setQuickSearchBase(data: Array<Array<any>>){
    this._quickSearchBase = data;
  }

  setValueFilterBase(data: Array<Array<any>>){
    this._valueFilterBase = data;
  }

  /**
   * Get the table data in 2D array format
   * @param {number} [offset] starting index of data to fetch, default is zero
   * @param {number} [numberOfItems] number of items to fetch, default is all items
   * @returns {2D array} 2D array containing the data
   */
  getRowData(offset?: number, numberOfItems?: number): any[][] {
    return this._dataTable.getData(offset, numberOfItems).data;
  }

  /**
   * Get the total count of data in grid data table
   * @returns {number} total number of records in data table
   */
  getTotalRowCount(): number {
    return this._dataTable.count();
  }

  /**
   * Get tyepf of the column
   * @param fieldName name of the column
   */
  getColumnType(fieldName: string): ColumnType | undefined {

    for (let i = 0; i < this._schema.length; i++) {
      let val = this._schema[i];
      if (val.name === fieldName) {
        return deriveColumnTypeFromSchema(val.type || 'text');
      }
    }

    return;
  }

  /**
   * Get schema and index of the field
   * @param fieldName Name of the field
   */
  getColumnSchema(fieldName: string): GridSchemaIndex | undefined {
    for (let i = 0; i < this._schema.length; i++) {
      if (this._schema[i].name === fieldName) {
        return Object.assign({}, this._schema[i], { index: i });
      }
    }

    return;
  }

  /**
   * Get min and max of the column
   * @param fieldName Name of the field
   */
  getColumnExtents(fieldName: string): GridColumnExtents | undefined {
    const colSchema = this.getColumnSchema(fieldName);
    if (typeof colSchema !== 'undefined') {
      if (colSchema.type === 'number' || colSchema.type === 'datetime') {
        const columnExtents = this._dataTable.extents(fieldName);
        return {
          min: columnExtents.min,
          max: columnExtents.max
        };
      }

      const data = this._data;
      let cellContent: string, minContent, maxContent, minLength, maxLength, cellLength;
      minContent = maxContent = data[0][colSchema.index];
      minLength = maxLength = maxContent.length;
      for (let i = 1; i < data.length; i++) {
        cellContent = data[i][colSchema.index];
        // null == undefined as per abstract equality operator rule        
        if (cellContent != null) {
          cellLength = cellContent.length;
          if (cellLength > maxLength) {
            maxContent = cellContent;
            maxLength = cellLength;
          } else if (cellLength < minLength) {
            minContent = cellContent;
            minLength = cellLength;
          }
        } 
      }

      return {
        min: minContent || '',
        max: maxContent || ''
      };
    }

    return;
  }
}