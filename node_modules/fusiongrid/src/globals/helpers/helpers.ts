import {
  LayoutType,
  LayoutDensityType,
  ValueTextPositionType,
  ValueTextAlignmentType,
  Layout,
  DerivedColumnOptions,
  DerivedRowOptions,
  DomContainerProps,
  templateFn,
  RowSelection
} from '../../public-api/interfaces';
import { GridData } from '../../data-layer/grid-data';
import { InlinechartDimState } from '../../utils/managers/inline-chart-space-manager';
import { getSpanDimension, styleObjectType  } from '../../utils/toolbox/src';

let MIN_COLUMN_WIDTH: number = 0;
/**
 * @type densityType defines density possible types like
 * default, compact, comfortable
 */
export type densityType = LayoutDensityType.Comfortable | LayoutDensityType.Compact | LayoutDensityType.Default;
/**
 * @type layoutDensity defines density possible types like
 * default, compact, comfortable
 */
export type layoutDensity = { [key in densityType]: number };
/**
 * @type validLayoutType defines Layout possible types like
 * row, card
 */
export type validLayoutType = LayoutType.Row | LayoutType.Card;

/**
 * @interface LayoutInputConfig defines configurations that need to be 
 * passed to instantiate layout manager
 */
export interface LayoutInputConfig {
  layoutConfig?: Layout,
  columnsConfig?: Array<DerivedColumnOptions>,
  rowOptionsConfig?: DerivedRowOptions,
  selectionConfig?: RowSelection
  domContainerDim: DomContainerProps,
  defaultColumnOptions: any,
  stores: any,
  groupLevel: Number
}
export interface StoreUnsubscribeFn {
  vizRecDomainUnsub: Function
}
/**
 * @interface RowConfig defines configurations each row
 */
export interface RowConfig {
  defaultRowHeight: number,
  headerRowHeight: number,
  rowHeight: number,
  densedRowHeight: number,
  densedHeaderRowHeight: number
}
export interface CardConfig {
  cardWidth: number,
  cardTempPlateConfig: CardTemplatePos,
  numCards: number,
  rowLeftMargin: number,
  rowRightMargin: number,
  cardPadding: number,
  defaultNumCards: number,
  defaultRowLeftMargin: number,
  defaultRowRightMargin: number,
  defaultCardPadding: number,
  defaultCardWidth: number,
  cardtemplate ?: templateFn

}

/**
 * @interface CellDimState defines final dimentionl calculation for each
 *  start cell of a column
 */
export interface CellDimState {
  left: number,
  width: number,
  inlinechartDim?: InlinechartDimState
}
/**
 * @interface RowDimState defines final dimentionl calculation for each
 * row
 */
export interface RowDimState {
  top: number,
  height: number
}
/**
 * @interface RowLayout defines structure of final dimentionl calculation for each
 * row
 */
export interface RowLayout {
  headerDimState: {
    height: number,
    cell: Array<CellDimState>
  },
  totalWidth: number,
  totalBodyHeight: number,
  rowDimState: Array<RowDimState>
}
/**
 * @interface CardLayout defines structure of final dimentionl calculation for each
 * card
 */
export interface CardLayout {
  width: number,
  height: number,
  numCards: number,
  paddingBetweenCards: number,
  startPadding: number,
  cardtemplate?: templateFn,
  cellState: Array<CardCellState>
}
export interface CardCellState {
  width: number,
  height: number,
  inlinechartDim: InlinechartDimState
}
/**
 * @interface LayoutState defines final calculated dimentions that layout manager's
 * calculatelayout to generate
 */
export interface LayoutState {
  rowLayout?: RowLayout,
  cardLayout?: CardLayout
}

export interface StoreUnsubscribeFn {
  vizRecDomainUnsub: Function
}

export interface CardTemplatePos {
  cardBorderTop: number,
  cardBorderBottom: number,
  cardBorderLeft: number,
  cardBorderRight: number,
  cardTopPadding: number,
  cardBottomPadding: number,
  cardLeftPadding: number,
  cardRightPadding: number,
  cardInfoRowTopPadding: number,
  cardInfoRowBottomPadding: number,
  cardInfoRowLeftPadding: number,
  cardInfoRowRightPadding: number,
  cardInfoRowHeight: number
}
export interface VizRecordDomainConfig {
  start: number,
  end: number,
  gridData?: GridData,
  hiddenDivHeight?: number,
  bodyTransLateY?: number
}
export interface LayoutObject {
  layout: Layout,
  layoutState: LayoutState
}
export interface Utils{
  gridData?: GridData;
  dispatchEvent?: Function;
}
export interface PaginationState{
  enable: boolean;
  showPages: {
    enable: boolean;
    showTotal: boolean;
    userInput: boolean;
  };
  showRecordCount: boolean;
  pageSize: {
    options: number[];
    applied: number;
  };
  showJumptoFirstPage: boolean;
  showJumpToLastPage: boolean;
  currentPage: number;
  totalPages: number;
  paginationHeight: number;
  numRows: number;
  totalRecords: number;
}
export interface GridDimensions{
  top: number,
  left: number,
  width: number,
  height: number
}
export interface GridColumnExtents {
  min: string | number;
  max: string | number;
}
export interface columnIndexWithMinMaxContent {
  columnIndex : number,
  content: GridColumnExtents
}
export interface ObjectTraverser {
  [prop: string]: any;
}
// const values declarations
export const DENSITY_TO_PX_MAP: layoutDensity = {
  default: 10,
  compact: 8,
  comfortable: 12
},
  DEFAULT_CHECKBOX_LEFT_PADDING: number = 16,
  DEFAULT_CHECKBOX_RIGHT_PADDING: number = 16,
  DEFAULT_CHECKBOX_WIDTH: number = 16,
  DEFAULT_CHECKBOX_COLUMN_WIDTH: number = DEFAULT_CHECKBOX_LEFT_PADDING + DEFAULT_CHECKBOX_WIDTH + DEFAULT_CHECKBOX_RIGHT_PADDING,
  DEFAULT_ROW_HEIGHT: number = 12,
  DEFAULT_INLINE_CHART_FONT_SIZE: number = 12,
  DEFAULT_COLUMN_WIDTH: number = 200,
  DEFAULT_ROW_LEFT_MARGIN: number = 30,
  DEFAULT_ROW_RIGHT_MARGIN: number = 30,
  DEFAULT_DENSED_ROW_HEIGHT = DEFAULT_ROW_HEIGHT + 2 * DENSITY_TO_PX_MAP[LayoutDensityType.Default],
  DEFAULT_VALUE_TEXT_POSITION = ValueTextPositionType.right,
  DEFAULT_VALUE_TEXT_ALIGNMENT = ValueTextAlignmentType.end,
  DEFAULT_CARD_PADDING: number = 15,
  DEFAULT_CARD_WIDTH: number = 300,
  DEFAULT_CARD_CONTAINER_TOP_BORDER: number = 1,
  DEFAULT_CARD_CONTAINER_BOTTOM_BORDER: number = 1,
  DEFAULT_CARD_CONTAINER_LEFT_BORDER: number = 1,
  DEFAULT_CARD_CONTAINER_RIGHT_BORDER: number = 1,
  DEFAULT_CARD_INFO_ROW_HEIGHT_CARD: number = 20,
  DEFAULT_CARD_CONTAINER_TOP_PADDING: number = 16.5,
  DEFAULT_CARD_CONTAINER_BOTTOM_PADDING: number = 16.5,
  DEFAULT_CARD_CONTAINER_LEFT_PADDING: number = 16.5,
  DEFAULT_CARD_CONTAINER_RIGHT_PADDING: number = 16.5,
  DEFAULT_CARD_INFO_ROW_TOP_PADDING: number = 0,
  DEFAULT_CARD_INFO_ROW_BOTTOM_PADDING: number = 0,
  DEFAULT_CARD_INFO_ROW_LEFT_PADDING: number = 0,
  DEFAULT_CARD_INFO_ROW_RIGHT_PADDING: number = 0,
  DEFAULT_CREDIT_LABEL_HEIGHT: number = 25,
  DEFAULT_PAGINATION_ROW_HEIGHT: number = 35,
  CARD_TEMPLATE_ONE_CONFIG: CardTemplatePos = {
    cardBorderTop: DEFAULT_CARD_CONTAINER_TOP_BORDER,
    cardBorderBottom: DEFAULT_CARD_CONTAINER_BOTTOM_BORDER,
    cardBorderLeft: DEFAULT_CARD_CONTAINER_LEFT_BORDER,
    cardBorderRight: DEFAULT_CARD_CONTAINER_RIGHT_BORDER,
    cardTopPadding: DEFAULT_CARD_CONTAINER_TOP_PADDING,
    cardBottomPadding: DEFAULT_CARD_CONTAINER_BOTTOM_PADDING,
    cardLeftPadding: DEFAULT_CARD_CONTAINER_LEFT_PADDING,
    cardRightPadding: DEFAULT_CARD_CONTAINER_RIGHT_PADDING,
    cardInfoRowTopPadding: DEFAULT_CARD_INFO_ROW_TOP_PADDING,
    cardInfoRowBottomPadding: DEFAULT_CARD_INFO_ROW_BOTTOM_PADDING,
    cardInfoRowLeftPadding: DEFAULT_CARD_INFO_ROW_LEFT_PADDING,
    cardInfoRowRightPadding: DEFAULT_CARD_INFO_ROW_RIGHT_PADDING,
    cardInfoRowHeight: DEFAULT_CARD_INFO_ROW_HEIGHT_CARD
  },
  setMinColumnWidth: Function = (container: HTMLElement): void => {
    let fontSize: string = '' + window.getComputedStyle(container).fontSize,
      styleObject: styleObjectType = {
        'font-size': fontSize
      };
    MIN_COLUMN_WIDTH = 32 + getSpanDimension(document, container, styleObject, 'W...').width;
  },
  getMinColumnWidth: Function = (): number=> MIN_COLUMN_WIDTH,
  dummyFunc: Function =  function (){return;},
  parseBoolean: Function = function (): boolean { // return the first valid boolean value
    for (let i = 0; i < arguments.length; i++){
      if (typeof arguments[i] === 'boolean'){
        return arguments[i];
      }
    }
    return false;
  },
  parseNumber: Function = function (): number | undefined{ // returns the first valid number 
    for (let i = 0; i < arguments.length; i++){
      if (typeof arguments[i] === 'number' && !isNaN(arguments[i])){
        return arguments[i];
      }
    }
    return;
  };