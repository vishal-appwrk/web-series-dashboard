import {
  DerivedColumnOptions,
  DerivedInlineChartConfig,
  ValueTextPositionType
} from '../../public-api/interfaces';
import {
  DEFAULT_VALUE_TEXT_POSITION,
  DEFAULT_INLINE_CHART_FONT_SIZE
} from '../../globals/helpers/helpers';

export interface InlinechartDimState {
  chartDimention: {
    leftPadding: number,
    rightPadding: number,
    topPadding: number,
    width: number,
    height: number,
    labelDataSetHGap: number
  },
  labelDimention: {
    top: number,
    width: number,
    fontSize: number
  },
  dataSetDimention: {
    top: number,
    height: number,
    width: number
  }
}
import { ScaleLinear } from '../scales/src';
export function getInlineChartDimension (columnConfig: DerivedColumnOptions, currColWidth: number, rowHeight: number): InlinechartDimState {
  let scale: ScaleLinear = columnConfig.scale,
    inlinechartDim: InlinechartDimState = <InlinechartDimState> {},
    chartConf: DerivedInlineChartConfig = columnConfig.derivedChartConfig || <DerivedInlineChartConfig>{},
    barHeight = chartConf.pxBarHeight,
    fontSize = DEFAULT_INLINE_CHART_FONT_SIZE,
    valueTextPos = chartConf.valuetextposition || DEFAULT_VALUE_TEXT_POSITION,
    chartLeftPadding: number = currColWidth * 0.05,
    chartRightPadding: number = currColWidth * 0.05,
    chartTopPadding: number = rowHeight * 0.15,
    showValue = chartConf && chartConf.showvalue,
    chartWidth: number = currColWidth * 0.9,
    chartHeight: number = rowHeight * 0.7,
    labelWidth: number = chartWidth * 0.2,
    datasetWidth: number = chartWidth * 0.75,
    labelDataSetHGap: number  = chartWidth * 0.05,
    labelDataSetVGap: number  = chartHeight * 0.10,
    dataSetHeight: number =  barHeight || chartHeight,
    labelLeft: number = chartLeftPadding,
    datasetLeft: number = chartLeftPadding,
    labelTop:number = chartTopPadding,
    datasetTop: number = chartTopPadding;

  if (showValue) {
    if (valueTextPos === ValueTextPositionType.left) {
      // when positon left, getting center position of the bar then adding 30% of font size (best visual by trial and error)
      labelTop += chartHeight * 0.5 + fontSize * 0.3;
      datasetLeft = labelLeft + labelWidth + labelDataSetHGap;
    } else if (valueTextPos === ValueTextPositionType.right) {
      // when positon right, getting center position of the bar then adding 30% of font size (best visual by trial and error)
      labelTop += chartHeight * 0.5 + fontSize * 0.3;
    } else if (valueTextPos === ValueTextPositionType.bottom || valueTextPos === ValueTextPositionType.top || valueTextPos === ValueTextPositionType.inside){
      dataSetHeight = barHeight || chartHeight * 0.3;
      fontSize = Math.min(chartHeight * 0.6, 12);
      datasetWidth = chartWidth;
      if (valueTextPos === ValueTextPositionType.top ) {
        labelTop += fontSize;
        datasetTop = labelTop + labelDataSetVGap;
      } else if (valueTextPos === ValueTextPositionType.bottom){
        labelTop = datasetTop + dataSetHeight + fontSize;
      } else {
        dataSetHeight = barHeight || chartHeight;
        fontSize = DEFAULT_INLINE_CHART_FONT_SIZE;
        // when positon inside, getting center position of the bar then adding 30% of font size (best visual by trial and error)
        labelTop = datasetTop + dataSetHeight * 0.5 + fontSize * 0.3;
      }
    }
  } else {
    datasetWidth = chartWidth;
  }
  scale.setRange([datasetLeft, datasetLeft + datasetWidth]);
  scale.setDomain([Math.min( Number(columnConfig.minContent) || 0, 0), Number(columnConfig.maxContent) || 0]);
  // TO-DO, to be replaced by space management calculation
  inlinechartDim.dataSetDimention = {
    top: datasetTop,
    height: dataSetHeight,
    width: datasetWidth
  };
  inlinechartDim.labelDimention = {
    top: labelTop,
    width: labelWidth,
    fontSize
  };
  inlinechartDim.chartDimention = {
    leftPadding: chartLeftPadding,
    rightPadding: chartRightPadding,
    topPadding: chartTopPadding,
    width: chartWidth,
    height: chartHeight,
    labelDataSetHGap
  };
  return inlinechartDim;
}