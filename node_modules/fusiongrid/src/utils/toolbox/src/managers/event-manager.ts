interface HandlerObject{
    handlerFn: Function,
    context: object
}
interface HandlerWrapper {
    [propName: string]: Array<HandlerObject>
}
interface EventsConfig{
    [propName: string]: Function
}
interface ConfigObject{
    events?: EventsConfig
    context: object
}
interface EventDataObject{
    originalEvent: Event,
    type: string,
    data: object,
    sender: object,
    preventDefault: Function
}

const preventDefaultHandler = function(this: EventDataObject):void {
    this.originalEvent && this.originalEvent.preventDefault();
  },
  stopPropagationHandler = function(this: EventDataObject):void {
    this.originalEvent && this.originalEvent.stopPropagation();
  };


class EventManager{
    private _evtListeners: HandlerWrapper = {};
    private _context: object; 
    dispatchEvent: Function;
    constructor(config: ConfigObject){
      let evtManager = this,
        events:EventsConfig | undefined = config.events,
        evtListener: Array<HandlerObject>,
        lowerCaseEvtName;
      this._context = config.context;
      // if events are provided during initialization
      if (events){
        for (let key in events){
          lowerCaseEvtName  = key.toLocaleLowerCase();
          if (!(evtListener = evtManager._evtListeners[lowerCaseEvtName])) {
            evtListener = evtManager._evtListeners[lowerCaseEvtName] = [];
          }
          if (typeof events[key] === 'function') {
            evtListener.push({
              handlerFn: events[key],
              context: this._context
            });
          }
        }
      }
      /**
       * Event dispatcher
       * @param {string} eventName the event name to be dsipatched
       * @param {object} eventObj the event payload
       * @param {EventListenerObject} eventObj the original event object
       * @param {object} explicitContext context fo the handler
       */
      this.dispatchEvent = function(eventName: string, payload: object, eventObj?:EventListenerObject, explicitContext ?: object): void {
        let sender:object = this,
          eventListeners:Array<HandlerObject> = evtManager._evtListeners[eventName], // get all of that event
          eventData: object;
        if (eventListeners && eventListeners.length){
          // create event data
          eventData = {
            type: eventName, // name of the event
            originalEvent: eventObj, // original DOM event
            data: payload, // event payload
            sender, // sender component,
            preventDefault: preventDefaultHandler, // prevent default operation,
            stopPropagation: stopPropagationHandler // stop propagation operation
          };
          eventListeners.forEach((eventListener: HandlerObject)=>{
            // call all the handlers of that event with proper data
            eventListener.handlerFn && eventListener.handlerFn.call(explicitContext || eventListener.context, eventData, payload);
          });
        }
      };
    }
    /**
     * Method to add a handler for a particular event
     * @param eventName string The name of the event 
     * @param handler function The handler function
     */
    addEventListener(eventName: string, handler: Function): void{
      let _evtListeners: HandlerWrapper = this._evtListeners,
        evtListener: Array<HandlerObject>,
        evtName: string = eventName.toLowerCase();
      if (!(evtListener = _evtListeners[evtName])){
        evtListener = _evtListeners[evtName] = [];
      }
      if (typeof handler === 'function'){
        evtListener.push({
          handlerFn: handler,
          context: this._context
        });
      }
    }
    /**
     * Method to remove a particular handler for an event
     * @param eventName string The name of the event
     * @param handler function The handler function
     */
    removeEventListener(eventName: string, handler: Function):void{
      let _evtListeners:HandlerWrapper = this._evtListeners,
        evtListener: Array<HandlerObject> = _evtListeners[eventName] || [],
        evtName: string = eventName.toLowerCase();
      // create a new listener array after excluding the concerned handler
      _evtListeners[evtName] = evtListener.filter(evtObj=>evtObj.handlerFn !== handler);
    }
    /**
     * Method to get all listeners currently stored by Event Manager 
     */
    getAllListeners():HandlerWrapper{
      return this._evtListeners;
    }
}
export default EventManager;