function isMergeableObject(obj: any): boolean {
  const isObject = obj && typeof obj === 'object';

  return isObject && Object.prototype.toString.call(obj) !== '[object RegExp]' && Object.prototype.toString.call(obj) !== '[object Date]';
}

/**
 * Clone an object or an array
 * @param obj Object to clone
 */
function clone(obj: any) {
  const blankValue = Array.isArray(obj) ? [] : {};
  return isMergeableObject(obj) ? mergeDeep(blankValue, obj) : obj;
}

function mergeArray(target: Array<any>, source: Array<any>) {
  const output = target.slice();
  source.forEach((value, index) => {
    if (typeof output[index] === 'undefined') {
      output[index] = clone(value);
    } else if (isMergeableObject(value)) {
      output[index] = mergeDeep(target[index], value);
    } else if (target.indexOf(value) === -1) {
      output.push(clone(value));
    }
  });
  return output;
}

function mergeObject(target: any, source: any) {
  const output: any = {};

  if (isMergeableObject(target)) {
    Object.keys(target).forEach(attr => {
      output[attr] = clone(target[attr]);
    });
  }

  Object.keys(source).forEach(attr => {
    if (!isMergeableObject(source[attr]) || !target[attr]) {
      output[attr] = clone(source[attr]);
    } else {
      output[attr] = mergeDeep(target[attr], source[attr]);
    }
  });

  return output;
}

/**
 * Deep merge objects to create a merged output
 * @param objects objects to merge
 */
function mergeDeep(...objects: Array<any>): any {
  return objects.reduce((prev, obj) => {
    if (Array.isArray(obj)) {
      return Array.isArray(prev) ? mergeArray(prev, obj) : clone(obj);
    } 
    return mergeObject(prev, obj);
        
  });
}

export { mergeDeep, mergeArray, clone };