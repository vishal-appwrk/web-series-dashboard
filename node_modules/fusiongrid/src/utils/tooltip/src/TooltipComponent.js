
import { isDefined, isTruthy } from './utils';
import Beak from './Beak';

const OBJECT_STR = 'object',
    BOTTOM_STR = 'bottom',
    ABOSULTE_STR = 'absolute',
    VISIBLE_STR = 'visible',
    HIDDEN_STR = 'hidden',
    DEFAULT_HORIZONTAL_PADDING = 11,
    DEFAULT_VERTICAL_PADDING = 11;

class TooltipComponent{

    constructor(obj){
        this.config = {};
        this._parent = obj.container;
        this._childrens = {};
        this._element = document.createElement('div');
        this._parent.appendChild(this._element);
        this._tooltipDim = {};
        this._prevContent = '';
        this.setDefaultConfig();
        this.configure(obj);
    }

    attachChild(childName, childClass, config){
        this._childrens[childName] = new childClass(config);
        return  this._childrens[childName];
    }

    removeChild(childName){
        let child = this._childrens[childName];
        child.dispose();
        delete this._childrens[childName];
    }
    setBounds(bounds){
        this.config.bounds = bounds;
    }
    getBounds(){
        return this.config.bounds;
    }
    setDefaultConfig(){
        let config = this.config;
        config.hasBeak = false;
        config.isSticky = false;
        config.defaultDirection = BOTTOM_STR;
        config.stickProps = {};
        config.beakProps = {};
        config.bounds = {};
        config.styles = {
            position: ABOSULTE_STR,
            visibility: HIDDEN_STR
        };
    }

    configure(config){
        let tooltip = this,
            tooltipConfig = tooltip.config,
            extStyles = config.styles || {},
            containerClasses = config.containerClasses,
            closeButtonClasses = config.closeButtonClasses,
            hasBeak = config.beak,
            isSticky = config.sticky,
            defaultDirection = config.defaultDirection;
        
        for (let key in extStyles){
            tooltipConfig.styles[key] = extStyles[key]
        }

        isDefined(containerClasses) && (tooltipConfig.containerClassName = containerClasses.join(' '));
        isDefined(closeButtonClasses) && (tooltipConfig.closeButtonClassName = closeButtonClasses.join(' '));
        isDefined(hasBeak) && (tooltipConfig.hasBeak = isTruthy(hasBeak));
        if (typeof hasBeak === OBJECT_STR){
            for (let key in hasBeak){
                isDefined(hasBeak[key]) && (tooltipConfig.beakProps[key] = hasBeak[key]);
            }
        }
        isDefined(isSticky) && (tooltipConfig.isSticky = isTruthy(isSticky));
        if (typeof isSticky === OBJECT_STR){
            for (let key in isSticky){
                isDefined(isSticky[key]) && (tooltipConfig.stickyProps[key] = isSticky[key]);
            }
        }
        isDefined(defaultDirection) && (tooltipConfig.defaultDirection = defaultDirection);

        tooltip.createChildComponents();
        tooltip.applyInlineStyles();
    }

    applyInlineStyles(){
        let tooltip = this,
            tooltipElem = tooltip._element,
            config = tooltip.config,
            styles = config.styles,
            className = config.containerClassName;
        for (let style in styles){
            tooltipElem.style[style] = styles[style];
        }
        tooltipElem.setAttribute('class', className);
    }
    
    createChildComponents(){
        let tooltip = this,
            tooltipConfig = tooltip.config,
            beak,
            closeAction;
        if (tooltipConfig.hasBeak){
            beak = tooltip.attachChild('beak', Beak, {
                container: tooltip._parent,
                parent: tooltip._element,
                direction: tooltipConfig.defaultDirection,
                className: tooltipConfig.containerClassName,
                beakProps: tooltipConfig.beakProps
            });
        }
    }
    show(content, x, y){
        let tooltip = this,
            tooltipElem = tooltip._element,
            tooltipDim = tooltip._tooltipDim;
        if (tooltip._prevContent !== content){
            tooltip._prevContent = content
            tooltipElem.style.whiteSpace = 'nowrap';
            tooltipElem.style.width = '';
            tooltipElem.style.height = '';
            tooltipElem.innerHTML = content;
            tooltipDim.width = tooltipElem.offsetWidth;
            tooltipDim.height = tooltipElem.offsetHeight;
        }   
        if (tooltipElem.style.visibility === HIDDEN_STR){
            tooltipElem.style.visibility  = VISIBLE_STR;
        } 
        tooltip.update(x, y);
    }
    update(x, y){
        let tooltip = this,
          parent = tooltip._parent,
          bounds = tooltip.config.bounds,
          tooltipElem = tooltip._element,
          {width: containerWidth, height: containerHeight, left: containerLeft, top: containerTop} = bounds,
          {width: tooltipWidth, height: tooltipHeight} = tooltip._tooltipDim,
          xPos = (x - containerLeft + DEFAULT_HORIZONTAL_PADDING),
          yPos = (y - containerTop + DEFAULT_VERTICAL_PADDING);
          // horizontal domain validation
          // if tooltip overflows the right side of the container push it to left
          if ((xPos + tooltipWidth) > containerWidth){
            // if tooltip still overflows the left side of the container then provide it a width
            // which is equal to the container and break texts into multiple lines
            if ((xPos - tooltipWidth) < containerLeft){
                xPos = 0;
                if (tooltipElem.style.width !== containerWidth + 'px'){
                    tooltipElem.style.width = containerWidth + 'px';
                }
                if (tooltipElem.style.whiteSpace !== 'normal'){
                    tooltipElem.style.whiteSpace = 'normal';
                };
                tooltipHeight = tooltipElem.offsetHeight;
            } else {
                xPos = xPos - tooltipWidth - DEFAULT_HORIZONTAL_PADDING;
                if (tooltipElem.style.width !== tooltipWidth + 'px'){
                    tooltipElem.style.width =  tooltipWidth + 'px';
                }
                if (tooltipElem.style.whiteSpace !== 'nowrap'){
                    tooltipElem.style.whiteSpace = 'nowrap';
                }
            }
          }
          // vertical domain validation
          // if tooltip overflows the bottom of the container then push the tooltip to top.
          // No validation will be done if the tooltip still overflows the top of the container
          if ((yPos + tooltipHeight) > containerHeight){
            yPos = yPos - tooltipHeight - DEFAULT_VERTICAL_PADDING;
          }
        xPos += 'px'; 
        yPos += 'px';  
        parent.style.left = xPos;
        parent.style.top = yPos;
        tooltip.showChildrens(xPos, yPos);
    }
    hide(){
        let tooltip = this,
            tooltipElem = tooltip._element;
        tooltipElem.style.visibility  = HIDDEN_STR;
        tooltip.hideChildrens();
    }
    showChildrens(xPos, yPos){
        let tooltip = this,
        childrens = tooltip._childrens;
        for (let child in childrens){
            childrens[child].show(xPos, yPos);
        }
    }
    hideChildrens(){
        let tooltip = this,
        childrens = tooltip._childrens;
        for (let child in childrens){
            childrens[child].hide();
        }
    }
}
export default TooltipComponent;