type interpolateNumberFn = (param: number) => number;
type interpolateConstructFn = (param1: number, param2: number) => interpolateNumberFn;

function interpolateNumber (_min: number, _max: number) {
  let min = Number(_min),
    max = Number(_max),
    diff = max - min;

  return (ratio: number) => (diff * ratio) + min;
}
const constant = (x: any) => () => x;
function isValid (num: any) {
  if (num === null || typeof num === 'undefined') {
    return false;
  }
  return true;
}
function interpolateRound (_min: number, _max: number) {
  let min = Number(_min),
    max = Number(_max),
    diff = max - min;

  return (ratio: number) => Math.round((diff * ratio) + min);
}

function interpolateValue (from: number, to: number) {
  const interpolator: interpolateConstructFn = interpolateNumber;

  if (!isValid(to) || !isValid(from) || typeof to === 'boolean') {
    return constant(to);
  }

  return interpolator(from, to);
}

/**
 * function to return a ratio with respect to the liinterpolatemit
 * @param {number} _min of domain
 * @param {number} _max of domain
 * @return {Function} that takes in value and return the ratio
 */
function deInterpolateLinear (_min: number, _max: number) {
  let min = Number(_min),
    max = Number(_max),
    diff = max - min;
  if (!diff) {
    return constant(diff);
  }

  return (value: number) => ((value - min) / diff);
}

export {
  constant,
  deInterpolateLinear,
  interpolateNumber,
  interpolateNumberFn,
  interpolateConstructFn,
  interpolateRound,
  interpolateValue
};