/* eslint require-jsdoc: 'error', valid-jsdoc: ["error", { "requireReturn": false }] */
import {
  constant, interpolateValue, interpolateRound, interpolateNumberFn, interpolateConstructFn
} from './scale-utils';

let UNDEF: undefined;
const UNIT: Array<number> = [0, 1];
/**
 *returns a function which when given a value in domain returns the corresponding range
 * @param {Array} domain array containing the start and end value
 * @param {Array} range array containing the start and end value
 * @param {Function} deInterpolate function
 * @param {Function} reInterpolate function
 * @return {Function} takes in value and returns the mapped value
 */
function bimap(domain: Array<number>, range: Array<number>, deInterpolate: interpolateConstructFn, reInterpolate: interpolateConstructFn) {
  var deInterpolator: interpolateNumberFn,
    reInterpolator: interpolateNumberFn;
  if (domain[0] > domain[1]) {
    deInterpolator = deInterpolate(domain[1], domain[0]);
    reInterpolator = reInterpolate(range[1], range[0]);
  } else {
    deInterpolator = deInterpolate(domain[0], domain[1]);
    reInterpolator = reInterpolate(range[0], range[1]);
  }
  return (value: number) => reInterpolator(deInterpolator(value));
}
/**
 * function to return a ratio with respect to the liinterpolatemit
 * @param {number} _min of domain
 * @param {number} _max of domain
 * @return {Function} that takes in value and return the ratio
 */
function deInterpolateLinear(_min: number, _max: number) {
  let min = Number(_min),
    max = Number(_max),
    diff = max - min;
  if (!diff) {
    return constant(diff);
  }

  return (value: number) => ((value - min) / diff);
}
/**
 * function to return a ratio with respect to the limit and will clamp it to 0 and 1
 * if it goes out of range
 * @param {Function} deInterpolate function
 * @return {Function} takes a value and return clamped value
 */
function deInterpolateClamp(deInterpolate: Function) {
  return (_min: number, _max: number) => {
    var min = Number(_min),
      max = Number(_max),
      interpolator = deInterpolate(min, max);
    return (value: number) => {
      if (value <= min) {
        return 0;
      } else if (value >= max) {
        return 1;
      }
      return interpolator(value);
    };
  };
}
/**
 * function to return a value with respect to the limit and will clamp it to max and min
 * if it goes out of range
 * @param {Function} reInterpolate function
 * @return {Function} takes in ratio and returns clamped value
 */
function reInterpolateClamp(reInterpolate: Function) {
  return (_min: number, _max: number) => {
    var min = Number(_min),
      max = Number(_max),
      interpolator = reInterpolate(min, max);
    return (ratio: number) => {
      if (ratio <= 0) {
        return min;
      } else if (ratio >= 1) {
        return max;
      }
      return interpolator(ratio);
    };
  };
}
/**
 * continous scale class
 */
class ScaleContinuous {
  private domain: Array<number>;
  private range: Array<number>;
  private deInterpolate: interpolateConstructFn;
  private reInterpolate: interpolateConstructFn;
  private interpolate: interpolateConstructFn;
  private clamp: boolean;
  private input: interpolateNumberFn | null;
  private output: interpolateNumberFn | null;
  /**
   * constructs the class with
   * @param {Function} deInterpolate deinterpolate(a,b)(x) takes a domain value x in [a,b] and returns
   * corresponding value t in [0,1]
   * @param {Function} reInterpolate reinterpolate(a,b)(t) takes a value t in [0,1] and returns
   * corresponding domain value x in [a,b]
   */
  constructor(deInterpolate: interpolateConstructFn, reInterpolate: interpolateConstructFn) {
    this.domain = UNIT;
    this.range = UNIT;
    this.deInterpolate = deInterpolate;
    this.reInterpolate = reInterpolate;
    this.interpolate = interpolateValue;
    this.clamp = false;
    this.input = null;
    this.output = null;

    this._rescale();
  }
  /**
   * when called it informs the scale that it needs to update its mappiing function
   * @return {Object} instnace of
   */
  _rescale() {
    this.input = null;
    this.output = null;
    return this;
  }
  /**
   * sets the domain
   * @param {Array} inputArr is the input array contianig the domian
   * @return {Object} instance of scale
   */
  setDomain(inputArr: Array<number> = UNIT) {
    this.domain = inputArr.map(Number);
    return this._rescale();
  }
  /**
   * returns the currnet domain
   * @return {Array} domain array
   */
  getDomain() {
    return this.domain.slice();
  }
  /**
   * sets the range
   * @param {Array} inputArr is the input array contianig the range
   * @return {Object} instance of scale
   */
  setRange(inputArr: Array<number> = UNIT) {
    this.range = inputArr.slice();
    return this._rescale();
  }
  /**
   * returns the currnet range
   * @return {Array} range array
   */
  getRange() {
    return this.range.slice();
  }
  /**
   * sets the inpterpolate function
   * @param {Function} interpolate function
   * @return {Object} instance of scale
   */
  setInterpolate(interpolate: interpolateConstructFn = interpolateValue) {
    this.interpolate = interpolate;
    return this._rescale();
  }
  /**
   * get the interpolate function
   * @return {Function} interpolate function
   */
  getInterpolate() {
    return this.interpolate;
  }
  /**
   * Function to set if the value returned will be clamped to the domain or range
   * @param {boolean} clamp is the flag to check wether to clamp the value to the given range
   * @return {Object} instance of scale
   */
  setClamp(clamp: boolean = false) {
    this.clamp = !!clamp;
    return this._rescale();
  }
  /**
   * returns the clamping value
   * @return {boolean} clamp flag value
   */
  getClamp() {
    return this.clamp;
  }
  /**
   * sets the new range and sets the interpolate function as round interpolate
   * @param {Array} inputArr of range
   * @return {Object} instance of scale
   */
  rangeRound(inputArr: Array<number> = UNIT) {
    this.range = inputArr.slice();
    this.interpolate = interpolateRound;
    return this._rescale();
  }
  /**
   * Function to return the range value with respect to domain value
   * @param {number} _domainValue is a domain value
   * @return {number} range value
   */
  getRangeValue(_domainValue: Array<number>) {
    let domainValue = _domainValue !== null ? _domainValue : UNDEF,
      clamp = this.getClamp(),
      deInterpolate = clamp ? deInterpolateClamp(this.deInterpolate) : this.deInterpolate;
    if (!this.output) {
      this.output = bimap(this.getDomain(), this.getRange(), deInterpolate, this.interpolate);
    }
    return this.output(Number(domainValue));
  }
  /**
   * Function to return the domain value with respect to range value
   * @param {number} rangeValue is the pixel value
   * @return {number} domain value
   */
  getDomainValue(rangeValue: Array<number>) {
    let clamp: boolean = this.getClamp(),
      reInterpolate = clamp ? reInterpolateClamp(this.reInterpolate) : this.reInterpolate;
    if (!this.input) {
      this.input = bimap(this.getRange(), this.getDomain(), deInterpolateLinear, reInterpolate);
    }
    return this.input(Number(rangeValue));
  }
}
export default ScaleContinuous;
