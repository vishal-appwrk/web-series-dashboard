<script>
  import { createEventDispatcher } from "svelte";

  import CheckBox from "../checkbox/header/checkbox.svelte";
  import ValueFilter from '../filters/valueFilter.svelte';
  import ConditionalFilter from '../filters/conditionalFilter.svelte';
  import HelperIcon from "../helperIcon.svelte";
  import { getContext } from "svelte";
  import FilterIcon from '../icons/filter.svelte';
  import FilterIconActive from '../icons/filterActive.svelte';
  import SortAscIcon from "../icons/sortasc.svelte";
  import SortDescIcon from "../icons/sortdesc.svelte";
  import {getConfigScope, getSubPropertyValue} from '../../utils/index';
  import CancelSearch from "../icons/cancelSearch.svelte";

  export let cellIndex;
  export let style;
  export let hovered;
  export let onGlobalSelect;
  export let onColumnSort;
  export let headerRowSelected;
  export let gridData;
  export let checkBoxEnabled;
  export let parsedGridConfig;
  export let handleFilter;
  export let filterData;
  export let isSearchEnabled;
  export let parent;
  export let stores;
  export let groupedHeader;
  export let groupCell;
  export let sortIconOnHover;
  export let filterMenuStyle;
  export let  quickSearchEnabled;
  export let hoveredGroupDetails;
  export let applyConditionalFilter;
  const BLANKSTRING = "";
  let selectionFeature,
    dispatch = createEventDispatcher(),
    showHelperIcon,
    tooltipRef = getContext("tooltipRef"),
    dispatchEvent = getContext("dispatchEvent");
  let cellInfo,
    extClassNames,
    extInlineStyle,
    cellContent,
    tooltipContent = "",
    hoverClass,
    extInlineStyleStr = "",
    extHoverClasses,
    extHoverStyle,
    cellElem,
    colindex,
    rowindex,
    showTooltip,
    sortEnabled,
    showSortIcon,
    showAscIcon,
    showDescIcon,
    columnType,
    reduceColumnIndexBy,
    isSelectionCell,
    mergedExtStyle,
    menuStyle = {},
    searchable,
    searchFlag,
    globalSearchFlag,
    searchTimeout,
    searchText,
    searchDisabledFromFilter,
    allSelected =false,
    selectedValues=[],
    multiColSearch,
    headerClass,
    headerStyle,
    localSortState,
    globalSortState,
    filterType,
    filterIndex,
    mappedCellIndex,
    valueFilterData,
    uniqueViewData,
    showFilterIconOnHover = false,
    globalFilterState,
    localFilterState,
    filterEnabled,
    filterStyleWithSearch = 'margin: 8px 6px 0px 0px; cursor: pointer',
    inputStyleWithFilter = 'width: 160px',
    crossContainerStyle = 'right: 32px',
    isCellHovered,
    conditionalFilterValues,
    isCellFilterApplied;
  $: {
    reduceColumnIndexBy = 0;
    if (checkBoxEnabled && cellIndex) {
      reduceColumnIndexBy = 1;
    }
    isCellHovered =  hovered || (!groupedHeader && hoveredGroupDetails && cellIndex >= hoveredGroupDetails.start && cellIndex < hoveredGroupDetails.end);
    mappedCellIndex = gridData._columnIndexMap[cellIndex - reduceColumnIndexBy];
    isSelectionCell = (checkBoxEnabled && cellIndex == 0 && !groupCell);
    cellInfo = gridData.getHeaderMetaInfo(cellIndex - reduceColumnIndexBy);
    extClassNames = (cellInfo.class || []).join(" ");
    extInlineStyle = cellInfo.style;
    cellContent = cellInfo.content;
    extHoverClasses = cellInfo.hoverClass;
    colindex = cellInfo.params.cellIndex >= parsedGridConfig.columns.length ? 0 : cellInfo.params.cellIndex;
    extHoverStyle = isCellHovered && cellInfo.hoverStyle;
    rowindex = cellInfo.params.rowIndex;
    showHelperIcon = cellInfo.showTooltipInHelper;
    headerClass = groupCell && groupCell.headerClass ? groupCell.headerClass : parsedGridConfig.defaultColGroupOptions &&  parsedGridConfig.defaultColGroupOptions.headerClass;
    headerStyle = groupCell && groupCell.headerStyle ? groupCell.headerStyle : parsedGridConfig.defaultColGroupOptions && parsedGridConfig.defaultColGroupOptions.headerStyle;
    columnType = parsedGridConfig.columns[colindex] ? parsedGridConfig.columns[colindex].type : '';
    localSortState = parsedGridConfig.columns[cellIndex] && ((typeof parsedGridConfig.columns[cellIndex].sortable === 'object' && parsedGridConfig.columns[cellIndex].sortable !== null ) ? parsedGridConfig.columns[cellIndex].sortable.enable : parsedGridConfig.columns[cellIndex].sortable),
    globalSortState = (typeof parsedGridConfig.defaultcolumnoptions.sortable === 'object' && parsedGridConfig.defaultcolumnoptions.sortable !== null ) ? parsedGridConfig.defaultcolumnoptions.sortable.enable : parsedGridConfig.defaultcolumnoptions.sortable,
    globalFilterState = (typeof parsedGridConfig.defaultcolumnoptions.filter === 'object' && parsedGridConfig.defaultcolumnoptions.filter !== null ) ? parsedGridConfig.defaultcolumnoptions.filter.enable : parsedGridConfig.defaultcolumnoptions.filter,
    localFilterState = parsedGridConfig.columns[cellIndex] && ((typeof parsedGridConfig.columns[cellIndex].filter === 'object' && parsedGridConfig.columns[cellIndex].filter !== null ) ? parsedGridConfig.columns[cellIndex].filter.enable : parsedGridConfig.columns[cellIndex].filter),
    filterEnabled = getConfigScope(localFilterState, globalFilterState),
    sortEnabled = getConfigScope(localSortState, globalSortState),
    showSortIcon = getSubPropertyValue(parsedGridConfig, cellIndex, 'sortable', 'showsortindicator', true),
    showAscIcon = typeof gridData._sortState === "object" && gridData._sortState.cellIndex === colindex && gridData._sortState.order === "asc",
    showDescIcon = typeof gridData._sortState === "object" && gridData._sortState.cellIndex === colindex && gridData._sortState.order === "desc",
    showAscIcon = (sortIconOnHover && sortEnabled && !showDescIcon) || showAscIcon;
    showTooltip = !showHelperIcon && cellInfo.tooltipContent.length;
    menuStyle = style + 'z-index:999';
    if (Array.isArray(cellInfo.tooltipContent)) {
      cellInfo.tooltipContent.forEach(content => (tooltipContent += content));
    } else {
      tooltipContent = cellInfo.tooltipContent;
    }
    extInlineStyleStr = "";
    mergedExtStyle = {...(!isSelectionCell ? (groupCell ? headerStyle : extInlineStyle) : {} ), ...extHoverStyle};
    for (let key in mergedExtStyle) {
      extInlineStyleStr += key + ":" + mergedExtStyle[key] + ";";
    }

    hoverClass = isCellHovered ? (extHoverClasses.join(" ") || "fg-column-header-hover ") : "";
    menuStyle = style + 'z-index:999';
    searchFlag = parsedGridConfig.columns[colindex] ? parsedGridConfig.columns[colindex].searchable : {}
    globalSearchFlag = parsedGridConfig.defaultcolumnoptions ? parsedGridConfig.defaultcolumnoptions.searchable : null;
    if(typeof searchFlag === 'boolean' || typeof searchFlag === 'object'){
      searchable = typeof searchFlag === 'boolean' ? searchFlag : searchFlag.enable;
    } else if((typeof globalSearchFlag === 'boolean' || typeof globalSearchFlag === 'object') && globalSearchFlag !== null){
      searchable = typeof globalSearchFlag === 'boolean' ? globalSearchFlag : globalSearchFlag.enable;
    }

    stores.colSearchValues.subscribe((colValues) => {
      searchText = colValues[gridData._columnIndexMap[cellIndex - reduceColumnIndexBy]] ? colValues[gridData._columnIndexMap[cellIndex - reduceColumnIndexBy]].text : "";
      searchDisabledFromFilter = colValues[gridData._columnIndexMap[cellIndex - reduceColumnIndexBy]] ? colValues[gridData._columnIndexMap[cellIndex - reduceColumnIndexBy]].searchDisabledFromFilter : false;
    })
    multiColSearch = (typeof globalSearchFlag === 'object' && globalSearchFlag && globalSearchFlag.multicolsearch !== undefined) ? globalSearchFlag.multicolsearch : true;
    stores.filterIndex.subscribe((index) => {
      filterIndex = index;
    })
    stores.valueFilterData.subscribe((value) => valueFilterData = value);
    stores.conditionalFilterValues.subscribe((value) => conditionalFilterValues = value);
    filterType = parsedGridConfig.defaultcolumnoptions.filter && parsedGridConfig.defaultcolumnoptions.filter.type;
    isCellFilterApplied = valueFilterData && valueFilterData[mappedCellIndex] && (!valueFilterData[mappedCellIndex].allSelected || valueFilterData[mappedCellIndex].searchText);
    // Conditional filter check
    isCellFilterApplied = isCellFilterApplied || (conditionalFilterValues && conditionalFilterValues[mappedCellIndex] && conditionalFilterValues[mappedCellIndex].find((cell) => (cell.condition && cell.value) || cell.condition === 'is empty' || cell.condition === 'is not empty'))
  }

  function handleMouseOver(e) {
    if(groupedHeader){
      dispatch("cellHoverIn", { groupDetails: { start: groupCell.childStartIndex, end: groupCell.childStartIndex + groupCell.childCount } })
    } else {
      !isSelectionCell && dispatch("cellHoverIn", { visualColIndex: colindex + reduceColumnIndexBy, rowindex, actualColIndex: colindex });
      showTooltip && tooltipRef.tooltip.show(tooltipContent, e.pageX, e.pageY);
      showFilterIconOnHover = true;
    }
  }
  function handleMouseMove(e) {
    showTooltip && tooltipRef.tooltip.update(e.pageX, e.pageY);
  }
  function handleMouseOut() {
    !isSelectionCell && dispatch("cellHoverOut", { visualColIndex: colindex + reduceColumnIndexBy, rowindex, actualColIndex: colindex });
    showTooltip && tooltipRef.tooltip.hide();
    // setTimeout(() => {
    //   showFilterIconOnHover = false;
    // }, 5000);
  }
  function handleClick(e){
    let parentDataIndex = gridData._columnIndexMap[cellIndex - reduceColumnIndexBy];
    const data = {
      columnType,
      cellIndex: cellIndex - reduceColumnIndexBy,
      parentDataIndex,
      rowHeight: parsedGridConfig.rowoptions.headerrowheight,
      filterEnabled: undefined, // @todo: need to set proper value after implementing filter feature
      sortEnabled: undefined // @todo: need to set proper value after implementing column feature
    };

    isSelectionCell && !isSearchEnabled && onGlobalSelect();
    sortEnabled && !isSelectionCell && !groupCell && onColumnSort(data);
    dispatchEvent('headerclicked', data, e);
    if(sortEnabled && !isSelectionCell && !groupCell){
      dispatchEvent('sortchanged', {
        columns: {
            name: cellContent,
            index: parentDataIndex,
            sortState: gridData._sortState.order
          }
      })
    }
  }
  function handleFilterIconClick(e){
    e.stopPropagation();
    handleFilter(mappedCellIndex);
    stores.filterIndex.set(mappedCellIndex);
  }

  /**
   * Function to update filters as per checkbox selection for value filter
   * @param value
   * @param event
   */
  function updateValueFilter(value, checked){
    let selectedValues = [],
      tempFiterData,
      dataIndex,
      filteredData,
      gridDataTable = parent._gridDataTable,
      dataTable = gridDataTable.dataTable,
      customData,
      sortState = gridData._sortState;

    stores.valueFilterData.subscribe((value) => tempFiterData = value);
    selectedValues = [...tempFiterData[mappedCellIndex].selectedValues];

    // Select All case handled
    if(value === '_allSelected'){
      tempFiterData[mappedCellIndex].allSelected = checked;
      selectedValues = checked ? dataTable.getDataStore().getUniqueValues(dataTable._data, mappedCellIndex) : [];
    } else if(checked) {
      selectedValues.push(value);
      tempFiterData[mappedCellIndex].allSelected = 
        dataTable.getDataStore().getUniqueValues(dataTable._data, mappedCellIndex).length === selectedValues.length;
    } // Remove header name in case of checkbox unchecked 
    else {
      dataIndex = selectedValues.findIndex((val) => val === value);
      selectedValues.splice(dataIndex, 1);
      tempFiterData[mappedCellIndex].allSelected = false;
    }

    // If quick search is enabled, then change base to quick search's last state
    if(isSearchEnabled){
      customData = gridDataTable.quickSearchBase;
    }

    disableQuickSearch(customData, selectedValues);
    tempFiterData[mappedCellIndex].selectedValues = selectedValues;
    stores.valueFilterData.set(tempFiterData);

    // When nothing is selected then set empty data
    if(!tempFiterData[mappedCellIndex].allSelected && !tempFiterData[mappedCellIndex].selectedValues.length){
      filteredData = [];
    } else {
      filteredData = dataTable.getDataStore().applyValueFilter(customData, tempFiterData, dataTable.getID());
    }

    // If sorting is enabled and applied previously, then sort data after filter
    if(sortEnabled && sortState && sortState.parentDataIndex && filteredData.length){
      sortDataAfterFilter(filteredData);
    } // Else update view 
    else {
      parent.updateViewData(filteredData);
    }

    updatePaginationConfig(filteredData);
  }

  function resetSearch(value, checked){
    let tempValueFilterData;
    stores.valueFilterData.subscribe((value) => tempValueFilterData = value);
    tempValueFilterData[mappedCellIndex].searchText = '';
    stores.valueFilterData.set(tempValueFilterData);
    updateValueFilter(value, checked);
  }

  function updateGridOnSearch(selectedValues, searchText ){
    let valueFilterData, 
      tempFilterData;

    stores.valueFilterData.subscribe((value) => valueFilterData = value);
    tempFilterData = [...valueFilterData];
    tempFilterData[mappedCellIndex].selectedValues = selectedValues;
    tempFilterData[mappedCellIndex].searchText = searchText;
    if(!searchText){
      tempFilterData[mappedCellIndex].allSelected = true;
    }

    applySortSearchAndFilter(selectedValues, tempFilterData);
  }

  function removeIntermediateState(){
    let tempValueFilterData;
    stores.valueFilterData.subscribe((val) => tempValueFilterData = val);
    tempValueFilterData[mappedCellIndex].selectedValues = [];
    tempValueFilterData[mappedCellIndex].allSelected = false;
    tempValueFilterData[mappedCellIndex].searchText = '';
    stores.valueFilterData.set(tempValueFilterData);
    applySortSearchAndFilter([], tempValueFilterData);
  }

  function applySortSearchAndFilter(selectedValues, tempValueFilterData){
    let filteredData = [],
      customData,
      gridDataTable = parent._gridDataTable,
      dataTable = gridDataTable.dataTable,
      sortState = gridData._sortState;

     // If quick search is enabled, then change base to quick search's last state
     if(isSearchEnabled){
      customData = gridDataTable.quickSearchBase;
    }

    disableQuickSearch(customData, selectedValues);

    // When nothing is selected then set empty data
    filteredData = dataTable.getDataStore().applyValueFilter(customData, tempValueFilterData, dataTable.getID());

    // If sorting is enabled and applied previously, then sort data after filter
    if(sortEnabled && sortState && sortState.parentDataIndex && filteredData.length){
      sortDataAfterFilter(filteredData);
    } // Else update view 
    else {
      parent.updateViewData(filteredData);
    }

    updatePaginationConfig(filteredData);
  }

  /**
   * Function to disable quick search if value filter or conditional filter is applied
  */
  function disableQuickSearch(customData, selectedValues){
    let searchDisabledFromFilter = false,
    colSearchValues;

    // If all values are checked then enable quick search
    if(isSearchEnabled){
      let searchUniqueValues = dataTable.getDataStore().getUniqueValues(customData, mappedCellIndex);
      searchUniqueValues.map((val) => {
        if(!selectedValues.includes(val)){
          searchDisabledFromFilter = true;
        }
      })
    }

    stores.colSearchValues.subscribe((val) => colSearchValues = val);
    colSearchValues.map((values) => {
      values.searchDisabledFromFilter = searchDisabledFromFilter;
    });
    stores.colSearchValues.set(colSearchValues);
  }

  function filterRowChanges(){
    let gridDataTable = gridData._gridDataTable,
    dataTable = gridDataTable._dataTable,
    sortState = gridData._sortState,
    tempColValues,
    filteredRows;
    stores.colSearchValues.subscribe((colValues) => {
      tempColValues = colValues
    } );
    filteredRows = dataTable.getDataStore().filterSearchRows(tempColValues, dataTable.getID());

    // If sorting is enabled and applied previously, then sort data after filter
    if(sortEnabled && sortState && sortState.parentDataIndex){
      sortDataAfterFilter(filteredRows);
    } // Else update view 
    else {
      parent.updateViewData(filteredRows);
    }

    // Update quick search latest state
    gridDataTable.setQuickSearchBase(filteredRows);
    searchTimeout = null;

    updatePaginationConfig(filteredRows);
    parent.trigger('searchchanged', {
      columns: {
          name: tempColValues[cellIndex].name,
          index: tempColValues[cellIndex].index,
          searchText: tempColValues[cellIndex].text
        }
    })
  }

  function sortDataAfterFilter(filteredRows){
    gridData.setPreSortOrder();
    gridData.sortGridRows(filteredRows);
  }

  function updatePaginationConfig(filteredRows){
    parent._pagination.setRowCount(filteredRows.length);
    parent._pagination.reconfigureState();
  }

  function handleChange(e) {
    let tempColValues,
      searchCellIndex = gridData._columnIndexMap[cellIndex - reduceColumnIndexBy];
    stores.colSearchValues.subscribe((colValues) => {
      tempColValues = colValues
    } );
    tempColValues[searchCellIndex].text = e.target.value;
    if(!multiColSearch){
      tempColValues.map((col, index) => {
      if(index !== searchCellIndex){
        col.text = ''
      }
    })
    }
    stores.colSearchValues.set(tempColValues);
    if(!searchTimeout){
      searchTimeout = setTimeout(() => {
        filterRowChanges()
      }, 500);
    }
  }

  export function resetSearchValue() {
    let tempColValues,
    searchCellIndex = gridData._columnIndexMap[cellIndex - reduceColumnIndexBy];
    stores.colSearchValues.subscribe((colValues) => {
      tempColValues = colValues
    } );
    tempColValues[searchCellIndex].text = '';
    stores.colSearchValues.set(tempColValues);
    if(!searchTimeout){
      searchTimeout = setTimeout(() => {
        filterRowChanges()
      }, 500);
    }
  }
</script>

{#if isSearchEnabled && !isSelectionCell}
<div
  class="fg-header-cell-textbox {extClassNames}
  {hoverClass}"
  bind:this={cellElem}
  style="{style}{extInlineStyleStr}"
  on:mouseover={handleMouseOver}
  on:mousemove={handleMouseMove}
  on:mouseout={handleMouseOut}>
  <div class="fg-input-wrapper">
    <input style={filterEnabled ? inputStyleWithFilter : ''} value={searchText} type="text" class="searchBox" disabled={(searchable !== undefined && !searchable) || searchDisabledFromFilter} on:keyup={handleChange} />
    {#if searchText}
    <div class="fg-cross-container" style={filterEnabled ? crossContainerStyle : ''}  on:click={(searchable !== undefined && !searchable) || searchDisabledFromFilter ? '' : resetSearchValue}>
      <CancelSearch />
    </div>
    {/if}
    {#if filterEnabled && showFilterIconOnHover}
      <div
      style={filterStyleWithSearch}
      on:click={handleFilterIconClick}>
      {#if isCellFilterApplied}
      <FilterIconActive />
      {:else}
        <FilterIcon />
      {/if}
    </div>
    {/if}
  </div>
</div>
{:else}
<div
  class="fg-header-cell {extClassNames}{headerClass || ''}
  {hoverClass}"
  bind:this={cellElem}
  style="{style}{extInlineStyleStr}{headerStyle || ''}"
  on:mouseover={handleMouseOver}
  on:mousemove={handleMouseMove}
  on:mouseout={handleMouseOut}
  on:click={handleClick}>
  {#if isSelectionCell}
    {#if !isSearchEnabled}
      <div class="fg-header-cell-checkbox">
        <CheckBox {headerRowSelected}/>
      </div>
    {/if}
  {:else if groupedHeader}
  <div class="fg-header-cell-content">
    {@html groupCell.headerName}
  </div>
  {:else}
    <div class="fg-header-cell-content">
      <div class='fg-header-cell-label'>
        {@html cellContent}
        {#if showSortIcon && filterEnabled && !quickSearchEnabled}
          {#if showAscIcon}
          <span class="fg-header-sort-icon">
            <SortAscIcon />
          </span>
          {/if}
          {#if showDescIcon}
          <span class="fg-header-sort-icon">
            <SortDescIcon />
          </span>
          {/if}
        {/if}
    </div>
    {#if filterEnabled && showFilterIconOnHover && !quickSearchEnabled }
        <div
        style='cursor: pointer'
        on:click={handleFilterIconClick}>
        {#if isCellFilterApplied}
        <FilterIconActive />
        {:else}
          <FilterIcon />
        {/if}
      </div>
      {/if}
      {#if showSortIcon && ((!filterEnabled && quickSearchEnabled) || (filterEnabled && quickSearchEnabled) || (!filterEnabled && !quickSearchEnabled))}
        {#if showAscIcon}
        <span class="fg-header-sort-icon">
          <SortAscIcon />
        </span>
        {/if}
        {#if showDescIcon}
        <span class="fg-header-sort-icon">
          <SortDescIcon />
        </span>
        {/if}
      {/if}
    </div>
    {#if showHelperIcon}
      <div class="fg-header-helper-icon">
        <HelperIcon tooltext={tooltipContent} />
      </div>
    {/if}
  {/if}
</div>
{/if}
{#if (!quickSearchEnabled || isSearchEnabled) && !isSelectionCell && !groupedHeader}
  {#if filterType === 'conditional' && filterIndex !== -1 && filterIndex === mappedCellIndex}
    <ConditionalFilter 
      cellIndex={mappedCellIndex} 
      {filterMenuStyle} 
      columnName={cellContent} 
      columnType={columnType} 
      {stores} 
      filterRows={applyConditionalFilter}
    />
  {:else if filterIndex !== -1 && filterIndex === mappedCellIndex}
    <ValueFilter 
      columnType={columnType}
      colIndex={mappedCellIndex} 
      {gridData} 
      filterData={filterData.data} 
      {uniqueViewData} 
      style={menuStyle} 
      onChange={updateValueFilter} 
      isChecked={valueFilterData[mappedCellIndex].selectedValues} 
      allSelected={valueFilterData[mappedCellIndex].allSelected}
      searchText={valueFilterData[mappedCellIndex].searchText}
      {updateGridOnSearch}
      {removeIntermediateState}
      {resetSearch}
    />
  {/if}
{/if}
