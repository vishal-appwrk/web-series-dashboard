<script>
  import Grid from "./type/grid.svelte";
  import Card from "./type/card.svelte";
  import CreditLabel from './creditLabel.svelte';
  import Pagination from './pagination/index.svelte';
  import { setContext, onMount } from "svelte";
  import Tooltip from "./tooltip.svelte";

  export let infiniteScrollManager;
  export let parsedCardConfig;
  export let container;
  export let paginationHandlers;
  export let stores;
  export let attachObserver;
  export let parent;
  export let handleCreditLabelClick;

  let isRow = true,
    layoutStateObj,
    autoHeightState,
    gridDim,
    parsedGridConfig,
    tooltipRef = {},
    gridData,
    vizRecDomain,
    pagination,
    dispatchEvent,
    filterData={index:-1, data:[]},
    childRef;
  onMount(() => {
    // dispatch rendered public event
    dispatchEvent('rendered', {
      container,
      gridConfig: parsedGridConfig
    });

    attachObserver(container);
    stores.hasRendered.set(true);
  });
  stores.layoutObject.subscribe(tmpLayoutObject => {
    isRow = tmpLayoutObject.layout.type !== "card"; // fallback to row if card is not explicitly mentioned
    if (isRow) {
      layoutStateObj = tmpLayoutObject.layoutState.rowLayout;
    } else {
      layoutStateObj = tmpLayoutObject.layoutState.cardLayout;
    }
  });
  stores.autoHeight.subscribe(tmpAutoHeightState => {
    autoHeightState = tmpAutoHeightState;
  });
  stores.visualUtils.subscribe(tmpVisualUtils => {
    gridData = tmpVisualUtils.gridData;
    parsedGridConfig = tmpVisualUtils.gridData.gridConfig;
    dispatchEvent = tmpVisualUtils.dispatchEvent;
  });
  stores.gridDimensions.subscribe(dim => {
      gridDim = dim;
  });
  stores.vizRecordDomain.subscribe(tmpVizRecDomain => {
    vizRecDomain = tmpVizRecDomain;
  });
  stores.paginationState.subscribe(paginationConfig => {
    pagination = paginationConfig;
  });
  setContext("parsedGridConfig", parsedGridConfig);
  setContext("tooltipRef", tooltipRef);
  setContext('dispatchEvent', dispatchEvent);
  setContext('parsedCardConfig', parsedCardConfig);
  setContext('gridContainer', container);

  function handleFilter(param){
      filterData.index = param
      filterData.data = gridData._gridDataTable._dataTable._dataStore.getUniqueValues(gridData._gridDataTable._data, param);
  }

  function filterSelectData(param){
    const array = gridData._gridDataTable._dataTable._data;
    // incase of select all or no filter selected, table will be reset
    if(param.length > 0){
      const filteredArray = gridData._gridDataTable._dataTable._dataStore.filterSelectedData(array,filterData.index,param)
      parent.updateViewData(filteredArray);
    } else if (param.length === 0) {
      parent.updateViewData([]);
    } else {
      parent.updateViewData(array)
    }
  }

  export function resetSearchValues(name){
    childRef.resetSearchValues(name);
  }
  
</script>

<div class="fg-root-wrapper {!isRow ? 'fg-layout-type-card' : ''}">
  {#if isRow}
    <Grid
      parent={parent}
      {gridData}
      {stores}
      bind:this={childRef}
      {vizRecDomain}
      handleFilter={handleFilter}
      filterData={filterData}
      filterSelectData={filterSelectData}
      rowLayout={layoutStateObj}
      {infiniteScrollManager}
      gridDimensions={gridDim}
      {parsedGridConfig}
      autoHeight={autoHeightState} />
  {:else}
    <Card 
      parent={parent}
      {gridData}
      {vizRecDomain}
      cardLayout={layoutStateObj}
      {infiniteScrollManager} 
      gridDimensions={gridDim}
      {parsedGridConfig}
      visualUtils = {stores.visualUtils}
      paginationEnabled = {pagination.enable}
      />
  {/if}
  {#if pagination.enable}
    <Pagination 
      parent={parent}
      config = {pagination}
      startRecord={vizRecDomain.start + 1}
      endRecord={vizRecDomain.end + 1}
      handlers={paginationHandlers}
      containerWidth={gridDim.width}/>
  {/if}
  <Tooltip {tooltipRef} gridDimensions={gridDim}/>
</div>
<CreditLabel hasCreditLabel={stores.hasCreditLabel} {handleCreditLabelClick} {stores} />
