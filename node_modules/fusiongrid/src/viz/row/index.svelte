<script>
  import HeaderCell from "../header/cell.svelte";
  import BodyCell from "../body/cell.svelte";
  import { getContext } from "svelte";

  export let type;
  export let style;
  export let rowIndex;
  export let rowHeight;
  export let gridLayout;
  export let hoveredColumnIndex;
  export let hovered;
  export let gridData;
	export let vizRecDomain;
  export let parsedGridConfig;
  export let handleFilter;
  export let filterSelectData;
  export let filterData;
  export let isSearchEnabled;
  export let parent;
  export let stores;
  export let groupedHeader;
  export let rowheight;
  export let quickSearchEnabled;
  export let hoveredGroupDetails;
  export let applyConditionalFilter;

  let dataStart = 0,
    dataEnd,
    rowInfo,
    extClassNames,
    extInlineStyle,
    extInlineStyleStr = "",
    rowSelectionState,
    bodyTransLateY,
    rowIndexInDT,
    rowHoverClass,
    rowSelectionClass,
    rowSelectionExtClasses,
		rowHoverExtClasses,
		headerState,
    rowState,
    selectionFeature,
    selectionEnabled,
    checkBoxEnabled,
    multiSelectionEnabled,
    rowHoverExtStyles,
    rowSelectionExtStyles,
    firstClick = true,
    firstClickTime,
    dispatchEvent = getContext('dispatchEvent'),
    firstClickTimer,
    mergedExtStyle,
    childRefs = [],
    columnGroups,
    sortIconOnHover = false,
    filterMenuStyle;
  $:{
    selectionFeature = gridData.gridConfig.rowoptions && gridData.gridConfig.rowoptions.selection;
    selectionEnabled = selectionFeature && selectionFeature.enable;
    checkBoxEnabled = selectionFeature && selectionFeature.enable && selectionFeature.enableselectioncheckbox;
    multiSelectionEnabled = selectionFeature && selectionFeature.enable && selectionFeature.rowselection === "multiple";
    columnGroups = gridData.gridConfig.columnGroups;
		headerState = gridLayout.headerDimState;
		rowState = gridLayout.rowDimState;
		dataStart = vizRecDomain.start;
    dataEnd = vizRecDomain.end;
    bodyTransLateY = vizRecDomain.bodyTransLateY || 0;
		if (type !== "header" && dataStart + rowIndex <= dataEnd) {
			rowInfo = gridData.getRowMetaInfo(dataStart + rowIndex);
      rowSelectionState = rowInfo && rowInfo.selected;
			extClassNames = (rowInfo.class || []).join(" ");
			extInlineStyle = rowInfo.style;
			rowHoverExtClasses = rowInfo.hoverClass;
      rowSelectionExtClasses = rowInfo.selectionClass;
      rowSelectionExtStyles = rowSelectionState && rowInfo.selectionStyle;
			extInlineStyleStr = "";
      rowIndexInDT = rowInfo.params.rowIndex;
      rowHoverExtStyles = hovered && rowInfo.hoverStyle;
      mergedExtStyle = {...extInlineStyle, ...rowHoverExtStyles, ...rowSelectionExtStyles};
			for (let key in mergedExtStyle) {
				extInlineStyleStr += key + ":" + mergedExtStyle[key] + ";";
      }
      rowHoverClass = hovered ? ("fg-row-hover " + rowHoverExtClasses.join(" ")) : "";
      rowSelectionClass = rowSelectionState ? (rowSelectionExtClasses ? rowSelectionExtClasses.join(" ") : "") || 'fg-row-selected'  : ""
    }
    filterMenuStyle = 'top:' + rowheight +'px;';
  }
  function onSingleSelect(finalRowIndex,e) {
    let prevRowSelectionIndex = gridData.getLatestSelectedRow();
    gridData.toggleRowSelectedState(finalRowIndex, e);
    if (prevRowSelectionIndex === finalRowIndex) {
      gridData.setLatestSelectedRow(undefined);
    } else {
      gridData.setLatestSelectedRow(finalRowIndex);
      gridData.setRowSelection(prevRowSelectionIndex, !gridData.getRowSelection(prevRowSelectionIndex));
    }
  }
  function onMultiSelect(finalRowIndex,e) {
    let globalSelectedState = gridData.getGlobalSelectedState();
    rowSelectionState = !rowSelectionState;
    gridData.toggleRowSelectedState(finalRowIndex, e);
    gridData.reEvaluateGlobalSelectedState();
  }
  function onGlobalSelect(e) {
    let globalSelectedState = gridData.getGlobalSelectedState();
    gridData.setGlobalSelectedState(!globalSelectedState);
    gridData.syncAllRowSelectedStateWithGlobalSelection(e);
  }
  function onColumnSort(event) {
    gridData.setSortDetails({
      cellIndex: event.cellIndex,
      parentDataIndex: event.parentDataIndex
    })
    gridData.sortGridRows();
  }
  function handleBodyRowClick(e){
    if (firstClick){ // single click
        dispatchEvent('rowclicked', {
          rowIndex,
          rowData: rowInfo.params.values,
          rowHeight: parsedGridConfig.rowoptions.rowheight,
          density: parsedGridConfig.layout.density
        }, e);
        dispatchEvent('recordclicked', {
          recordIndex: rowIndex
        }, e);
        firstClick = false;
        firstClickTime = window.performance.now();
        firstClickTimer = setTimeout(()=>{
            firstClick = true;
            firstClickTime = 0;
        }, 350);
    } else{ 
        // @todo: remove this block if double click is not needed
        clearTimeout(firstClickTimer);
        if ((window.performance.now() - firstClickTime) <=300){ // double click
            firstClickTime = 0;
            firstClick = true;
        }

    }
  }
  function handleAllClickActions(e){
    multiSelectionEnabled ? selectionEnabled && onMultiSelect.call(this, dataStart + rowIndex, e) : selectionEnabled && onSingleSelect.call(this, dataStart + rowIndex, e);
    handleBodyRowClick(e);
  }

  function toggleSortIndicator () {
    sortIconOnHover = !sortIconOnHover;
  }
  export function resetSearchValues(name){
    // name/index reset
    if(name !== undefined){
      let index;
      if(Number(name)){
        index = (Number(name) < childRefs.length) &&  Number(name);
      } else {
        index = schema.findIndex((sch) => sch.name === name);
      }
      childRefs[index].resetSearchValue();
    } // global reset  
    else {
      childRefs.map((ref) => {
        ref.resetSearchValue();
    }); 
    }
  }
</script>
{#if type === 'header' && isSearchEnabled}
<div class="fg-header-row" {style} on:mouseover={toggleSortIndicator} on:mouseout={toggleSortIndicator}>
  {#each headerState.cell as cellState, i}
    <HeaderCell
      parent={parent}
      {gridData}
      handleFilter={handleFilter}
      filterSelectData={filterSelectData}
      filterData={filterData}
      headerRowSelected={gridData.getGlobalSelectedState()}
      {onGlobalSelect}
      {checkBoxEnabled}
      {parsedGridConfig}
      style="left:{cellState.left}px;width:{cellState.width}px;"
      filterMenuStyle={filterMenuStyle + 'left:' + cellState.left + 'px;'}
      cellIndex={i}
      hovered = {hoveredColumnIndex === i}
      {hoveredGroupDetails}
      on:cellHoverIn
      on:cellHoverOut 
      isSearchEnabled={isSearchEnabled}
      {stores}
      {sortIconOnHover}
      bind:this={childRefs[i]}
      {applyConditionalFilter}
      />
  {/each}
</div> 
{:else if type === 'header' && groupedHeader}
<div class="fg-header-row" {style}>
  {#each columnGroups as groupCell, i}
    <HeaderCell
      parent={parent}
      {gridData}
      {groupCell}
      handleFilter={handleFilter}
      filterSelectData={filterSelectData}
      filterData={filterData}
      headerRowSelected={gridData.getGlobalSelectedState()}
      enableFilter={isSearchEnabled}
      {quickSearchEnabled}
      {onColumnSort}
      {onGlobalSelect}
      {checkBoxEnabled}
      {parsedGridConfig}
      filterMenuStyle={filterMenuStyle + 'left:' + headerState.cell[checkBoxEnabled ? groupCell.childStartIndex + 1 : groupCell.childStartIndex].left + 'px;'}
      style="top:{(groupCell.level - 1) * rowheight}px;height:{100/(groupCell.level + groupCell.totalHeight - 2)}%;left:{headerState.cell[checkBoxEnabled ? groupCell.childStartIndex + 1 : groupCell.childStartIndex].left}px;width:{groupCell.width}px;"
      {rowheight}
      cellIndex={i}
      hovered = {
        hoveredColumnIndex !== undefined ? 
        hoveredColumnIndex >= groupCell.childStartIndex && hoveredColumnIndex < groupCell.childCount + groupCell.childStartIndex :
        hoveredGroupDetails && hoveredGroupDetails.start === groupCell.childStartIndex &&  hoveredGroupDetails.end === groupCell.childCount + groupCell.childStartIndex
      }
      {hoveredGroupDetails}
      {stores}
      {groupedHeader}
      bind:this={childRefs[i]}
      on:cellHoverIn
      on:cellHoverOut 
      {applyConditionalFilter}
      />
  {/each}
</div>
{:else if type === 'header'}
  <div class="fg-header-row" {style} on:mouseover={toggleSortIndicator} on:mouseout={toggleSortIndicator}>
    {#each headerState.cell as cellState, i}
      <HeaderCell
        parent={parent}
        {gridData}
        headerRowSelected={gridData.getGlobalSelectedState()}
        handleFilter={handleFilter}
        filterSelectData={filterSelectData}
        filterData={filterData}
        {onColumnSort}
        {onGlobalSelect}
        {checkBoxEnabled}
        {parsedGridConfig}
        filterMenuStyle={filterMenuStyle + 'left:' + cellState.left + 'px;'}
        style="left:{cellState.left}px;width:{cellState.width}px;"
        cellIndex={i}
        hovered = {hoveredColumnIndex === i}
        {hoveredGroupDetails}
        {stores}
        {sortIconOnHover}
        enableFilter={isSearchEnabled}
        {quickSearchEnabled}
        bind:this={childRefs[i]}
        on:cellHoverIn
        on:cellHoverOut
        {applyConditionalFilter}
        />
    {/each}
  </div>
{:else}
  <div
    class="fg-row {rowIndex % 2 ? 'fg-row-odd ' : 'fg-row-even '}{extClassNames}
    {rowHoverClass}{rowSelectionClass}"
    style="{style}{extInlineStyleStr}; transform:
    translateY({bodyTransLateY}px)"
    on:click={e => handleAllClickActions(e)}>
    {#each headerState.cell as cellState, i}
      <BodyCell
        {gridData}
        {stores}
        {vizRecDomain}
        {rowSelectionState}
        {dataStart}
        style="left:{cellState.left}px;width:{cellState.width}px;"
        cellIndex={i}
        {rowIndex}
        {cellState}
        {rowHeight}
        {checkBoxEnabled}
        {parsedGridConfig}
        hovered = {hoveredColumnIndex === i}
        {hoveredGroupDetails}
        on:cellHoverIn
        on:cellHoverOut />
    {/each}
  </div>
{/if}
