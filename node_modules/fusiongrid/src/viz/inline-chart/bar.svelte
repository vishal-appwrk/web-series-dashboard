<script>
  import { getSpanDimension } from '../../utils/toolbox/src';
  import { ValueTextPositionType, ValueTextAlignmentType } from '../../public-api/interfaces';
  import { getContext } from "svelte";
  export let cellContent;
  export let scale;
  export let rowHeight;
  export let cellState,
    cellIndex,
    cellOrinalVal,
    parsedGridConfig,
    inlineChartStyle;

  let gridContainer = getContext('gridContainer'),
    DEFAULT_INLINE_CHART_FONT_SIZE = 12,
    currColumnConfig,
    showValue,
    valueTextAlignment,
    valueTextPosition,
    showHundrePercentBar,
    plotLeft,
    plotWidth,
    plotColor,
    labelLeft,
    plotDim,
    labelDim,
    barWidth,
    chartDim,
    contentApproximateWidth,
    zeroValuePos,
    progressBackgroundLeft,
    progressBackgroundPositive,
    progressBackgroundNegative,
    progressBackgroundWidth,
    textAnchorProp = ValueTextAlignmentType.start,
    progressBarOpacity = 0.35,
    positiveBarClass,
    positiveBarStyle,
    negativeBarClass,
    negativeBarStyle,
    hundredPercentBarClass,
    hundredPercentBarStyle,
    barClass,
    inlineBarStyle,
    inlineTextStyle = "",
    inlineBackgroundStyle = "",
    valueTextClass,
    valueTextStyle;

  // for null or undefined data we are not showing charts
  $: if (cellOrinalVal != null) {
    currColumnConfig = parsedGridConfig.columns[cellIndex].derivedChartConfig;
    // user given configuration
    showValue = currColumnConfig.showvalue;
    valueTextAlignment = currColumnConfig.valuetextalignment;
    valueTextPosition = currColumnConfig.valuetextposition;
    showHundrePercentBar = currColumnConfig.showhundredpercentbar;
    // calculated dataset leftmost and right most position
    [progressBackgroundNegative, progressBackgroundPositive] = [
      ...scale.getRange()
    ];
    // calculating all styles and classes
    valueTextClass = inlineChartStyle.valueTextClass && ([].concat(inlineChartStyle.valueTextClass)).join(" ");
    valueTextStyle = inlineChartStyle.valueTextStyle;
    for (let key in hundredPercentBarStyle) {
      inlineBackgroundStyle += key + ":" + hundredPercentBarStyle[key] + ";";
    }
    for (let key in valueTextStyle) {
      inlineTextStyle += key + ":" + valueTextStyle[key] + ";";
    }
    inlineBarStyle = "";
    labelLeft = 0;
    positiveBarClass = inlineChartStyle.positiveBarClass && ([].concat(inlineChartStyle.positiveBarClass)).join(" "),
    positiveBarStyle = inlineChartStyle.positiveBarStyle,
    negativeBarClass = inlineChartStyle.negativeBarClass && ([].concat(inlineChartStyle.negativeBarClass)).join(" "),
    negativeBarStyle = inlineChartStyle.negativeBarStyle,
    hundredPercentBarClass = inlineChartStyle.hundredPercentBarClass && ([].concat(inlineChartStyle.hundredPercentBarClass)).join(" "),
    hundredPercentBarStyle = inlineChartStyle.hundredPercentBarStyle,
    barWidth = scale.getRangeValue(cellOrinalVal);
    plotDim = cellState.inlinechartDim.dataSetDimention;
    labelDim = cellState.inlinechartDim.labelDimention;
    chartDim = cellState.inlinechartDim.chartDimention;
    // used when label gets out of the allocated column width
    contentApproximateWidth = getSpanDimension(document,gridContainer,{'font-size':labelDim.fontSize+'px'}, cellContent).width;
    zeroValuePos = scale.getRangeValue(0);
    // label, progress background, and dataplot position calculated for +ve values
    if (cellOrinalVal >= 0) {
      progressBackgroundLeft = plotLeft = zeroValuePos;
      barClass = positiveBarClass;
      for (let key in positiveBarStyle) {
        inlineBarStyle += key + ":" + positiveBarStyle[key] + ";";
      }
      plotWidth = barWidth - zeroValuePos;
      plotColor = "#00b7e4";
      plotWidth = plotWidth > 0 && plotWidth < 1 ? 1 : plotWidth;
      progressBackgroundWidth = progressBackgroundPositive - zeroValuePos;
      if (valueTextAlignment === ValueTextAlignmentType.start) {
        labelLeft =
          valueTextPosition === ValueTextPositionType.inside ? plotLeft + 5 : zeroValuePos;
        textAnchorProp = ValueTextAlignmentType.start;
      } else if (valueTextAlignment === ValueTextAlignmentType.middle) {
        labelLeft =
          valueTextPosition === ValueTextPositionType.inside
            ? plotLeft + plotWidth * 0.5
            : plotLeft + progressBackgroundWidth * 0.5;
        textAnchorProp = ValueTextAlignmentType.middle;
      } else if (valueTextAlignment === ValueTextAlignmentType.end) {
        labelLeft =
          valueTextPosition === ValueTextPositionType.inside
            ? plotLeft + plotWidth - 5
            : progressBackgroundPositive;
        textAnchorProp = ValueTextAlignmentType.end;
      }
      if (valueTextPosition === ValueTextPositionType.right) {
        labelLeft =
          progressBackgroundPositive +
          chartDim.labelDataSetHGap +
          labelDim.width;
        textAnchorProp = ValueTextAlignmentType.end;
      } else if (valueTextPosition === ValueTextPositionType.left) {
        labelLeft = chartDim.leftPadding;
        textAnchorProp = ValueTextAlignmentType.start;
      }

      // special check added, when text nodes with positive values are getting out of available width, updating labelLeft to position within cell
      if (valueTextPosition !== ValueTextPositionType.left && valueTextPosition !== ValueTextPositionType.right) {
        if (contentApproximateWidth > cellState.width) {
          labelLeft = chartDim.leftPadding;
          textAnchorProp = ValueTextAlignmentType.start;
        } else if (valueTextAlignment === ValueTextAlignmentType.start && (contentApproximateWidth + labelLeft > cellState.width)) {
          labelLeft -= (contentApproximateWidth + labelLeft + chartDim.rightPadding) - cellState.width;
        } else if (valueTextAlignment === ValueTextAlignmentType.middle && ((contentApproximateWidth / 2) + labelLeft > cellState.width)) {
          // adding half of the contentApproximateWidth as textanchor set as middle
          labelLeft -= ((contentApproximateWidth /2) + labelLeft + chartDim.rightPadding) - cellState.width;
        } else if (valueTextAlignment === ValueTextAlignmentType.end && (labelLeft - contentApproximateWidth < 0)) {
          labelLeft += contentApproximateWidth - labelLeft + chartDim.leftPadding;
        }
      }
    } else {    // label, progress background, and dataplot position calculated for +ve values
      progressBackgroundLeft = progressBackgroundNegative;
      barClass = negativeBarClass;
      for (let key in negativeBarStyle) {
        inlineBarStyle += key + ":" + negativeBarStyle[key] + ";";
      }
      plotWidth = zeroValuePos - barWidth;
      plotWidth = plotWidth > 0 && plotWidth < 1 ? 1 : plotWidth;
      plotLeft = barWidth;
      progressBackgroundWidth = zeroValuePos - progressBackgroundNegative;
      plotColor = "#ffa75c";
      if (valueTextAlignment === ValueTextAlignmentType.start) {
        labelLeft =
          valueTextPosition === ValueTextPositionType.inside ? zeroValuePos - 5 : zeroValuePos;
        textAnchorProp = ValueTextAlignmentType.end;
      } else if (valueTextAlignment === ValueTextAlignmentType.middle) {
        labelLeft =
          valueTextPosition === ValueTextPositionType.inside
            ? plotLeft + plotWidth * 0.5
            : zeroValuePos * 0.5;
        textAnchorProp = ValueTextAlignmentType.middle;
      } else if (valueTextAlignment === ValueTextAlignmentType.end) {
        labelLeft =
          valueTextPosition === ValueTextPositionType.inside
            ? plotLeft + 5
            : progressBackgroundNegative;
        textAnchorProp = ValueTextAlignmentType.start;
      }
      if (valueTextPosition === ValueTextPositionType.right) {
        labelLeft =
          progressBackgroundPositive +
          chartDim.labelDataSetHGap +
          labelDim.width -
          progressBackgroundNegative;
        textAnchorProp = ValueTextAlignmentType.end;
      } else if (valueTextPosition === ValueTextPositionType.left) {
        labelLeft = chartDim.leftPadding;
        textAnchorProp = ValueTextAlignmentType.start;
      }
      // special check added, when text nodes with -ve values are getting out of available width, updating labelLeft to position within cell
      if (valueTextPosition !== ValueTextPositionType.left && valueTextPosition !== ValueTextPositionType.right) {
        if (contentApproximateWidth > cellState.width) {
          labelLeft = chartDim.leftPadding;
          textAnchorProp = ValueTextAlignmentType.start;
        } else if (valueTextAlignment === ValueTextAlignmentType.start && (labelLeft - contentApproximateWidth < 0)) {
          labelLeft += contentApproximateWidth - labelLeft + chartDim.leftPadding;
        } else if (valueTextAlignment === ValueTextAlignmentType.middle && (labelLeft - (contentApproximateWidth / 2) < 0)) {
          // adding half of the contentApproximateWidth as textanchor set as middle
          labelLeft += (contentApproximateWidth / 2)- labelLeft + chartDim.leftPadding;
        } else if (valueTextAlignment === ValueTextAlignmentType.end && (contentApproximateWidth + labelLeft + chartDim.rightPadding > cellState.width)) {
          labelLeft -= (contentApproximateWidth + labelLeft + chartDim.rightPadding) - cellState.width;
        }
      }
    }
  }
</script>

{#if cellOrinalVal != null}
  <svg
    height="{rowHeight}px"
    width="{cellState.width}px"
    xmlns="http://www.w3.org/2000/svg">
    {#if showHundrePercentBar}
      <rect
        x="{progressBackgroundLeft}px"
        y="{plotDim.top}px"
        width="{progressBackgroundWidth}px"
        height="{plotDim.height}px"
        fill={plotColor}
        opacity={progressBarOpacity}
        class = {hundredPercentBarClass ? hundredPercentBarClass : ''}
        style = {inlineBackgroundStyle ? inlineBackgroundStyle : ''} />
    {/if}
    <rect
      x="{plotLeft}px"
      y="{plotDim.top}px"
      width="{plotWidth}px"
      height="{plotDim.height}px"
      fill={plotColor}
      class = {barClass ? barClass : ''}
      style = {inlineBarStyle ? inlineBarStyle : ''} />
    {#if showValue == true}
      <text
        x="{labelLeft}px"
        y="{labelDim.top}px"
        fill="#5f5f5f"
        font-size = {labelDim.fontSize}
        class = {valueTextClass ? valueTextClass : ''}
        style = {inlineTextStyle ? inlineTextStyle : ''}
        text-anchor={textAnchorProp}>
        {cellContent}
      </text>
    {/if}
  </svg>
{/if}
