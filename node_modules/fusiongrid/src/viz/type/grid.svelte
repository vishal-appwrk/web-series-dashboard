<script>
  import Header from "../header/index.svelte";
  import Body from "../body/index.svelte";
  import { onMount, setContext, getContext } from "svelte";
  import { dummyFunc } from "../../globals/helpers/helpers.ts";
  import { isIOS } from '../../utils/toolbox/src/browsers/browser-type';
  import { syncScroll } from "../../utils/toolbox/src";
  import ConditionalFilterGlobalIndicator from '../filters/conditionalFilterIndicator.svelte';
  import {getConfigScope} from '../../utils/index';

  export let infiniteScrollManager;
  export let autoHeight;
  export let rowLayout;
  export let gridData;
  export let vizRecDomain;
  export let handleFilter;
  export let filterSelectData;
  export let gridDimensions;
  export let parsedGridConfig;
  export let filterData;
  export let parent;
  export let stores;

  const HORIZONTAL = 'horizontal',
    VERTICAL = 'vertical';

  let element, 
    headerContainerRef = {},
    bodyContainerRef = {},
    bodyScrollLeft = 0,
    hoveredColumnIndex,
    hoverInRowIndex,
    tooltipRef = getContext("tooltipRef"),
    dispatchEvent = getContext("dispatchEvent"),
    columns,
    rowOptions,
    prevHoveredRowIndex,
    prevHoveredColumnIndex,
    columnHoverOutTimer,
    rowHoverOutTimer,
    headerHeight,
    bodyHeight,
    totalBodyHeight,
    totalBodyWidth,
    rowMetaData,
    gridHeight,
    childRef,
    hoveredGroupDetails,
    globalHoverEnable,
    searchable,
    isSearchEnabled,
    sortEnabled,
    localSortState,
    globalSortState;
  $: {
    headerHeight = rowLayout.headerDimState.height;
    gridHeight = gridDimensions.height;
    bodyHeight = gridHeight - headerHeight;
    totalBodyHeight = rowLayout.totalBodyHeight;
    totalBodyWidth = rowLayout.totalWidth;
    columns = parsedGridConfig.columns;
    rowOptions = parsedGridConfig.rowoptions;
    globalHoverEnable = parsedGridConfig.defaultcolumnoptions && parsedGridConfig.defaultcolumnoptions.hover && parsedGridConfig.defaultcolumnoptions.hover.enable;
    searchable = parsedGridConfig.defaultcolumnoptions.searchable;
    if(typeof searchable === 'boolean'){
      isSearchEnabled = searchable;
    } else if(typeof searchable === 'object'){
      isSearchEnabled = searchable.enable;
    }
    localSortState = parsedGridConfig.columns.find((col, cellIndex) => ((typeof col.sortable === 'object' && col.sortable !== null ) ? col.sortable.enable : col.sortable));
    globalSortState = (typeof parsedGridConfig.defaultcolumnoptions.sortable === 'object' && parsedGridConfig.defaultcolumnoptions.sortable !== null ) ? parsedGridConfig.defaultcolumnoptions.sortable.enable : parsedGridConfig.defaultcolumnoptions.sortable;
    sortEnabled = getConfigScope(localSortState, globalSortState);
  }
  onMount(() => {
    syncScroll(headerContainerRef.node, bodyContainerRef.node, "horizontal");
    // fix for hover out issue in ios
    isIOS && document.addEventListener('click', dummyFunc);
  });
  function handleHoverIn(e) {
    let { actualColIndex, visualColIndex, rowindex, groupDetails } = e.detail;
    clearTimeout(columnHoverOutTimer); // clear previous hoverout timer
    if (visualColIndex !== undefined && visualColIndex !== prevHoveredColumnIndex) {
      // set new column hover index only if its different than the previous index
      if (columns[actualColIndex].hover && columns[actualColIndex].hover.enable) {
        hoveredColumnIndex = prevHoveredColumnIndex = visualColIndex;
        dispatchEvent('columnhovered', {
          columnIndex: actualColIndex,
          columnOptions: parsedGridConfig.columns[actualColIndex]
        }, e);
      } else {
        hoveredColumnIndex = prevHoveredColumnIndex = undefined;
      }
      hoveredGroupDetails = undefined;
    }

    if(groupDetails && globalHoverEnable){
      hoveredColumnIndex = undefined;
      hoveredGroupDetails = groupDetails;
    }
    clearTimeout(rowHoverOutTimer); // clear previous hoverout timer
    if (
      rowOptions.hover &&
      rowOptions.hover.enable &&
      rowindex !== undefined &&
      rowindex !== prevHoveredRowIndex &&
      rowindex !== -1 // do not perform operations for header row
    ) {
      rowMetaData = gridData.getRowMetaInfo(rowindex);
      // set new row hover index only if its different than the previous index
      hoverInRowIndex = prevHoveredRowIndex = rowindex;
      dispatchEvent('rowhovered', {
        rowIndex: rowindex,
        rowData: rowMetaData.params.values,
        rowHoverClass: rowMetaData.hoverClass,
        rowHoverStyle: rowMetaData.hoverStyle
      }, e);
    }

    if(rowindex === -1){
      hoverInRowIndex = prevHoveredRowIndex = undefined;
    }
  }
  function handleHoverOut(e) {
    // do not remove colum hover index instantly, as the hoverout may happen on a different element
    // of the same cell
    columnHoverOutTimer = setTimeout(() => {
      hoveredColumnIndex = prevHoveredColumnIndex = undefined;
      hoveredGroupDetails = undefined;
    }, 20);
    // do not remove row hover index instantly, as the hoverout may happen on a different element
    // of the same cell
    rowHoverOutTimer = setTimeout(() => {
      hoverInRowIndex = prevHoveredRowIndex = undefined;
      hoveredGroupDetails = undefined;
    }, 20);
  }
  export function resetSearchValues(name){
    childRef.resetSearchValues(name);
  }
  function handleClick(e){
    let filterIndex; 
    stores.filterIndex.subscribe((value) => {
      filterIndex = value;
    })
    if (!(e.target.closest('.fg-filter-menu-container') || e.target.closest('.fg-conditional-filter-container') || e.target.closest('.fg-cross-filter-container') || e.target.closest('.fg-filters-container') || e.target.closest('.fg-clear-filter') || e.target.closest('fg-global-conditions-wrapper') || e.target.closest('.fg-deselect-icon') || e.target.closest('.fg-filter-value-row')) && filterIndex !== -1) {
      stores.filterIndex.set(-1);
    }
  }

   /**
   * Function to trigger conditional filter on columns
   */
   function applyConditionalFilter(){
    let gridDataTable = gridData._gridDataTable,
      dataTable = gridData._gridDataTable._dataTable,
      conditionalFilterValues,
      conditionalFilterOperator,
      sortState = gridData._sortState,
      filteredRows = [],
      customData;
    
    // Get filter details for each column
    stores.conditionalFilterValues.subscribe((values) => {
      conditionalFilterValues = values
    });

    // Get logical operator detail for each column
    stores.conditionalFilterLogicalOperators.subscribe((value) => conditionalFilterOperator = value);

    // Disable quick search if conditional filter is applied
    if(isSearchEnabled){
      let searchDisabledFromFilter = false,
        colSearchValues;

      // Change base of filter to quick search's last state
      customData = gridDataTable.quickSearchBase;

      // Disable quick search if conditional filter is getting applied
      conditionalFilterValues.map((columnData) => {
        columnData && columnData.map((condition) => {
          if(condition.value){
            searchDisabledFromFilter = true;
          }
        })
      })

      stores.colSearchValues.subscribe((val) => colSearchValues = val);
      colSearchValues.map((values) => {
        values.searchDisabledFromFilter = searchDisabledFromFilter;
      });
      stores.colSearchValues.set(colSearchValues);
    }

    // Get filter applied data and update in grid
    filteredRows = dataTable.getDataStore().applyConditionalFilter(customData, conditionalFilterValues, conditionalFilterOperator, dataTable.getID()); 

    // If sorting is enabled and applied previously, then sort data after filter
    if(sortEnabled && sortState && sortState.parentDataIndex !== undefined && filteredRows.length){
      sortDataAfterFilter(filteredRows);
    } // Else update view 
    else {
      parent.updateViewData(filteredRows);
    }

    updatePaginationConfig(filteredRows);
  }

  function updatePaginationConfig(filteredRows){
    parent._pagination.setRowCount(filteredRows.length);
    parent._pagination.reconfigureState();
  }

  function sortDataAfterFilter(filteredRows){
    gridData.setPreSortOrder();
    gridData.sortGridRows(filteredRows);
  }
  function handleScroll(e){
    // hide the tooltip when body scrolls
    tooltipRef.tooltip.hide();
    if (element.scrollLeft !== bodyScrollLeft){
      // horizontal scroll
      bodyScrollLeft = element.scrollLeft;
      dispatchEvent('scroll', {
        direction: HORIZONTAL,
        top: element.scrollTop,
        left: element.scrollLeft
      }, e);
    } else {
        // vertical scroll
        infiniteScrollManager.updateHScrollProps(e);
        dispatchEvent('scroll', {
        direction: VERTICAL,
        top: element.scrollTop,
        left: element.scrollLeft
      }, e);
    }
  }
</script>

<div class="fg-grid-wrapper"
  bind:this={element}
  on:click={handleClick}
  on:scroll={e => handleScroll(e)}
>
  <ConditionalFilterGlobalIndicator 
    {stores}
    {applyConditionalFilter}
    {gridData}
  />
  <Header
    parent={parent}
    {gridData}
    handleFilter={handleFilter}
      filterSelectData={filterSelectData}
      filterData={filterData}
    {stores}
    bind:this={childRef}
    {vizRecDomain}
    gridLayout={rowLayout}
    headerContainer={headerContainerRef}
    bodyWidthOverflowed={totalBodyWidth > gridDimensions.width}
    bodyContentOverflowed={totalBodyHeight > bodyHeight}
    {hoveredColumnIndex}
    {hoveredGroupDetails}
    {parsedGridConfig}
    {gridDimensions}
    on:cellHoverIn={handleHoverIn}
    on:cellHoverOut={handleHoverOut} 
    {applyConditionalFilter}
    />
  <Body
    {gridData}
    {stores}
    {vizRecDomain}
    {parsedGridConfig}
    gridLayout={rowLayout}
    bodyContainer={bodyContainerRef}
    {infiniteScrollManager}
    {autoHeight}
    {bodyHeight}
    {hoveredColumnIndex}
    {hoveredGroupDetails}
    {prevHoveredRowIndex}
    hoverInRowIndex = {hoverInRowIndex - vizRecDomain.start}
    on:cellHoverIn={handleHoverIn}
    on:cellHoverOut={handleHoverOut} />
</div>
