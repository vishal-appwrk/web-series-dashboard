import { columnIndexOf, columnMinValue, columnMaxValue, columnExtents, columnUnique, columnMinDiff } from '../../src/utils/datatable-utils';

let UNDEF, 
  schema = [
    {
      name: 'DateRange',
      type: 'interval'
    },
    {
      name: 'Date',
      type: 'datetime'
    },
    {
      name: 'Country'
    },
    {
      name: 'Name',
      type: 'string'
    },
    {
      name: 'Revenue',
      type: 'number'
    },
    {
      name: 'Status',
      type: 'number'
    }
  ], data = [
    [{ start: +new Date(2018, 0, 1), end: +new Date(2018, 1, 1) }, +new Date(2018, 0, 15), 'India', 'Tata', 10000, 0],
    [{ start: +new Date(2016, 5, 1), end: +new Date(2016, 7, 18) }, +new Date(2017, 7, 2), 'India', null, null, 0],
    [null, +new Date(2018, 0, 1), null, 'Google', 25000, 0],
    [{ start: +new Date(2017, 0, 1), end: +new Date(2018, 1, 15) }, UNDEF, 'USA', 'Facebook', 50000, 0],
    [{ start: +new Date(2015, 0, 1), end: +new Date(2015, 1, 15) }, +new Date(2015, 0, 19), 'USA', 'Netflix', UNDEF, 0]
  ];

describe('columnIndexOf test cases', () => {
  it('returns the 0 based index', () => {
    expect(columnIndexOf('Country', schema)).toBe(2);
  });

  it('returns -1 for wrong column', () => {
    expect(columnIndexOf('Countryyaa', schema)).toBe(-1);
  });

  it('returns null for missing column name and schema name', () => {
    expect(columnIndexOf('Countryyaa')).toBeNull();
    expect(columnIndexOf(null, schema)).toBeNull();
  });
});

describe('columnMinValue test cases', () => {
  it('returns the minimum value from a number column', () => {
    expect(columnMinValue('Revenue', data, schema)).toBe(10000);
  });

  it('returns the minimum value from a date column', () => {
    expect(columnMinValue('Date', data, schema)).toBe(+new Date(2015, 0, 19));
  });

  it('returns the minimum start value from an interval column', () => {
    expect(columnMinValue('DateRange', data, schema)).toBe(+new Date(2015, 0, 1));
  });

  it('returns 0 from an all zero column', () => {
    expect(columnMinValue('Status', data, schema)).toBe(0);
  });
});

describe('columnMaxValue test cases', () => {
  it('returns the maximum value from a number column', () => {
    expect(columnMaxValue('Revenue', data, schema)).toBe(50000);
  });

  it('returns the maximum value from a date column', () => {
    expect(columnMaxValue('Date', data, schema)).toBe(+new Date(2018, 0, 15));
  });

  it('returns the maximum end value from an interval column', () => {
    expect(columnMaxValue('DateRange', data, schema)).toBe(+new Date(2018, 1, 15));
  });

  it('returns 0 from an all zero column', () => {
    expect(columnMaxValue('Status', data, schema)).toBe(0);
  });
});

describe('columnExtents test cases', () => {
  it('returns the maximum value from a number column', () => {
    expect(columnExtents('Revenue', data, schema)).toEqual({ min: 10000, max: 50000 });
  });

  it('returns the maximum value from a date column', () => {
    expect(columnExtents('Date', data, schema)).toEqual({ min: +new Date(2015, 0, 19), max: +new Date(2018, 0, 15) });
  });

  it('returns the maximum end value from an interval column', () => {
    expect(columnExtents('DateRange', data, schema)).toEqual({ min: +new Date(2015, 0, 1), max: +new Date(2018, 1, 15) });
  });

  it('returns 0 from an all zero column', () => {
    expect(columnExtents('Status', data, schema)).toEqual({ min: 0, max: 0 });
  });
});

describe('columnUnique test cases', () => {
  it('returns the maximum value from a number column', () => {
    expect(columnUnique('Revenue', data, schema)).toEqual([10000, null, 25000, 50000, UNDEF]);
  });

  it('returns the maximum value from a string column', () => {
    expect(columnUnique('Country', data, schema)).toEqual(['India', null, 'USA']);
  });
});

describe('columnMinDiff test cases', () => {
  it('when all values are null returns null', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', null],
        ['B', null],
        ['C', null]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(null);
  });

  it('when all values are undefined returns null', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', UNDEF],
        ['B', UNDEF],
        ['C', UNDEF]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(null);
  });

  it('when all values are 0 returns 0', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', 0],
        ['B', 0],
        ['C', 0]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(0);
  });

  it('when all values are same returns 0', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', 10],
        ['B', 10],
        ['C', 10]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(0);
  });

  it('returns difference between numbers when negative values are present', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', -10],
        ['B', 8],
        ['C', -3]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(7);

    dataCMD = [
      ['A', -10],
      ['B', 8],
      ['C', -3],
      ['C', -10]
    ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(0);
  });

  it('returns difference between numbers when separated by null', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', 8],
        ['B', null],
        ['C', null],
        ['D', 3]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(5);
  });

  it('returns difference between numbers when separated by undefined', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', 8],
        ['B', UNDEF],
        ['C', UNDEF],
        ['D', 3]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(5);
  });

  it('returns difference between numbers when separated by null and undefined', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', 8],
        ['B', null],
        ['C', UNDEF],
        ['D', 3]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(5);
  });

  it('returns difference between numbers when 0 present', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', 8],
        ['B', 12],
        ['C', 0],
        ['D', 3]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(3);
  });

  it('returns difference between numbers when 0 and null present', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', 8],
        ['B', null],
        ['C', 0],
        ['D', 3]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(3);
  });

  it('returns difference between numbers when 0 and undefined present', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', 8],
        ['B', UNDEF],
        ['C', 0],
        ['D', 3]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(3);
  });

  it('returns difference between numbers when 0, undefined and null present', () => {
    let schemaCMD = [{
        name: 'Item',
        type: 'string'
      }, {
        name: 'Value',
        type: 'number'
      }],
      dataCMD = [
        ['A', 8],
        ['B', null],
        ['C', 0],
        ['D', UNDEF],
        ['E', UNDEF],
        ['F', 3]
      ];

    expect(columnMinDiff('Value', dataCMD, schemaCMD, 'Item')).toBe(3);
  });
});
