import { carsData, schema } from '../../sample/data/cars';
import isSorted from '../../src//utils/datatable-sort-utils';
import sort from '../../src/operators/sort';
import DataStore from '../../src/datastore';

let dataStore = new DataStore(carsData, schema, { enableIndex: false }),
  dataTable = dataStore.getDataTable(),
  data = dataTable.getData().data, UNDEF;

describe('sort operator test', () => {
  it('sorts in ascending order on a single column', () => {
    let sortOps = sort({ column: 'Miles_per_Gallon' }),
      sortFn = sortOps.fn(data, schema),
      sortDt = sortFn.generatorFn();
    expect(isSorted(sortDt, (a, b) => a[1] - b[1])).toBe(true);
  });

  it('sorts in descending order on a single column', () => {
    let sortOps = sort({ column: 'Miles_per_Gallon', order: 'desc' }),
      sortFn = sortOps.fn(data, schema),
      sortDt = sortFn.generatorFn();
    expect(isSorted(sortDt, (a, b) => b[1] - a[1])).toBe(true);
  });

  it('sorts using custom function on a single column', () => {
    let sortOps = sort((a, b) => b[1] - a[1]),
      sortFn = sortOps.fn(data, schema),
      sortDt = sortFn.generatorFn();
    expect(isSorted(sortDt, (a, b) => b[1] - a[1])).toBe(true);
  });

  it('sort on string column - ascending order', () => {
    let dataCopy = [[
        'Japan', 10000
      ], [
        'India', 20000
      ], [
        'Argentina', 15000
      ], [
        'India', 15000
      ]],
      dataCopySchema = [{
        'name': 'Country'
      }, {
        'name': 'Value'
      }], sortOps = sort({ column: 'Country' }),
      sortFn = sortOps.fn(dataCopy, dataCopySchema),
      sortDt = sortFn.generatorFn();
    expect(isSorted(sortDt, (a, b) => { return a[0] === b[0] ? 0 : a[0] < b[0] ? -1 : 1; }, 0)).toBe(true);
  });

  it('sort on string column - descending order', () => {
    let dataCopy = [[
        'Japan', 10000
      ], [
        'India', 20000
      ], [
        'Argentina', 15000
      ], [
        'India', 15000
      ]],
      dataCopySchema = [{
        'name': 'Country'
      }, {
        'name': 'Value'
      }], sortOps = sort({ column: 'Country', order: 'desc' }),
      sortFn = sortOps.fn(dataCopy, dataCopySchema),
      sortDt = sortFn.generatorFn();
    expect(isSorted(sortDt, (a, b) => { return a[0] === b[0] ? 0 : a[0] < b[0] ? -1 : 1; }, 1)).toBe(true);
  });

  it('sort on string column - when both lower and upper case is present', () => {
    let dataCopy = [[
        'Japan', 10000
      ], [
        'India', 20000
      ], [
        'Argentina', 15000
      ], [
        'India', 15000
      ], [
        'india', 15000
      ], [
        'InDia', 15000
      ], [
        'INDIA', 15000
      ], [
        'INdia', 15000
      ]],
      dataCopySchema = [{
        'name': 'Country'
      }, {
        'name': 'Value'
      }], sortOps = sort({ column: 'Country' }),
      sortFn = sortOps.fn(dataCopy, dataCopySchema),
      sortDt = sortFn.generatorFn();
    expect(isSorted(sortDt, (a, b) => { return a[0] === b[0] ? 0 : a[0] < b[0] ? -1 : 1; }, 0)).toBe(true);
  });

  it('sort on string column - when both lower, upper, null, undefined, numbers are present', () => {
    let dataCopy = [[
        'Japan', 10000
      ], [
        'India', 20000
      ], [
        200, 20000
      ], [
        120, 20000
      ], [
        'Argentina', 15000
      ], [
        100, 15000
      ], [
        'india', 15000
      ], [
        'InDia', 15000
      ], [
        'INDIA', 15000
      ], [
        null, 15000
      ], [
        'INdia', 15000
      ], [
        UNDEF, 15000
      ], [
        'India', 15000
      ]],
      dataCopySchema = [{
        'name': 'Country'
      }, {
        'name': 'Value'
      }], sortOps = sort({ column: 'Country' }),
      sortFn = sortOps.fn(dataCopy, dataCopySchema),
      sortDt = sortFn.generatorFn(),
      sortDtCountries = sortDt.map(x => x[0]);

    expect(sortDtCountries).toEqual(['Argentina',
      'INDIA',
      'INdia',
      'InDia',
      'India',
      'India',
      'Japan',
      'india',
      100,
      120,
      200,
      null,
      UNDEF ]);
  });

  it('sort on interval column - ascending order', () => {
    let dataCopy = [[
        {
          start: +new Date(2018, 5, 1),
          end: +new Date(2018, 5, 30)
        }, 'A', 200
      ], [{
        start: +new Date(2018, 6, 1),
        end: +new Date(2018, 6, 30)
      }, 'B', 300], [{
        start: +new Date(2018, 1, 1),
        end: +new Date(2018, 1, 30)
      }, 'C', 500], [{
        start: +new Date(2018, 4, 1),
        end: +new Date(2018, 4, 30)
      }, 'D', 200], [{
        start: +new Date(2018, 3, 1),
        end: +new Date(2018, 3, 30)
      }, 'E', 900]],
      dataCopySchema = [{
        name: 'OrderDate',
        type: 'interval'
      }, {
        name: 'Name'
      }, {
        name: 'Value',
        type: 'number'
      }], sortOps = sort({ column: 'OrderDate' }),
      sortFn = sortOps.fn(dataCopy, dataCopySchema),
      sortDt = sortFn.generatorFn();
    expect(isSorted(sortDt, (a, b) => a[0].start - b[0].start)).toBe(true);
  });

  it('sorts multiple levels', () => {
    let sortOps = sort([{ column: 'Miles_per_Gallon' }, { column: 'Displacement', comparator: (a, b) => a[3] - b[3] }, { column: 'Horsepower', order: 'desc' }]),
      sortFn = sortOps.fn(data, schema),
      sortDt = sortFn.generatorFn(), expectedData = [], row, sortedDataWithoutId,
      expectedJSON = [{
        'Name': 'datsun pl510',
        'Miles_per_Gallon': 27,
        'Cylinders': 4,
        'Displacement': 97,
        'Horsepower': 88,
        'Weight_in_lbs': 2130,
        'Acceleration': 14.5,
        'Year': 0,
        'Origin': 'Japan'
      }, {
        'Name': 'datsun pl510',
        'Miles_per_Gallon': 27,
        'Cylinders': 4,
        'Displacement': 97,
        'Horsepower': 88,
        'Weight_in_lbs': 2130,
        'Acceleration': 14.5,
        'Year': 31536000000,
        'Origin': 'Japan'
      }, {
        'Name': 'toyota corolla 1600 (sw)',
        'Miles_per_Gallon': 27,
        'Cylinders': 4,
        'Displacement': 97,
        'Horsepower': 88,
        'Weight_in_lbs': 2100,
        'Acceleration': 16.5,
        'Year': 63072000000,
        'Origin': 'Japan'
      },
      {
        'Name': 'volkswagen model 111',
        'Miles_per_Gallon': 27,
        'Cylinders': 4,
        'Displacement': 97,
        'Horsepower': 60,
        'Weight_in_lbs': 1834,
        'Acceleration': 19,
        'Year': 31536000000,
        'Origin': 'Europe'
      }, {
        'Name': 'renault 12tl',
        'Miles_per_Gallon': 27,
        'Cylinders': 4,
        'Displacement': 101,
        'Horsepower': 83,
        'Weight_in_lbs': 2202,
        'Acceleration': 15.3,
        'Year': 189302400000,
        'Origin': 'Europe'
      }, {
        'Name': 'chevrolet cavalier wagon',
        'Miles_per_Gallon': 27,
        'Cylinders': 4,
        'Displacement': 112,
        'Horsepower': 88,
        'Weight_in_lbs': 2640,
        'Acceleration': 18.6,
        'Year': 378691200000,
        'Origin': 'USA'
      }, {
        'Name': 'ford mustang gl',
        'Miles_per_Gallon': 27,
        'Cylinders': 4,
        'Displacement': 140,
        'Horsepower': 86,
        'Weight_in_lbs': 2790,
        'Acceleration': 15.6,
        'Year': 378691200000,
        'Origin': 'USA'
      }, {
        'Name': 'pontiac phoenix',
        'Miles_per_Gallon': 27,
        'Cylinders': 4,
        'Displacement': 151,
        'Horsepower': 90,
        'Weight_in_lbs': 2735,
        'Acceleration': 18,
        'Year': 378691200000,
        'Origin': 'USA'
      }, {
        'Name': 'chevrolet camaro',
        'Miles_per_Gallon': 27,
        'Cylinders': 4,
        'Displacement': 151,
        'Horsepower': 90,
        'Weight_in_lbs': 2950,
        'Acceleration': 17.3,
        'Year': 378691200000,
        'Origin': 'USA'
      }];

    for (let i = 0; i < expectedJSON.length; i++) {
      row = [];
      for (let attr in expectedJSON[i]) {
        row.push(expectedJSON[i][attr]);
      }
      expectedData.push(row);
    }

    sortedDataWithoutId = sortDt.filter(x => x[1] === 27).map(x => x.slice(0,9));

    expect(isSorted(sortDt, (a, b) => a[1] - b[1])).toBe(true);
    expect(sortedDataWithoutId).toEqual(expectedData);
  });
});
