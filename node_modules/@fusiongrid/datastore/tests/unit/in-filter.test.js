import IN from '../../src/operators/in-filter';
import DataStore from '../../src';

let UNDEF;
const data = [
    ['Mike Bostock', 50, +new Date(2020, 1, 1)],
    ['Rich Harris', 45, +new Date(2020, 1, 1)],
    ['Mike Bostock', 50, +new Date(2020, 2, 2)],
    ['Michelle Obama', 55, +new Date(2020, 2, 5)],
    ['Michelle Stark', 35, +new Date(2020, 1, 1)],
    ['Arya Stark', 21, +new Date(2020, 5, 2)],
    ['Richie Rich', 21, +new Date(2020, 2, 2)],
    ['Richie Richardson', 45, +new Date(2020, 2, 5)],
    ['Ryan Harris', 35, +new Date(2020, 8, 5)],
    ['Harrison Ford', 35, +new Date(2020, 8, 5)],
    ['Michelle Stark', 35, +new Date(2020, 1, 1)],
    ['Barrack Obama', 58, +new Date(2020, 8, 5)],
    [2,100, +new Date(2020, 2, 9)],
    ['2',100, +new Date(2020, 2, 9)],
    [UNDEF,25, +new Date(2020, 2, 9)],
    [null, null, +new Date(2020, 1, 1)],
    ['A+b*', 25, +new Date(2020, 8, 5)],
    ['a+b*', 25, +new Date(2020, 8, 5)],
    ['*8b*', 25, +new Date(2020, 7, 8)],
  ], schema = [
    {
      name: 'Name'
    }, {
      name: 'Age',
      type: 'number'
    }, {
      name: 'Entry_Date',
      type: 'datetime'
    }
  ];

describe('Generic IN filter - ', () => {
  it('works with string type column', () => {
    let returnVal = IN('Name', ['Mike Bostock', 'Barrack Obama', 'Michelle Stark']),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(5);
    expect(returnArr[0][0]).toBe('Mike Bostock');
    expect(returnArr[1][0]).toBe('Mike Bostock');
    expect(returnArr[2][0]).toBe('Michelle Stark');
    expect(returnArr[3][0]).toBe('Michelle Stark');
    expect(returnArr[4][0]).toBe('Barrack Obama');
  });

  it('works with number type column', () => {
    let returnVal = IN('Age', [50, 55, 58]),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(4);
    expect(returnArr[0][0]).toBe('Mike Bostock');
    expect(returnArr[1][0]).toBe('Mike Bostock');
    expect(returnArr[2][0]).toBe('Michelle Obama');
    expect(returnArr[3][0]).toBe('Barrack Obama');
  });

  it('works with datetime type column', () => {
    let returnVal = IN('Entry_Date', [+new Date(2020, 8, 5), +new Date(2020, 2, 9)]),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(8);
    expect(returnArr[0][0]).toBe('Ryan Harris');
    expect(returnArr[7][0]).toBe('a+b*');
  });

  it('skips the extra values which are not present in data', () => {
    let returnVal = IN('Age', [50, 55, 38, 1, 'hell', UNDEF]),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(3);
    expect(returnArr[0][0]).toBe('Mike Bostock');
    expect(returnArr[1][0]).toBe('Mike Bostock');
    expect(returnArr[2][0]).toBe('Michelle Obama');
  });

  it('filters out special character as well', () => {
    let returnVal = IN('Name', ['a+b*', null, 2, UNDEF]),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(4);
    expect(returnArr[0][0]).toBe(2);
    expect(returnArr[1][0]).toBeUndefined();
    expect(returnArr[2][0]).toBe(null);
    expect(returnArr[3][0]).toBe('a+b*');
  });

  it('throws error if invalid parameter is passed', () => {
    let returnVal = IN('Name', 'Mike Bostock');
    expect(() => { return returnVal.fn(data, schema); }).toThrowError();
  });
});

describe('IN filter with indexing -', () => {
  it('works with number type column', () => {
    const dataTable = new DataStore().createDataTable(data, schema, 'table-1', { enableIndex: true, indexBy: 'Age' }),
      inOps = IN('Age', [100, 58, 21, 50]),
      resultDt = dataTable.query(inOps),
      result = resultDt.getData().data;

    expect(result.length).toBe(7);
  });

  it('works with string type column', () => {
    const dataTable = new DataStore().createDataTable(data.filter(row => row[0]), schema, 'table-1', { enableIndex: true, indexBy: 'Name' }),
      inOps = IN('Name', ['Mike Bostock', 'Arya Stark', '2', 2, 'Rich Harris', '*8b*', 'a+b*']),
      resultDt = dataTable.query(inOps),
      result = resultDt.getData().data,
      inOps2 = IN('Name', ['Arya Stark', 2, 'Rich Harris', '*8b*', 'a+b*', 'hello', 'hi', UNDEF]),
      resultDt2 = dataTable.query(inOps2),
      result2 = resultDt2.getData().data;

    expect(result.length).toBe(8);
    expect(result2.length).toBe(4);
  });

  xit('works with string type column when the original data has undefined and null', () => {
    const dataTable = new DataStore().createDataTable(data, schema, 'table-1', { enableIndex: true, indexBy: 'Name' }),
      inOps = IN('Name', ['Mike Bostock', 'Arya Stark', 2, 'Rich Harris', '*8b*', 'a+b*']),
      resultDt = dataTable.query(inOps),
      result = resultDt.getData().data,
      inOps2 = IN('Name', ['Arya Stark', 2, 'Rich Harris', '*8b*', 'a+b*', 'hello', 'hi', UNDEF]),
      resultDt2 = dataTable.query(inOps2),
      result2 = resultDt2.getData().data;

    expect(result.length).toBe(7);
    expect(result2.length).toBe(5);
  });

  it('works with non indexed type column as well when the table is indexed', () => {
    const dataTable = new DataStore().createDataTable(data, schema, 'table-1', { enableIndex: true, indexBy: 'Age' }),
      inOps = IN('Name', [2, 'Rich Harris', '*8b*', 'a+b*', null]),
      resultDt = dataTable.query(inOps),
      result = resultDt.getData().data;

    expect(result.length).toBe(4);
  });
});