import DataStore from '../../src/datastore';
import DataTable from '../../src/datatable';
import { schema, data5rows } from '../../sample/data/cars';
import salesData from '../../sample/data/salesTransaction';
import salesSchema from '../../sample/data/salesTransaction.schema';
import { indexColBetween, select, sort, groupBy, pivot } from '../../src/operators';
import { before, duration } from '../../src/time-utils/src/index';
import { DatetimeUnits } from '../../src/toolbox/src/index';
import { ROW_ID_COL_NAME } from '../../src/globals/defaults';

let data = data5rows,
  dataTable = new DataTable(null, data, schema),
  returnedData = dataTable.getData(), UNDEF;

describe('DataTable API - getData', () => {
  it('Valid data - schema should always be equal', () => {
    expect(returnedData.schema).toBe(schema);
  });

  it('Valid data - if selectedIndices is not provided and getData is called without argument then data should also be same', () => {
    expect(JSON.stringify(returnedData.data)).toBe(JSON.stringify(data));
  });

  let dataGetDataString = dataTable.getData('hello'),
    dataGetDataDecimal = dataTable.getData(2.9765),
    dataGetDataHigherEnd = dataTable.getData(0, 15),
    dataGetDataHigherEnd2 = dataTable.getData(3, 15),
    dataGetDataHigherEnd3 = dataTable.getData(2, 2.2341),
    dataGetDataHigherEnd4 = dataTable.getData(2, 'hello'),
    dataGetDataInvalid = dataTable.getData(0, 0),
    dataGetDataInvalid2 = dataTable.getData('hello', 'hello'),
    dataGetDataInvalid3 = dataTable.getData(-2, -2),
    dataGetData2 = dataTable.getData(2),
    data22 = dataTable.getData(2, 2),
    data2 = dataTable.getData(-2),
    data3 = dataTable.getData(2, -1);

  it('getData(\'hello\') - check first row first cell', () => {
    expect(dataGetDataString.data[0][0]).toBe('chevrolet chevelle malibu');
  });

  it('getData(2.9765) - check first row first cell', () => {
    expect(dataGetDataDecimal.data[0][0]).toBe('plymouth satellite');
  });

  it('getData(0,15) - check first row first cell', () => {
    expect(dataGetDataHigherEnd.data[dataGetDataHigherEnd.data.length - 1][0]).toBe('ford torino');
  });

  it('getData(3,15) - check first row first cell', () => {
    expect(dataGetDataHigherEnd2.data[dataGetDataHigherEnd2.data.length - 1][0]).toBe('ford torino');
  });

  it('getData(2, 2.2341) - check first row first cell', () => {
    expect(dataGetDataHigherEnd3.data[dataGetDataHigherEnd3.data.length - 1][0]).toBe('amc rebel sst');
  });

  it('getData(2, \'hello\') - check first row first cell', () => {
    expect(dataGetDataHigherEnd4.data[dataGetDataHigherEnd4.data.length - 1][0]).toBe('ford torino');
  });

  it('getData(0,0) - check length - should be 0', () => {
    expect(dataGetDataInvalid.data.length).toBe(0);
  });

  it('getData(0,0) - schema should be same', () => {
    expect(dataGetDataInvalid.schema).toBe(schema);
  });

  it('getData(hello,hello) - check length- should be 5', () => {
    expect(dataGetDataInvalid2.data.length).toBe(5);
  });

  it('getData(hello,hello) - schema should be same', () => {
    expect(dataGetDataInvalid2.schema).toBe(schema);
  });

  it('getData(-2,-2) - check length - should be 0', () => {
    expect(dataGetDataInvalid3.data.length).toBe(0);
  });

  it('getData(-2,-2) - schema should be same', () => {
    expect(dataGetDataInvalid3.schema).toBe(schema);
  });

  it('getData(2) - check first row first cell', () => {
    expect(dataGetData2.data[0][0]).toBe('plymouth satellite');
  });

  it('getData(2) - check last row first cell', () => {
    expect(dataGetData2.data[dataGetData2.data.length - 1][0]).toBe('ford torino');
  });

  it('getData(2,2) - schema should always be equal', () => {
    expect(data22.schema).toBe(schema);
  });

  it('getData(2,2) - check number of items', () => {
    expect(data22.data.length).toBe(2);
  });

  it('getData(2,2) - check first row first cell', () => {
    expect(data22.data[0][0]).toBe('plymouth satellite');
  });

  it('getData(2,2) - check last row first cell', () => {
    expect(data22.data[data22.data.length - 1][0]).toBe('amc rebel sst');
  });

  it('getData(-2) - should return last 2 elements - check first row first cell', () => {
    expect(data2.data[0][0]).toBe('amc rebel sst');
  });

  it('getData(-2) - should return last 2 elements - check first row first cell', () => {
    expect(data2.data[data2.data.length - 1][0]).toBe('ford torino');
  });

  it('getData(2, -1) - should return elements starting from  - check first row first cell', () => {
    expect(data3.data[0][0]).toBe('plymouth satellite');
  });

  it('getData(2, -1) - should return elements starting from  - check first row first cell', () => {
    expect(data3.data[data3.data.length - 1][0]).toBe('amc rebel sst');
  });
});

describe('DataTable API - count', () => {
  it('Count of default data - should be 5', () => {
    expect(dataTable.count()).toBe(5);
  });

  it('FDT_TC_062 - for null data count should be 0', () => {
    let DataTable4 = new DataTable(null, null, schema);
    expect(DataTable4.count()).toBe(0);
  });
});

describe('DataTable API - getSchema', () => {
  it('getSchema - check the reference - should be equal', () => {
    expect(dataTable.getSchema()).toBe(schema);
  });
});

describe('DataTable API - getDataStore', () => {
  it('getDataStore - check reference - should be equal', () => {
    let dataStore = new DataStore(data, schema),
      DataTableTable = dataStore.getDataTable();
    expect(DataTableTable.getDataStore()).toBe(dataStore);
  });
});

describe('DataTable API - indexOf', () => {
  it('indexOf - indexOf - Weight_in_lbs - should be 5', () => {
    expect(dataTable.indexOf('Weight_in_lbs')).toBe(5);
  });

  it('indexOf - indexOf - FusionCharts - should be -1', () => {
    expect(dataTable.indexOf('FusionCharts')).toBe(-1);
  });

  it('indexOf - indexOf with null or UNDEF argument - should return null', () => {
    expect(dataTable.indexOf()).toBe(null);
  });
});

describe('DataTable API - min', () => {
  it('min - with no arguments - should return null', () => {
    expect(dataTable.min()).toBeNull();
  });

  it('min - with wrong arguments - should return null', () => {
    expect(dataTable.min('hello')).toBeNull();
  });

  it('min - HorsePower - should return 130', () => {
    expect(dataTable.min('Horsepower')).toBe(130);
  });
});

describe('DataTable API - max', () => {
  it('max - with no arguments - should return null', () => {
    expect(dataTable.max()).toBeNull();
  });

  it('max - with wrong arguments - should return null', () => {
    expect(dataTable.max('hello')).toBeNull();
  });

  it('max - HorsePower - should return 130', () => {
    expect(dataTable.max('Horsepower')).toBe(165);
  });
});

describe('DataTable API - unique', () => {
  it('unique - with no arguments - should return empty array', () => {
    expect(dataTable.unique()).toEqual([]);
  });

  it('unique - with wrong arguments - should return empty array', () => {
    expect(dataTable.unique('hello')).toEqual([]);
  });

  it('unique - HorsePower - should return array with 4 elements', () => {
    expect(dataTable.unique('Horsepower')).toEqual([130, 165, 150, 140]);
  });

  it('unique - Cylinders - should return array with one element', () => {
    expect(dataTable.unique('Cylinders')).toEqual([8]);
  });
});

describe('DataTable API - extents', () => {
  it('extents - with no arguments - should return null', () => {
    expect(dataTable.extents()).toBeNull();
  });

  it('extents - with wrong arguments - should return null', () => {
    expect(dataTable.extents('hello')).toBeNull();
  });

  it('extents - HorsePower - should return 130 & 165', () => {
    expect(dataTable.extents('Horsepower')).toEqual({ min: 130, max: 165 });
  });
});

describe('DataTable id generation', () => {
  it('keeps the id same if id is provided in constructor', () => {
    let dataTableTest = new DataTable(null, data5rows, schema, null, null, null, 'test-id');

    expect(dataTableTest._id).toEqual('test-id');
  });

  it('generates an id if the table id is not provided', () => {
    let dataTableTest = new DataTable(null, data5rows, schema);

    expect(dataTableTest._id).toBeDefined();
  });

  it('generates an id for the child table when both parent and child table has no id', () => {
    let dataTableTest = new DataTable(null, data5rows, schema), dataTableTest2 = new DataTable(null, data5rows, schema, null, dataTable);

    expect(dataTableTest._id).toBeDefined();
    expect(dataTableTest2._id).toBeDefined();
  });

  it('generates an id for the child table when parent has id but child has no id', () => {
    let dataTableTest = new DataTable(null, data5rows, schema, null, null, null, 'test-id'),
      dataTableTest2 = new DataTable(null, data5rows, schema, null, dataTableTest),
      dataTableTest3 = new DataTable(null, data5rows, schema, null, dataTableTest);

    expect(dataTableTest._id).toEqual('test-id');
    expect(dataTableTest2._id).toEqual('test-id_1');
    expect(dataTableTest3._id).toEqual('test-id_2');
  });
});

describe('DataTable API - query', () => {
  let data4 = [].concat(data5rows, data5rows).sort((a, b) => { return a[1] - b[1]; }),
    dataStore = new DataStore(data4, schema, { enableIndex: false }),
    // let carsDt = new DataTable(null, data, schema);
    carsDt = dataStore.getDataTable(),
    opsDt = carsDt.query([indexColBetween(1, 16, 17), select(['Name', 'Miles_per_Gallon', 'Origin'])]),
    opsSel, opsDtData, opsSelData, incorrectOps, incorrectOpsData, incorrectOps2, incorrectOpsData2;

  opsDtData = opsDt.getData();

  it('Generates an id for the child table', () => {
    expect(opsDt._id).toBeDefined();
  });

  it('Small cars data - Miles_Per_Gallon between 16 & 17 - select 3 columns - number of data should be 4', () => {
    expect(opsDtData.data.length).toBe(4);
  });

  it('Small cars data - Miles_Per_Gallon between 16 & 17 - select 3 columns - schema should have 3 columns', () => {
    expect(opsDtData.schema.length).toBe(3);
  });

  it('Small cars data - Miles_Per_Gallon between 16 & 17 - select 3 columns - schema columns must match', () => {
    expect(opsDtData.schema[0].name).toBe('Name');
    expect(opsDtData.schema[1].name).toBe('Miles_per_Gallon');
    expect(opsDtData.schema[2].name).toBe('Origin');
  });

  opsSel = carsDt.query(select(['Name', 'Origin']));
  opsSelData = opsSel.getData();

  it('Small cars data - select 2 columns - schema should have 2 columns', () => {
    expect(opsSelData.schema.length).toBe(2);
  });

  it('Small cars data - select 2 columns - schema columns must match', () => {
    expect(opsSelData.schema[0].name).toBe('Name');
    expect(opsSelData.schema[1].name).toBe('Origin');
  });

  incorrectOps = carsDt.query([18, select(['Name', 'Origin']), 'Wrong_Name']);
  incorrectOpsData = incorrectOps.getData();

  it('Small cars data - select 2 columns with other wrong arguments - schema should have 2 columns', () => {
    expect(incorrectOpsData.schema.length).toBe(2);
  });

  it('Small cars data - select 2 columns with other wrong arguments - schema columns must match', () => {
    expect(incorrectOpsData.schema[0].name).toBe('Name');
    expect(incorrectOpsData.schema[1].name).toBe('Origin');
  });

  it('Small cars data - select 2 columns with other wrong arguments - number of data must be same', () => {
    expect(incorrectOpsData.data.length).toBe(data4.length);
  });

  incorrectOps2 = carsDt.query(['infinity', 0, new Date('1988-8-5')]);
  incorrectOpsData2 = incorrectOps2.getData();

  it('Incorrect query arguments - check schema length - should be equal to original length', () => {
    expect(incorrectOpsData2.schema.length).toBe(10);
  });
});

describe('DataTable API - addColumns', () => {
  let dataStore = new DataStore(data5rows, schema, { enableIndex: false }),
    carsDt = dataStore.getDataTable(),
    opsDtData, newColumns, newSchema,
    opsSelDT, opsSelData;

  it('FDT_TC_078, FDT_TC_079, FDT_TC_080, FDT_TC_087, FDT_TC_088 - Basic tests', () => {
    let durationMonth = duration(DatetimeUnits.Month);
    newColumns = [{
      name: 'Kms_per_Litre',
      type: 'number',
      calcFn: (row, columns) => {
        return row[columns.Miles_per_Gallon] * 0.354;
      }
    }, {
      name: 'Nickname',
      type: 'string',
      calcFn: (row, columns) => {
        return row[columns.Name].split(' ')[0];
      }
    }, {
      name: 'Previous Month',
      type: 'datetime',
      calcFn: (row, columns) => {
        return before(durationMonth, row[columns.Year]);
      },
      // format: '%Y-%m-%d',
      enableUTC: true
    }];

    carsDt.addColumns(...newColumns);

    newSchema = schema.slice(0);
    newColumns.forEach(row => {
      let dummyRow = {
        name: row.name,
        type: row.type,
        calcFn: row.calcFn
      };
      if (row.format) dummyRow.format = row.format;
      if (row.enableUTC) dummyRow.enableUTC = row.enableUTC;
      newSchema.push(dummyRow);
    });

    opsDtData = carsDt.getData();

    expect(opsDtData.schema.filter(x => x.name !== ROW_ID_COL_NAME)).toEqual(newSchema);
    expect(opsDtData.data[0][10]).toBe(opsDtData.data[0][1] * 0.354);
    expect(opsDtData.data[0][11]).toBe('chevrolet');
    expect(opsDtData.data[0][12]).toBe(-2678400000);
  });

  describe('argument other than object or array of objects should throw error', () => {
    it('array of objects should work', () => {
      let newColumn = {
        name: 'Kms_per_Litre - 1',
        type: 'number',
        calcFn: (row, columns) => {
          return row[columns.Miles_per_Gallon] * 0.354;
        }
      };
      newColumns = [newColumn];

      carsDt.addColumns(...newColumns);
      opsDtData = carsDt.getData();

      expect(opsDtData).toBeDefined();
    });
    it('object should work', () => {
      let newColumn = {
        name: 'Kms_per_Litre - 2',
        type: 'number',
        calcFn: (row, columns) => {
          return row[columns.Miles_per_Gallon] * 0.354;
        }
      };

      carsDt.addColumns(newColumn);
      opsDtData = carsDt.getData();

      expect(opsDtData).toBeDefined();
    });
    it('string shouldn\'t work', () => {
      expect(() => { carsDt.addColumns('wrong'); }).toThrow();
    });
    it('number shouldn\'t work', () => {
      expect(() => { carsDt.addColumns(1); }).toThrow();
    });
    it('array of strings shouldn\'t work', () => {
      expect(() => { carsDt.addColumns(['wrong', 'incorrect']); }).toThrow();
    });
    it('array of numbers shouldn\'t work', () => {
      expect(() => { carsDt.addColumns([1, 2, 3]); }).toThrow();
    });
    it('array of arrays shouldn\'t work', () => {
      newColumns = [{
        name: 'Kms_per_Litre - 2',
        type: 'number',
        calcFn: (row, columns) => {
          return row[columns.Miles_per_Gallon] * 0.354;
        }
      }];

      expect(() => { carsDt.addColumns([newColumns]); }).toThrow();
    });
  });

  it('FDT_TC_081 - name cannot be blank', () => {
    newColumns = [{
      type: 'number',
      calcFn: (row, columns) => {
        return row[columns.Miles_per_Gallon] * 0.354;
      }
    }];

    expect(() => { carsDt.addColumns(...newColumns); }).toThrow();
  });

  it('FDT_TC_082, FDT_TC_083 - name must be unique', () => {
    newColumns = [{
      name: 'Miles_per_Gallon',
      type: 'number',
      calcFn: (row, columns) => {
        return row[columns.Miles_per_Gallon];
      }
    },
    {
      name: 'Miles_per_Gallon',
      type: 'number',
      calcFn: (row, columns) => {
        return row[columns.Miles_per_Gallon];
      }
    }];

    carsDt.addColumns(...newColumns);

    opsDtData = carsDt.getData();

    expect(opsDtData.schema[opsDtData.schema.length - 2].name).toBe('Miles_per_Gallon 1');
    expect(opsDtData.schema[opsDtData.schema.length - 1].name).toBe('Miles_per_Gallon 2');
  });

  it('FDT_TC_085 - missing type should use string', () => {
    newColumns = [{
      name: 'FDT_TC_085 - Some field',
      calcFn: (row, columns) => {
        return row[columns.Name];
      }
    }];

    carsDt.addColumns(...newColumns);

    opsDtData = carsDt.getData();

    expect(opsDtData.schema[opsDtData.schema.length - 1].type).toBe('string');
  });

  it('FDT_TC_086 - incorrect type should use string', () => {
    newColumns = [{
      name: 'FDT_TC_086 - Some field',
      type: 'wrong',
      calcFn: (row, columns) => {
        return row[columns.Name];
      }
    }];

    carsDt.addColumns(...newColumns);

    opsDtData = carsDt.getData();

    expect(opsDtData.schema[opsDtData.schema.length - 1].type).toBe('string');
  });

  it('calcFn should be a function', () => {
    newColumns = [{
      name: 'calcFn - Some field',
      type: 'number',
      calcFn: 'abc'
    }];

    expect(() => { carsDt.addColumns(...newColumns); }).toThrow();
  });

  it('FDT_TC_089 - missing calcFn should change schema, but keep empty data', () => {
    newColumns = [{
      name: 'FDT_TC_089 - Some field',
      type: 'string'
    }];

    carsDt.addColumns(...newColumns);

    opsDtData = carsDt.getData();

    expect(opsDtData.schema[opsDtData.schema.length - 1]).toEqual(newColumns[0]);
    expect(opsDtData.data[0][opsDtData.schema.length - 1]).toBeUndefined();
  });

  it('FDT_TC_090 - when value doesn\'t match type - number type results NaN', () => {
    newColumns = [{
      name: 'FDT_TC_090 - Some field',
      type: 'number',
      calcFn: () => {
        return 'text';
      }
    }];

    carsDt.addColumns(...newColumns);

    opsDtData = carsDt.getData();

    expect(opsDtData.schema[opsDtData.schema.length - 1]).toEqual(newColumns[0]);
    expect(opsDtData.data[0][opsDtData.schema.length - 1]).toBe(null);
  });

  it('FDT_TC_093 - does not propagate across related DTs', () => {
    newColumns = [{
      name: 'FDT_TC_093 - Kms_per_Litre',
      type: 'number',
      calcFn: (row, columns) => {
        return row[columns.Miles_per_Gallon] * 0.354;
      }
    }];

    opsSelDT = carsDt.query(select(['Name', 'Origin']));

    carsDt.addColumns(...newColumns);
    opsDtData = carsDt.getData();
    expect(opsDtData.schema[opsDtData.schema.length - 1]).toEqual(newColumns[0]);
    expect(opsDtData.data[0][opsDtData.schema.length - 1]).toBe(opsDtData.data[0][1] * 0.354);

    opsSelData = opsSelDT.getData();
    // new column hasn't been added to end of derived DT's schema
    expect(opsSelData.schema[opsSelData.schema.length - 1]).not.toEqual(newColumns[0]);
    // derived DT's schema and data is still of length 2
    expect(opsSelData.schema.length).toBe(2);
  });

  describe('\'updated\' event', () => {
    it('FDT_TC_106 - single column addition triggers updated event', () => {
      let newColumn = {
          name: 'FDT_TC_106',
          type: 'number',
          calcFn: (row, columns) => {
            return row[columns.Miles_per_Gallon] * 0.354;
          }
        },
        fnRunFlag = false,
        dummyFn = () => {
          fnRunFlag = true;
        };

      carsDt.on('updated', dummyFn);

      newColumns = [newColumn];
      carsDt.addColumns(...newColumns);

      expect(fnRunFlag).toBe(true);
    });
    it('FDT_TC_107 - multiple column addition triggers updated event', () => {
      let multipleNewColumns = [{
          name: 'Kms_per_Litre - FDT_TC_107',
          type: 'number',
          calcFn: (row, columns) => {
            return row[columns.Miles_per_Gallon] * 0.354;
          }
        }, {
          name: 'Nickname - FDT_TC_107',
          type: 'string',
          calcFn: (row, columns) => {
            return row[columns.Name].split(' ')[0];
          }
        }],
        fnRunFlag = false,
        dummyFn = () => {
          fnRunFlag = true;
        };

      carsDt.on('updated', dummyFn);

      carsDt.addColumns(...multipleNewColumns);

      expect(fnRunFlag).toBe(true);
    });
    describe('FDT_TC_110 - other functions should not trigger updated event', () => {
      it('getDate()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.getData();

        expect(fnRunFlag).toBe(false);
      });
      it('count()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.count();

        expect(fnRunFlag).toBe(false);
      });
      it('getSchema()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.getSchema();

        expect(fnRunFlag).toBe(false);
      });
      it('getDataStore()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.getDataStore();

        expect(fnRunFlag).toBe(false);
      });
      it('indexOf()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.indexOf('Name');

        expect(fnRunFlag).toBe(false);
      });
      it('min()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.min('Miles_per_Gallon');

        expect(fnRunFlag).toBe(false);
      });
      it('max()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.max('Miles_per_Gallon');

        expect(fnRunFlag).toBe(false);
      });
      it('unique()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.unique('Name');

        expect(fnRunFlag).toBe(false);
      });
      it('extents()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.extents('Miles_per_Gallon');

        expect(fnRunFlag).toBe(false);
      });
      it('query()', () => {
        let fnRunFlag = false,
          dummyFn = () => {
            fnRunFlag = true;
          };

        carsDt.on('updated', dummyFn);

        carsDt.query([indexColBetween(1, 16, 17), select(['Name', 'Miles_per_Gallon', 'Origin'])]);

        expect(fnRunFlag).toBe(false);
      });
    });
    it('FDT_TC_111 - sibling datatables should not trigger updated event', () => {
      let newColumn = {
          name: 'FDT_TC_106',
          type: 'number',
          calcFn: (row, columns) => {
            return row[columns.Miles_per_Gallon] * 0.354;
          }
        },
        fnRunCount = 0,
        dummyFn = () => {
          ++fnRunCount;
        };

      carsDt.query([indexColBetween(1, 16, 17)]);

      carsDt.on('updated', dummyFn);

      newColumns = [newColumn];
      carsDt.addColumns(...newColumns);

      expect(fnRunCount).toBe(1);
    });
  });
});

jest.useFakeTimers();
describe('DataTable API - on', () => {
  it('FDT_TC_101 - 1 - handler is bound to an event through on', () => {
    var fnRunFlag = false,
      dummyFn = () => {
        fnRunFlag = true;
      };

    dataTable.on('FDT_TC_101 - 1', dummyFn);

    setTimeout(() => {
      dataTable._trigger('FDT_TC_101 - 1');
    }, 200);

    jest.advanceTimersByTime(500);
    expect(fnRunFlag).toBe(true);
  });

  it('FDT_TC_101 - 2 - multiple handlers are bound to an event through on', () => {
    var fn1RunFlag = false, fn2RunFlag = false,
      dummyFn1 = () => {
        fn1RunFlag = true;
      },
      dummyFn2 = () => {
        fn2RunFlag = true;
      };

    dataTable.on('FDT_TC_101 - 2', [dummyFn1, dummyFn2]);

    setTimeout(() => {
      dataTable._trigger('FDT_TC_101 - 2');
    }, 200);

    jest.advanceTimersByTime(500);
    expect(fn1RunFlag).toBe(true);
    expect(fn2RunFlag).toBe(true);
  });

  it('FDT_TC_101 - 3 - multiple handlers bound to an event execute in order', () => {
    var arrFlag = [],
      dummyFn1 = () => {
        arrFlag.push('dummyFn1');
      },
      dummyFn2 = () => {
        arrFlag.push('dummyFn2');
      };

    dataTable.on('FDT_TC_101 - 3', [dummyFn1, dummyFn2]);

    setTimeout(() => {
      dataTable._trigger('FDT_TC_101 - 3');
    }, 200);

    jest.advanceTimersByTime(500);
    expect(arrFlag.length).toBe(2);
    expect(arrFlag).toEqual(['dummyFn1', 'dummyFn2']);
  });

  it('FDT_TC_101 - 4 - empty event name throws error', () => {
    var dummyFn = () => {
      return true;
    };

    expect(() => { dataTable.on('', dummyFn); }).toThrow();
    expect(() => { dataTable.on(dummyFn); }).toThrow();
  });

  it('FDT_TC_101 - 5 - empty handler throws error', () => {
    expect(() => { dataTable.on('FDT_TC_101 - 5'); }).toThrow();
  });
});

describe('DataTable API - off', () => {
  it('FDT_TC_036 - only given handler is removed', () => {
    var fn1RunCount = 0, fn2RunCount = 0,
      dummyFn1 = () => {
        fn1RunCount++;
      },
      dummyFn2 = () => {
        fn2RunCount++;
      };

    dataTable.on('FDT_TC_036', [dummyFn1, dummyFn2]);

    // trigger the event
    setTimeout(() => {
      dataTable._trigger('FDT_TC_036');
    }, 200);

    jest.advanceTimersByTime(200);
    expect(fn1RunCount).toBe(1);
    expect(fn2RunCount).toBe(1);

    // remove a handler
    setTimeout(() => {
      dataTable.off('FDT_TC_036', dummyFn1);
    }, 300);

    // trigger the event again
    setTimeout(() => {
      dataTable._trigger('FDT_TC_036');
    }, 400);

    jest.advanceTimersByTime(400);
    expect(fn1RunCount).toBe(1);
    expect(fn2RunCount).toBe(2);
  });

  it('multiple handlers can be removed by providing an array', () => {
    var fn1RunCount = 0, fn2RunCount = 0,
      dummyFn1 = () => {
        fn1RunCount++;
      },
      dummyFn2 = () => {
        fn2RunCount++;
      };

    dataTable.on('FDT_TC_031x', [dummyFn1, dummyFn2]);

    // trigger the event
    setTimeout(() => {
      dataTable._trigger('FDT_TC_031x');
    }, 200);

    jest.advanceTimersByTime(200);
    expect(fn1RunCount).toBe(1);
    expect(fn2RunCount).toBe(1);

    // remove a handler
    setTimeout(() => {
      dataTable.off('FDT_TC_031x', [dummyFn1, dummyFn2]);
    }, 300);

    // trigger the event again
    setTimeout(() => {
      dataTable._trigger('FDT_TC_031x');
    }, 400);

    jest.advanceTimersByTime(400);
    expect(fn1RunCount).toBe(1);
    expect(fn2RunCount).toBe(1);
  });

  it('FDT_TC_038 - missing handler removes all from event', () => {
    var fn1RunCount = 0, fn2RunCount = 0,
      dummyFn1 = () => {
        fn1RunCount++;
      },
      dummyFn2 = () => {
        fn2RunCount++;
      };

    dataTable.on('FDT_TC_038', [dummyFn1, dummyFn2]);

    // trigger the event
    setTimeout(() => {
      dataTable._trigger('FDT_TC_038');
    }, 200);

    jest.advanceTimersByTime(200);
    expect(fn1RunCount).toBe(1);
    expect(fn2RunCount).toBe(1);

    // remove a handler
    setTimeout(() => {
      dataTable.off('FDT_TC_038');
    }, 300);

    // trigger the event again
    setTimeout(() => {
      dataTable._trigger('FDT_TC_038');
    }, 400);

    jest.advanceTimersByTime(400);
    expect(fn1RunCount).toBe(1);
    expect(fn2RunCount).toBe(1);
  });

  it('FDT_TC_034 - empty event name throws error', () => {
    var dummyFn = () => {
      return true;
    };

    expect(() => { dataTable.off('', dummyFn); }).toThrow();
    expect(() => { dataTable.off(dummyFn); }).toThrow();
  });
});

describe('DataTable API - trigger', () => {
  it('FDT_TC_040 - empty eventname throws error', () => {
    var dummyFn = () => {
      return true;
    };

    dataTable.on('FDT_TC_031', dummyFn);

    expect(() => { dataTable._trigger(''); }).toThrow();
    expect(() => { dataTable._trigger([]); }).toThrow();
  });
});

describe('DataTable API - getMinDiff', () => {
  let salesDS = new DataStore(salesData, salesSchema, { enableIndex: true, indexBy: 'Time' }),
    salesDT = salesDS.getDataTable();
  it('Method will return minimum difference between datetimes', () => {
    let minDiff = salesDT.getMinDiff('Time');

    expect(minDiff).toBe(0);
  });

  it('Incorrect column name returns null', () => {
    let minDiff = salesDT.getMinDiff('Time wrong');

    expect(minDiff).toBe(null);
  });
});

describe('DataTable API - dispose', () => {
  let dataStore = new DataStore(data5rows, schema, { enableIndex: false }),
    carsDt, opsDt,
    disposedState = {
      disposed: true
    };

  it('FDT_TC_103 - datatable references and the datatable are removed', () => {
    carsDt = dataStore.getDataTable();
    opsDt = carsDt.query([indexColBetween(1, 16, 17), select(['Name', 'Miles_per_Gallon', 'Origin'])]);

    opsDt.getData();

    expect(opsDt._dataStore).toBeDefined();
    expect(opsDt._parentTable).toBeDefined();
    expect(opsDt._children).toBeDefined();
    expect(opsDt._opsFunnel).toBeDefined();
    expect(opsDt._data).toBeDefined();
    expect(opsDt._schema).toBeDefined();
    expect(opsDt._config).toBeDefined();
    expect(opsDt._result).toBeDefined();

    opsDt.dispose();
    // all references should be null
    expect(opsDt._dataStore).toBeUndefined();
    expect(opsDt._parentTable).toBeUndefined();
    expect(opsDt._children).toBeUndefined();
    expect(opsDt._opsFunnel).toBeUndefined();
    expect(opsDt._data).toBeUndefined();
    expect(opsDt._schema).toBeUndefined();
    expect(opsDt._config).toBeUndefined();
    expect(opsDt._result).toBeUndefined();
    expect(JSON.stringify(opsDt)).toEqual(JSON.stringify(disposedState));
  });

  it('FDT_TC_104 - parent datatable and datasource are not affected', () => {
    carsDt = dataStore.getDataTable();
    opsDt = carsDt.query([indexColBetween(1, 16, 17), select(['Name', 'Miles_per_Gallon', 'Origin'])]);

    carsDt.getData();
    opsDt.getData();

    opsDt.dispose();

    // main ds has no change
    expect(dataStore).toBeDefined();
    expect(dataStore.dataTables).toBeDefined();
    expect(dataStore._defaultDataTable).toBeDefined();
    expect(dataStore).not.toEqual({});
    // parent dt has no change
    expect(carsDt._dataStore).toBeDefined();
    expect(carsDt._children).toBeDefined();
    expect(carsDt._data).toBeDefined();
    expect(carsDt._schema).toBeDefined();
    expect(carsDt._config).toBeDefined();
    expect(carsDt._result).toBeDefined();
    expect(carsDt).not.toEqual({});
    // in current dt all references should be null
    expect(opsDt._dataStore).toBeUndefined();
    expect(opsDt._parentTable).toBeUndefined();
    expect(opsDt._children).toBeUndefined();
    expect(opsDt._opsFunnel).toBeUndefined();
    expect(opsDt._data).toBeUndefined();
    expect(opsDt._schema).toBeUndefined();
    expect(opsDt._config).toBeUndefined();
    expect(opsDt._result).toBeUndefined();
    expect(JSON.stringify(opsDt)).toEqual(JSON.stringify(disposedState));
  });

  it('FDT_TC_104 - child datatable is removed', () => {
    carsDt = dataStore.getDataTable();
    opsDt = carsDt.query([indexColBetween(1, 16, 17), select(['Name', 'Miles_per_Gallon', 'Origin'])]);

    carsDt.getData();
    opsDt.getData();

    expect(carsDt._dataStore).toBeDefined();
    expect(carsDt._children).toBeDefined();
    expect(carsDt._data).toBeDefined();
    expect(carsDt._schema).toBeDefined();
    expect(carsDt._config).toBeDefined();
    expect(carsDt._result).toBeDefined();

    carsDt.dispose();

    // in current dt all references should be null
    expect(carsDt._dataStore).toBeUndefined();
    expect(carsDt._children).toBeUndefined();
    expect(carsDt._data).toBeUndefined();
    expect(carsDt._schema).toBeUndefined();
    expect(carsDt._config).toBeUndefined();
    expect(carsDt._result).toBeUndefined();
    expect(JSON.stringify(carsDt)).toEqual(JSON.stringify(disposedState));
    // child dt is also removed
    expect(JSON.stringify(opsDt)).toEqual(JSON.stringify(disposedState));
  });

  it('FDT_TC_112 - disposed event is triggered', () => {
    var fnRunFlag = false,
      dummyFn = () => {
        fnRunFlag = true;
      };

    carsDt = dataStore.getDataTable();
    carsDt.on('disposed', dummyFn);

    carsDt.dispose();

    expect(fnRunFlag).toBe(true);
  });

  describe('FDT_TC_113 - on method with disposed event', () => {
    it('FDT_TC_031 - handler is bound to an event through on', () => {
      var fnRunFlag = false,
        dummyFn = () => {
          fnRunFlag = true;
        };

      carsDt = dataStore.getDataTable();
      carsDt.on('disposed', dummyFn);

      carsDt.dispose();

      expect(fnRunFlag).toBe(true);
    });

    it('FDT_TC_031 - multiple handlers are bound to an event through on', () => {
      var fn1RunFlag = false, fn2RunFlag = false,
        dummyFn1 = () => {
          fn1RunFlag = true;
        },
        dummyFn2 = () => {
          fn2RunFlag = true;
        };

      carsDt = dataStore.getDataTable();
      carsDt.on('disposed', [dummyFn1, dummyFn2]);

      carsDt.dispose();

      expect(fn1RunFlag).toBe(true);
      expect(fn2RunFlag).toBe(true);
    });

    it('FDT_TC_033 - multiple handlers bound to an event execute in order', () => {
      var arrFlag = [],
        dummyFn1 = () => {
          arrFlag.push('dummyFn1');
        },
        dummyFn2 = () => {
          arrFlag.push('dummyFn2');
        };

      carsDt = dataStore.getDataTable();
      carsDt.on('disposed', [dummyFn1, dummyFn2]);

      carsDt.dispose();

      expect(arrFlag.length).toBe(2);
      expect(arrFlag).toEqual(['dummyFn1', 'dummyFn2']);
    });

    it('FDT_TC_034 - empty event name throws error', () => {
      var dummyFn = () => {
        return true;
      };

      carsDt = dataStore.getDataTable();

      expect(() => { carsDt.on('', dummyFn); }).toThrow();
      expect(() => { carsDt.on(dummyFn); }).toThrow();

      carsDt.dispose();
    });

    it('FDT_TC_035 - empty handler throws error', () => {
      carsDt = dataStore.getDataTable();
      expect(() => { carsDt.on('disposed'); }).toThrow();
    });
  });

  describe('FDT_TC_048 - off method with disposed event', () => {
    it('multiple handlers can be removed by providing an array', () => {
      var fn1RunCount = 0, fn2RunCount = 0,
        dummyFn1 = () => {
          fn1RunCount++;
        },
        dummyFn2 = () => {
          fn2RunCount++;
        };

      carsDt = dataStore.getDataTable();
      carsDt.on('disposed', [dummyFn1, dummyFn2]);

      carsDt.dispose();

      expect(fn1RunCount).toBe(1);
      expect(fn2RunCount).toBe(1);

      // remove a handler
      carsDt.off('disposed', [dummyFn1, dummyFn2]);

      carsDt.dispose();

      expect(fn1RunCount).toBe(1);
      expect(fn2RunCount).toBe(1);
    });

    it('FDT_TC_038 - missing handler removes all from event', () => {
      var fn1RunCount = 0, fn2RunCount = 0,
        dummyFn1 = () => {
          fn1RunCount++;
        },
        dummyFn2 = () => {
          fn2RunCount++;
        };

      carsDt = dataStore.getDataTable();
      carsDt.on('disposed', [dummyFn1, dummyFn2]);

      carsDt.dispose();

      expect(fn1RunCount).toBe(1);
      expect(fn2RunCount).toBe(1);

      // remove a handler
      carsDt.off('disposed');

      carsDt.dispose();

      expect(fn1RunCount).toBe(1);
      expect(fn2RunCount).toBe(1);
    });

    it('FDT_TC_034 - empty event name throws error', () => {
      var dummyFn = () => {
        return true;
      };

      carsDt = dataStore.getDataTable();

      expect(() => { carsDt.off('', dummyFn); }).toThrow();
      expect(() => { carsDt.off(dummyFn); }).toThrow();

      carsDt.dispose();
    });
  });
});

describe('Edge cases', () => {
  describe('Sort operation should change indexBy in config', () => {
    var dataArr = [
        ['Mike', 10, 12],
        ['John', 11, 18],
        ['Alice', 14, 12],
        ['John', 13, 10],
        ['Alice', 12, 16],
        ['John', 17, 11],
        ['John', 15, 12],
        ['Alice', 13, 10],
        ['Mike', 11, 7],
        ['Alice', 13, 11]
      ], schemaArr = [
        {
          name: 'Name',
          type: 'string'
        },
        {
          name: 'Age',
          type: 'number'
        },
        {
          name: 'Class',
          type: 'number'
        }
      ], DS, DT, ageSorted, classStudents;

    it('With DataTable indexBy set, sorting changes it', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort({ column: 'Age' }));
      ageSorted.getData();

      expect(ageSorted._result.config.indexBy).toBe('Age');
    });

    it('With DataTable indexBy set, sorting changes it, but UTC configuration is not changed', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class', enableUTC: true });
      ageSorted = DT.query(sort({ column: 'Age' }));
      ageSorted.getData();

      expect(ageSorted._result.config.indexBy).toBe('Age');
      expect(ageSorted._result.config.enableUTC).toBe(true);
    });

    it('With DataTable indexBy set, descending order sorting does not apply any indexing on newly created data table', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort({ column: 'Age', order: 'desc' }));
      ageSorted.getData();

      expect(ageSorted._result.config.indexBy).toBeUndefined();
    });

    it('With DataTable indexBy set, sorting using function does apply any indexing on newly created data table', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort((a, b) => a - b ));
      ageSorted.getData();

      expect(ageSorted._result.config.indexBy).toBeUndefined();
    });

    it('With DataTable indexBy set to "X", sort on "Y", then group on "X"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort({ column: 'Age' }));
      classStudents = ageSorted.query(groupBy([
        {
          column: 'Class'
        }
      ], [
        {
          column: 'Name',
          operation: 'count'
        }
      ]));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBeUndefined();
      expect(classStudents._result.config.enableIndex).toBe(false);
      expect(classStudents._result.data.length).toBe(6);
      expect(classStudents._result.data).toEqual([[12, 3], [7, 1], [18, 1], [16, 1], [10, 2], [11, 2]]);
    });

    it('With DataTable indexBy set to "X", sort on "Y", then group on "Y"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort({ column: 'Age' }));
      classStudents = ageSorted.query(groupBy([
        {
          column: 'Age'
        }
      ], [
        {
          column: 'Name',
          operation: 'count'
        }
      ]));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBe('Age');
      expect(classStudents._result.config.enableIndex).toBe(true);
      expect(classStudents._result.data.length).toBe(7);
      expect(classStudents._result.data).toEqual([[10, 1], [11, 2], [12, 1], [13, 3], [14, 1], [15, 1], [17, 1]]);
    });

    it('With DataTable indexBy set to "X", sort on "Y", then pivot with grouping on "X"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort({ column: 'Age' }));
      classStudents = ageSorted.query(pivot([
        {
          column: 'Class'
        }
      ], 'Name', [
        {
          column: 'Name',
          operation: 'count'
        }
      ]));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBeUndefined();
      expect(classStudents._result.config.enableIndex).toBe(false);
      expect(classStudents._result.data.length).toBe(6);
      expect(classStudents._result.data).toEqual([[12, 1, 1, 1], [7, UNDEF, UNDEF, 1], [18, UNDEF, 1, UNDEF], [16, 1, UNDEF, UNDEF], [10, 1, 1, UNDEF], [11, 1, 1, UNDEF]]);
    });

    it('With DataTable indexBy set to "X", sort on "Y", then pivot with grouping on "Y"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort({ column: 'Age' }));
      classStudents = ageSorted.query(pivot([
        {
          column: 'Age'
        }
      ], 'Name', [
        {
          column: 'Name',
          operation: 'count'
        }
      ]));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBe('Age');
      expect(classStudents._result.config.enableIndex).toBe(true);
      expect(classStudents._result.data.length).toBe(7);
      expect(classStudents._result.data).toEqual([[10, UNDEF, UNDEF, 1], [11, UNDEF, 1, 1], [12, 1], [13, 2, 1], [14, 1], [15, UNDEF, 1], [17, UNDEF, 1]]);
    });

    it('With DataTable indexBy set to "X", multi sort on "Y", "Z", then group on "X"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort([{ column: 'Name' }, { column: 'Age' }]));
      classStudents = ageSorted.query(groupBy(
        [{ column: 'Class' }],
        [{ column: 'Name', operation: 'count' }]
      ));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBeUndefined();
      expect(classStudents._result.config.enableIndex).toBe(false);
      expect(classStudents._result.data.length).toBe(6);
      expect(classStudents._result.data).toEqual([[16, 1], [10, 2], [11, 2], [12, 3], [18, 1], [7, 1]]);
    });

    it('With DataTable indexBy set to "X", multi sort on "Y", "Z", then group on "Y"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort([{ column: 'Name' }, { column: 'Age' }]));
      classStudents = ageSorted.query(groupBy(
        [{ column: 'Name' }],
        [{ column: 'Name', operation: 'count' }]
      ));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBe('Name');
      expect(classStudents._result.config.enableIndex).toBe(true);
      expect(classStudents._result.data.length).toBe(3);
      expect(classStudents._result.data).toEqual([['Alice', 4], ['John', 4], ['Mike', 2]]);
    });

    it('With DataTable indexBy set to "X", multi sort on "Y", "Z", then group on "Z"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort([{ column: 'Name' }, { column: 'Age' }]));
      classStudents = ageSorted.query(groupBy(
        [{ column: 'Age' }],
        [{ column: 'Name', operation: 'count' }]
      ));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBeUndefined();
      expect(classStudents._result.config.enableIndex).toBe(false);
      expect(classStudents._result.data.length).toBe(7);
      expect(classStudents._result.data).toEqual([[12, 1], [13, 3], [14, 1], [11, 2], [15, 1], [17, 1], [10, 1]]);
    });

    it('With DataTable indexBy set to "X", multi sort on "Y", "Z", then pivot with grouping on "X"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Class' });
      ageSorted = DT.query(sort([{ column: 'Name' }, { column: 'Age' }]));
      classStudents = ageSorted.query(pivot(
        [{ column: 'Class' }],
        'Name',
        [{ column: 'Name', operation: 'count' }]
      ));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBeUndefined();
      expect(classStudents._result.config.enableIndex).toBe(false);
      expect(classStudents._result.data.length).toBe(6);
      expect(classStudents._result.data).toEqual([[16, 1, UNDEF, UNDEF], [10, 1, 1, UNDEF], [11, 1, 1, UNDEF], [12, 1, 1, 1], [18, UNDEF, 1, UNDEF], [7, UNDEF, UNDEF, 1]]);
    });

    it('With DataTable indexBy set to "X", multi sort on "Y", "Z", then pivot with grouping on "Y"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Name' });
      ageSorted = DT.query(sort([{ column: 'Class' }, { column: 'Age' }]));
      classStudents = ageSorted.query(pivot(
        [{ column: 'Class' }],
        'Name',
        [{ column: 'Name', operation: 'count' }]
      ));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBe('Class');
      expect(classStudents._result.config.enableIndex).toBe(true);
      expect(classStudents._result.data.length).toBe(6);
      expect(classStudents._result.data).toEqual([[7, UNDEF, UNDEF, 1], [10, 1, 1], [11, 1, 1], [12, 1, 1, 1], [16, 1], [18, UNDEF, 1]]);
    });

    it('With DataTable indexBy set to "X", multi sort on "Y", "Z", then pivot with grouping on "Z"', () => {
      DS = new DataStore();
      DT = DS.createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Name' });
      ageSorted = DT.query(sort([{ column: 'Class' }, { column: 'Age' }]));
      classStudents = ageSorted.query(pivot(
        [{ column: 'Age' }],
        'Name',
        [{ column: 'Name', operation: 'count' }]
      ));
      classStudents.getData();

      expect(classStudents._result.config.indexBy).toBeUndefined();
      expect(classStudents._result.config.enableIndex).toBe(false);
      expect(classStudents._result.data.length).toBe(7);
      expect(classStudents._result.data).toEqual([[11, UNDEF, 1, 1], [13, 2, 1, UNDEF], [17, UNDEF, 1, UNDEF], [10, UNDEF, UNDEF, 1], [14, 1, UNDEF, UNDEF], [15, UNDEF, 1, UNDEF], [12, 1, UNDEF, UNDEF]]);
    });
  });
});
