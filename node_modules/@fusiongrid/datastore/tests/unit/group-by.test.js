import DataStore from '../../src/datastore';
import { DatetimeUnits, Weekdays } from '../../src/toolbox/src/index';
import cityBikesData from '../../sample/data/cityBikes';
import cityBikesSchema from '../../sample/data/cityBikes.schema';
import salesTransactionData from '../../sample/data/salesTransaction';
import salesTransactionSchema from '../../sample/data/salesTransaction.schema';
import groupBy from '../../src/operators/group-by';

let UNDEF;

describe('test groupBy', () => {
  var cityBikesDS = new DataStore(
      cityBikesData,
      cityBikesSchema,
      {
        enableIndex: false,
        indexBy: 'starttime'
      }
    ),
    cityBikesDT = cityBikesDS.getDataTable(),
    salesTransactionDS = new DataStore(
      salesTransactionData,
      salesTransactionSchema,
      {
        enableIndex: false,
        indexBy: 'Time'
      }
    ),
    salesTransactionDT = salesTransactionDS.getDataTable(),
    groupByOps,
    result;

  it('groupBy takes 2 arguments', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );
    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result).toBeDefined();
  });

  it('column in argument doesn\'t belong in dataview', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime X',
        timeUnit: DatetimeUnits.Hour
      }],
      [{
        column: 'tripduration X',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );
    expect(() => groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config)).toThrow();
  });

  it('column is missing', () => {
    groupByOps = groupBy(
      [{
        timeUnit: DatetimeUnits.Hour
      }],
      [{
        column: 'tripduration X',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );
    expect(() => groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config)).toThrow();
  });

  describe('outputAs is used in group config', () => {
    it('single sorted column grouping', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age' }],
        dataArr = [
          ['John', 13],
          ['Luna', 17],
          ['Sam', 5],
          ['John', 19],
          ['Sam', 14]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Name' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name',
          outputAs: 'Student Name'
        }],
        [{
          column: 'Age',
          operation: 'count'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[0].name).toBe('Student Name');
    });

    it('single unsorted column grouping', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age' }],
        dataArr = [
          ['John', 13],
          ['Luna', 17],
          ['Sam', 5],
          ['John', 19],
          ['Sam', 14]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Age' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name',
          outputAs: 'Student Name'
        }],
        [{
          column: 'Age',
          operation: 'count'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[0].name).toBe('Student Name');
    });

    it('multiple sorted column grouping', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age' }, { name: 'Class' }],
        dataArr = [
          ['John', 13, 7],
          ['Luna', 17, 11],
          ['Sam', 5, 2],
          ['John', 19, 11],
          ['Sam', 14, 7]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Name' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name',
          outputAs: 'Student Name'
        }, {
          column: 'Class',
          outputAs: 'Class Name'
        }],
        [{
          column: 'Age',
          operation: 'count'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[0].name).toBe('Student Name');
      expect(result.schema[1].name).toBe('Class Name');
    });

    it('multiple unsorted column grouping', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age' }, { name: 'Class' }],
        dataArr = [
          ['John', 13, 7],
          ['Luna', 17, 11],
          ['Sam', 5, 2],
          ['John', 19, 11],
          ['Sam', 14, 7]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Age' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name',
          outputAs: 'Student Name'
        }, {
          column: 'Class',
          outputAs: 'Class Name'
        }],
        [{
          column: 'Age',
          operation: 'count'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[0].name).toBe('Student Name');
      expect(result.schema[1].name).toBe('Class Name');
    });
  });

  describe('outputAs is used in aggregation config', () => {
    it('single sorted column grouping, single column aggregation', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age' }, { name: 'Class' }],
        dataArr = [
          ['John', 13, 7],
          ['Luna', 17, 11],
          ['Sam', 5, 2],
          ['John', 19, 11],
          ['Sam', 14, 7]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Name' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name'
        }],
        [{
          column: 'Age',
          operation: 'count',
          outputAs: 'Student Count'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[1].name).toBe('Student Count');
    });

    it('single unsorted column grouping, single column aggregation', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age' }, { name: 'Class' }],
        dataArr = [
          ['John', 13, 7],
          ['Luna', 17, 11],
          ['Sam', 5, 2],
          ['John', 19, 11],
          ['Sam', 14, 7]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Age' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name'
        }],
        [{
          column: 'Age',
          operation: 'count',
          outputAs: 'Student Count'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[1].name).toBe('Student Count');
    });

    it('multiple column grouping, single column aggregation', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age' }, { name: 'Class' }],
        dataArr = [
          ['John', 13, 7],
          ['Luna', 17, 11],
          ['Sam', 5, 2],
          ['John', 19, 11],
          ['Sam', 14, 7]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Name' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name'
        }, {
          column: 'Class'
        }],
        [{
          column: 'Age',
          operation: 'count',
          outputAs: 'Student Count'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[2].name).toBe('Student Count');
    });

    it('single column grouping, multiple column aggregation', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age', type: 'number' }, { name: 'Class' }],
        dataArr = [
          ['John', 13, 7],
          ['Luna', 17, 11],
          ['Sam', 5, 2],
          ['John', 19, 11],
          ['Sam', 14, 7]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Name' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name'
        }],
        [{
          column: 'Class',
          operation: 'count',
          outputAs: 'Student Count'
        }, {
          column: 'Age',
          operation: 'avg',
          outputAs: 'Student Average Age'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[1].name).toBe('Student Count');
      expect(result.schema[2].name).toBe('Student Average Age');
    });

    it('multiple column grouping, multiple column aggregation', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age', type: 'number' }, { name: 'Class' }],
        dataArr = [
          ['John', 13, 7],
          ['Luna', 17, 11],
          ['Sam', 5, 2],
          ['John', 19, 11],
          ['Sam', 14, 7]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Name' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name'
        }, {
          column: 'Class'
        }],
        [{
          column: 'Class',
          operation: 'count',
          outputAs: 'Student Count'
        }, {
          column: 'Age',
          operation: 'avg',
          outputAs: 'Student Average Age'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[2].name).toBe('Student Count');
      expect(result.schema[3].name).toBe('Student Average Age');
    });

    it('missing outputAs uses [original column name - operation]', () => {
      let DS, DT,
        schemaArr = [{ name: 'Name', type: 'string' }, { name: 'Age', type: 'number' }, { name: 'Class' }],
        dataArr = [
          ['John', 13, 7],
          ['Luna', 17, 11],
          ['Sam', 5, 2],
          ['John', 19, 11],
          ['Sam', 14, 7]
        ];

      DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Name' });
      DT = DS.getDataTable();
      groupByOps = groupBy(
        [{
          column: 'Name'
        }, {
          column: 'Class'
        }],
        [{
          column: 'Class',
          operation: 'count'
        }, {
          column: 'Age',
          operation: 'avg'
        }]
      );
      result = groupByOps.fn(DT._data, DT._schema, DT._config);

      expect(result.schema[2].name).toBe('Class - count');
      expect(result.schema[3].name).toBe('Age - avg');
    });
  });

  it('timeUnit used in date column', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );
    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.schema[0].type).toBe('interval');
    expect(result.data[0][0].config.duration.name).toEqual(DatetimeUnits.Hour.Unit);
  });

  it('timeUnit = second should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Second
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 30, 9, 58, 11));
    expect(result.data[0][0].end).toBe(+new Date(2016, 9, 30, 9, 58, 12));
  });

  it('timeUnit = minute should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Minute
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 30, 9, 58));
    expect(result.data[0][0].end).toBe(+new Date(2016, 9, 30, 9, 59));
  });

  it('timeUnit = hour should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Hour
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 30, 9));
    expect(result.data[0][0].end).toBe(+new Date(2016, 9, 30, 10));
  });

  it('timeUnit = day should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 30));
    expect(result.data[0][0].end).toBe(+new Date(2016, 9, 31));
  });

  it('timeUnit = day should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 30));
    expect(result.data[0][0].end).toBe(+new Date(2016, 10, 6));
  });

  // month
  // quarter
  // year

  it('incorrect timeUnit used in date column', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.abc
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );
    expect(() => groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config)).toThrow();
  });

  it('outputFormat is used', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour,
        outputFormat: '%e %B %Y, %I %p'
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );
    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data[0][0].toString()).toBe(' 1 February 2014, 12 AM');
  });

  it('default format if outputFormat is missing', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );
    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data[0][0].toString()).toBe('Feb 01, 2014 00 hrs');
  });

  it('binSize makes interval a range', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour,
        binSize: 3
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );

    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data[0][0].start).toBe(1391212800000);
    expect(result.data[0][0].end).toBe(1391223600000);
  });

  it('incorrect outputFormat', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour,
        outputFormat: '%g'
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );

    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data[0][0].toString()).toBe('g');
  });

  it('string binSize uses 1', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour,
        binSize: 'three'
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );

    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data[0][0].start).toBe(1391212800000);
    expect(result.data[0][0].end).toBe(1391216400000);
  });

  it('negative binSize uses positive', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour,
        binSize: -3
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );

    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data[0][0].start).toBe(1391212800000);
    expect(result.data[0][0].end).toBe(1391223600000);
  });

  it('null binSize uses 1', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour,
        binSize: null
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );

    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data[0][0].start).toBe(1391212800000);
    expect(result.data[0][0].end).toBe(1391216400000);
  });

  it('startValue is used when provided', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour,
        startValue: 1391329619000
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );

    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data[0][0].start).toBe(1391328000000);
    expect(result.data[0][0].end).toBe(1391331600000);
  });

  it('startValue greater than max returns empty data', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour,
        startValue: 1391365680000
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );

    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data).toEqual([]);
  });

  it('startValue should always be a number', () => {
    groupByOps = groupBy(
      [{
        column: 'starttime',
        timeUnit: DatetimeUnits.Hour,
        startValue: 'yesterday'
      }],
      [{
        column: 'tripduration',
        operation: 'stddev',
        outputAs: 'total trip duration'
      }]
    );

    result = groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config);

    expect(result.data[0][0].start).toBe(1391212800000);
    expect(result.data[0][0].end).toBe(1391216400000);
  });

  it('default weekStartFrom is sunday', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 30, 0, 0, 0));
    expect(result.data[0][0].end).toBe(+new Date(2016, 10, 6, 0, 0, 0));
  });

  it('weekStartFrom is monday', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week,
        weekStartFrom: Weekdays.Monday
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 24, 0, 0, 0));
    expect(result.data[0][0].end).toBe(+new Date(2016, 9, 31, 0, 0, 0));
  });

  it('weekStartFrom is tuesday', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week,
        weekStartFrom: Weekdays.Tuesday
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 25, 0, 0, 0));
    expect(result.data[0][0].end).toBe(+new Date(2016, 10, 1, 0, 0, 0));
  });

  it('weekStartFrom is wednesday', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week,
        weekStartFrom: Weekdays.Wednesday
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 26, 0, 0, 0));
    expect(result.data[0][0].end).toBe(+new Date(2016, 10, 2, 0, 0, 0));
  });

  it('weekStartFrom is thursday', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week,
        weekStartFrom: Weekdays.Thursday
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 27, 0, 0, 0));
    expect(result.data[0][0].end).toBe(+new Date(2016, 10, 3, 0, 0, 0));
  });

  it('weekStartFrom is friday', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week,
        weekStartFrom: Weekdays.Friday
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 28, 0, 0, 0));
    expect(result.data[0][0].end).toBe(+new Date(2016, 10, 4, 0, 0, 0));
  });

  it('weekStartFrom is saturday', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week,
        weekStartFrom: Weekdays.Saturday
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 29, 0, 0, 0));
    expect(result.data[0][0].end).toBe(+new Date(2016, 10, 5, 0, 0, 0));
  });

  it('weekStartFrom is sunday', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week,
        weekStartFrom: Weekdays.Sunday
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][0].start).toBe(+new Date(2016, 9, 30, 0, 0, 0));
    expect(result.data[0][0].end).toBe(+new Date(2016, 10, 6, 0, 0, 0));
  });

  it('incorrect weekStartFrom should throw error', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Week,
        weekStartFrom: 'monday'
      }],
      [{
        column: 'Item',
        operation: 'count',
        outputAs: 'Total Items'
      }]
    );

    expect(() => groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config)).toThrow();
  });

  it('UNDEF aggregation operation should throw error', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'wrong',
        outputAs: 'Total value'
      }]
    );

    expect(() => groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config)).toThrow();
  });

  it('sum aggregation should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'sum',
        outputAs: 'Total value'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(Number(result.data[0][1].toFixed(2))).toBe(3011.76);
  });

  it('avg aggregation should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'avg',
        outputAs: 'Average value'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(Number(result.data[0][1].toFixed(2))).toBe(16.73);
  });

  it('count aggregation should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'count',
        outputAs: 'Total items'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][1]).toBe(180);
  });

  it('min aggregation should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'min',
        outputAs: 'Minimum value'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][1]).toBe(1.03);
  });

  it('max aggregation should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'max',
        outputAs: 'Maximum value'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][1]).toBe(30.71);
  });

  it('first aggregation should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'first',
        outputAs: 'First value'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][1]).toBe(21.8);
  });

  it('last aggregation should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'last',
        outputAs: 'Last value'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(result.data[0][1]).toBe(25.29);
  });

  it('stddev aggregation should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'stddev',
        outputAs: 'Standard Deviation'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(Number(result.data[0][1].stddev.toFixed(2))).toBe(8.88);
  });

  it('variance aggregation should work', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Value',
        operation: 'variance',
        outputAs: 'Variance'
      }]
    );

    result = groupByOps.fn(salesTransactionDT._data, salesTransactionDT._schema, salesTransactionDT._config);

    expect(Number(result.data[0][1].variance.toFixed(1))).toBe(78.8);
  });

  it('numberic aggregation on non-numeric column should throw error', () => {
    groupByOps = groupBy(
      [{
        column: 'Time',
        timeUnit: DatetimeUnits.Day
      }],
      [{
        column: 'Item',
        operation: 'sum'
      }]
    );

    expect(() => groupByOps.fn(cityBikesDT._data, cityBikesDT._schema, cityBikesDT._config)).toThrow();
  });
});

describe('test groupBy edge cases', () => {
  var DS, DT, groupByOps,
    result;

  it('empty data array returns empty result without error', () => {
    let dataArr = [], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(0);
  });

  it('first row empty returns result without error', () => {
    let dataArr = [
        [],
        ['Harry', 28],
        ['John', 21],
        ['Sam', 20],
        ['Harry', 16],
        ['Sam', 33],
        ['John', 33],
        ['Harry', 27],
        ['John', 41],
        ['John', 40],
        ['Sam', 12]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DT = new DataStore().createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true });

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(4);
  });

  it('first row null returns result without error', () => {
    let dataArr = [
        [null, null],
        ['Harry', 28],
        ['John', 21],
        ['Sam', 20],
        ['Harry', 16],
        ['Sam', 33],
        ['John', 33],
        ['Harry', 27],
        ['John', 41],
        ['John', 40],
        ['Sam', 12]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(4);
  });

  it('multiple empty rows returns result without error', () => {
    let dataArr = [
        [],
        ['Harry', 28],
        ['John', 21],
        ['Sam', 20],
        ['Harry', 16],
        ['Sam', 33],
        [],
        [],
        ['John', 33],
        ['Harry', 27],
        ['John', 41],
        ['John', 40],
        ['Sam', 12]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(4);
  });

  it('first row with aggregation column value as empty returns result without error', () => {
    let dataArr = [
        ['Sam'],
        ['Harry', 28],
        ['John', 21],
        ['Sam', 20],
        ['Harry', 16],
        ['Sam', 33],
        ['John', 33],
        ['Harry', 27],
        ['John', 41],
        ['John', 40],
        ['Sam', 12]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    const sam_grouped_row = result.data.filter(x => x[0] === 'Sam');

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(sam_grouped_row[0][1]).toBe(65/3);    
  });

  it('first row with aggregation column value as empty will still be counted if count is applied on grouped column', () => {
    let dataArr = [
        ['Sam'],
        ['Harry', 28],
        ['John', 21],
        ['Sam', 20],
        ['Harry', 16],
        ['Sam', 33],
        ['John', 33],
        ['Harry', 27],
        ['John', 41],
        ['John', 40],
        ['Sam', 12]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Name',
        operation: 'count'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    const sam_grouped_row = result.data.filter(x => x[0] === 'Sam');

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(sam_grouped_row[0][1]).toBe(4);    
  });

  it('first row with aggregation column value as null returns result without error', () => {
    let dataArr = [
        ['Sam', null],
        ['Harry', 28],
        ['John', 21],
        ['Sam', 20],
        ['Harry', 16],
        ['Sam', 33],
        ['John', 33],
        ['Harry', 27],
        ['John', 41],
        ['John', 40],
        ['Sam', 12]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(Math.round(result.data[0][1] * 1e2) / 1e2).toBe(21.67);
  });

  it('all aggregation column values as null returns result without error', () => {
    let dataArr = [
        ['Sam', null],
        ['Harry', null],
        ['John', null],
        ['Sam', null],
        ['Harry', null],
        ['Sam', null],
        ['John', null],
        ['Harry', null],
        ['John', null],
        ['John', null],
        ['Sam', null]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(result.data[0][1]).toBe(UNDEF);
    expect(result.data[1][1]).toBe(UNDEF);
    expect(result.data[2][1]).toBe(UNDEF);
  });

  it('all group column values as null returns result without error', () => {
    let dataArr = [
        [null, 28],
        [null, 21],
        [null, 20],
        [null, 16],
        [null, 33],
        [null, 33],
        [null, 27],
        [null, 41],
        [null, 40],
        [null, 12]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(1);
    expect(result.data[0][0]).toBe(null);
    expect(result.data[0][1]).toBe(27.1);
  });

  it('all group column values as empty strings returns result without error', () => {
    let dataArr = [
        ['', 28],
        ['', 21],
        ['', 20],
        ['', 16],
        ['', 33],
        ['', 33],
        ['', 27],
        ['', 41],
        ['', 40],
        ['', 12]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(1);
    expect(result.data[0][0]).toBe('');
    expect(result.data[0][1]).toBe(27.1);
  });

  it('group column values as empty strings returns result without error', () => {
    let dataArr = [
        ['', 5],
        ['Harry', 28],
        ['John', 21],
        ['Sam', 20],
        ['Harry', 16],
        ['Sam', 33],
        ['John', 33],
        ['Harry', 27],
        ['John', 41],
        ['John', 40],
        ['Sam', 12],
        ['', 40],
        ['', 12]
      ], schemaArr = [{ name: 'Name' }, { name: 'Age', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Name'
      }],
      [{
        column: 'Age',
        operation: 'avg'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(4);
    expect(result.data[0][0]).toBe('');
    expect(result.data[0][1]).toBe(19);
  });

  it('0 value in variance operation', () => {
    let dataArr = [
        ['2016-10-30 09:58:11', 1, 'Bread', -10, 'India'],
        ['2016-10-30 09:59:11', 1, 'Bread', null, 'India'],
        ['2016-10-30 10:03:34', 2, 'Scandinavian', 27.13, 'India'],
        ['2016-10-30 10:04:34', 2, 'Scandinavian', null, 'India'],
        ['2016-10-30 10:05:44', 2, 'Scandinavian', 0, 'India'],
        ['2016-10-30 10:07:57', 3, 'Hot chocolate', 0, 'India'],
        ['2016-10-30 10:08:57', 3, 'Hot chocolate', 12, 'Srilanka'],
        ['2016-10-30 10:09:37', 3, 'Hot chocolate', null, 'Srilanka'],
        ['2016-10-30 10:09:57', 1, 'Bread', 0, 'Srilanka'],
        ['2016-10-30 10:10:57', 3, 'Bread', 110, 'Srilanka'],
        ['2016-10-30 10:10:59', 2, 'Scandinavian', 4.15, 'Srilanka']
      ], schemaArr = [
        { name: 'Time', type: 'datetime', format: '%Y-%m-%d %H:%M:%S' // enableUTC: true
        },
        { name: 'Transaction', type: 'number' },
        { name: 'Item', type: 'string' },
        { name: 'Value', type: 'number' },
        { name: 'Country', type: 'string' }
      ];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true });
    DT = DS.getDataTable();

    groupByOps = groupBy([{
      column: 'Item'
    }], [{
      column: 'Value',
      operation: 'avg'
    }, {
      column: 'Value',
      operation: 'variance'
    }, {
      column: 'Value',
      operation: 'stddev'
    }]);

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(result.data[2][0]).toBe('Hot chocolate');
    expect(result.data[2][1]).toBe(6);
    expect(result.data[2][2]).toEqual({ avg: 6, variance: 72 });
    expect(result.data[2][3]).toEqual({ avg: 6, stddev: 8.48528137423857 });
  });

  it('0 can be min', () => {
    let dataArr = [
        ['A', 10],
        ['B', 10],
        ['B', 0],
        ['A', 10],
        ['C', -10],
        ['B', 3],
        ['A', 10],
        ['C', -4],
        ['A', 14],
        ['C', 0]
      ], schemaArr = [{ name: 'Item', type: 'string' }, { name: 'Value', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Item' });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Item'
      }],
      [{
        column: 'Value',
        operation: 'min'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(result.data[1][0]).toBe('B');
    expect(result.data[1][1]).toBe(0);
    
    DT = new DataStore().createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Value' });

    groupByOps = groupBy(
      [{
        column: 'Item'
      }],
      [{
        column: 'Value',
        operation: 'min'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(result.data[1][0]).toBe('B');
    expect(result.data[1][1]).toBe(0);
  });

  it('0 can be max', () => {
    let dataArr = [
        ['A', 10],
        ['B', 10],
        ['B', 0],
        ['A', 10],
        ['C', -10],
        ['B', 3],
        ['A', 10],
        ['C', -4],
        ['A', 14],
        ['C', 0]
      ], schemaArr = [{ name: 'Item', type: 'string' }, { name: 'Value', type: 'number' }];
    
    DT = new DataStore().createDataTable(dataArr, schemaArr, 'table-1', { enableIndex: true, indexBy: 'Item' });

    groupByOps = groupBy(
      [{
        column: 'Item'
      }],
      [{
        column: 'Value',
        operation: 'max'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);    
    expect(result.data[2][0]).toBe('C');
    expect(result.data[2][1]).toBe(0);    
  });

  it('0 can be first value', () => {
    let dataArr = [
        ['B', null, 2],
        ['A', 10, 1],
        ['B', 0, 1],
        ['B', 10, 2],
        ['A', 10, 1],
        ['C', -10, 1],
        ['A', 10, 2],
        ['C', -4, 1],
        ['A', 14, 1],
        ['C', 0, 2],
        ['B', 2, 1],
        ['A', 3, 2],
        ['C', 10, 2]
      ], schemaArr = [{ name: 'Item', type: 'string' }, { name: 'Value', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Item' });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Item'
      }],
      [{
        column: 'Value',
        operation: 'first'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(result.data[1][0]).toBe('B');
    expect(result.data[1][1]).toBe(0);

    DS = new DataStore(dataArr, schemaArr, { enableIndex: false });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Item'
      }],
      [{
        column: 'Value',
        operation: 'first'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(result.data[0][0]).toBe('B');
    expect(result.data[0][1]).toBe(0);
  });

  it('0 can be last', () => {
    let dataArr = [
        ['B', null, 2],
        ['A', 10, 1],
        ['B', 10, 2],
        ['A', 10, 1],
        ['C', -10, 1],
        ['A', 10, 2],
        ['C', -4, 1],
        ['A', 14, 1],
        ['B', 2, 1],
        ['A', 3, 2],
        ['C', 10, 2],
        ['C', 0, 2],
        ['B', 0, 1]
      ], schemaArr = [{ name: 'Item', type: 'string' }, { name: 'Value', type: 'number' }];

    DS = new DataStore(dataArr, schemaArr, { enableIndex: true, indexBy: 'Item' });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Item'
      }],
      [{
        column: 'Value',
        operation: 'last'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(result.data[2][0]).toBe('C');
    expect(result.data[2][1]).toBe(0);

    DS = new DataStore(dataArr, schemaArr, { enableIndex: false });
    DT = DS.getDataTable();

    groupByOps = groupBy(
      [{
        column: 'Item'
      }],
      [{
        column: 'Value',
        operation: 'last'
      }]
    );

    result = groupByOps.fn(DT._data, DT._schema, DT._config);

    expect(result.data.constructor).toBe(Array);
    expect(result.data.length).toBe(3);
    expect(result.data[2][0]).toBe('C');
    expect(result.data[2][1]).toBe(0);
  });
});
