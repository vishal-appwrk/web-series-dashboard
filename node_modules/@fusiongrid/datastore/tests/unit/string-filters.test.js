import { contains, startsWith, endsWith } from '../../src/operators/string-filters';

let UNDEF;
const data = [
    ['Mike Bostock', 50],
    ['Rich Harris', 45],
    ['Mike Bostock', 50],
    ['Michelle Obama', 55],
    ['Michelle Stark', 30],
    ['Arya Stark', 18],
    ['Richie Rich', 21],
    ['Richie Richardson', 45],
    ['Ryan Harris', 35],
    ['Harrison Ford', 35],
    ['Tara Trofors', 35],
    ['Ryan Brewstar', 38],
    [2,100],
    [UNDEF,25],
    [null, null],
    ['a+b*', 25],
    ['*8b*', 25],
  ], schema = [
    {
      name: 'Name'
    }, {
      name: 'Age',
      type: 'number'
    }
  ];

describe('Contains operation - ', () => {
  it('filters out all the strings with a pattern occurring at start, end or middle of another string and by default operation is case insensitive', () => {
    let returnVal = contains('Name', 'tar'),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(4);
  });

  it('filters out all the strings with a pattern occurring at start, end or middle of another string by case sensitive operations', () => {
    let returnVal = contains('Name', 'tar', true),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(3);
  });

  it('works with patterns containing space as well', () => {
    let returnVal = contains('Name', 'rich '),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);
    expect(returnArr[0][0]).toBe('Rich Harris');

    returnVal = contains('Name', ' rich');
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(2);
    expect(returnArr[0][0]).toBe('Richie Rich');
    expect(returnArr[1][0]).toBe('Richie Richardson');
  });

  it('works with patterns containing special characters', () => {
    let returnVal = contains('Name', '+'),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);

    returnVal = contains('Name', '*');
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(2);

    returnVal = contains('Name', 'a+');
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);

    returnVal = contains('Name', 'b*');
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(2);
  });
});

describe('Starts with operation - ', () => {
  it('filters out all the strings with a pattern occurring at start of another string and by default operation is case insensitive', () => {
    let returnVal = startsWith('Name', 'Ar'),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);

    returnVal = startsWith('Name', 'tar');
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);
  });

  it('filters out all the strings with a pattern occurring at start of another string by case sensitive operations', () => {
    let returnVal = startsWith('Name', 'Tar', true),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);

    returnVal = startsWith('Name', 'tar', true);
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(0);
  });

  it('works with patterns containing space as well', () => {
    let returnVal = startsWith('Name', 'rich '),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);
    expect(returnArr[0][0]).toBe('Rich Harris');
  });

  it('works with patterns containing special characters', () => {
    let returnVal = startsWith('Name', '+'),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(0);

    returnVal = startsWith('Name', '*');
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);

    returnVal = startsWith('Name', 'a+');
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);
  });
});


describe('Ends with operation - ', () => {
  it('filters out all the strings with a pattern occurring at end of another string and by default operation is case insensitive', () => {
    let returnVal = endsWith('Name', 's'),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(3);    
  });

  it('filters out all the strings with a pattern occurring at end of another string by case sensitive operations', () => {
    let returnVal = endsWith('Name', 'Bostock', true),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(2);

    returnVal = endsWith('Name', 'bostock', true);
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(0);
  });

  it('works with patterns containing space as well', () => {
    let returnVal = endsWith('Name', ' bostock'),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(2);
    expect(returnArr[0][0]).toBe('Mike Bostock');
  });

  it('works with patterns containing special characters', () => {
    let returnVal = endsWith('Name', '+'),
      returnFn = returnVal.fn(data, schema),
      returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(0);

    returnVal = endsWith('Name', '*');
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(2);

    returnVal = endsWith('Name', '*8b*');
    returnFn = returnVal.fn(data, schema);
    returnArr = returnFn.generatorFn();

    expect(returnArr.length).toBe(1);
  });
});

