/**
 * Attaches handler functions to an event
 *
 * @param {string} eventName The name of the event
 * @param {function} handler The handler function for the event
 * @param {object} sender The object on which the event occured
 */
function addHandler (eventName, handler, sender) {
  var attachedHandlersLen;

  // in case handler is sent as array, we recursively process it
  if (handler instanceof Array) {
    let recurseReturn = [], handlerLen = handler.length;
    for (let i = 0; i < handlerLen; i += 1) {
      recurseReturn.push(addHandler(eventName, handler[i], sender));
    }
    return recurseReturn;
  }

  if (!eventName || typeof eventName !== 'string') throw new Error('eventName must be a non-empty string');
  if (typeof handler !== 'function') throw new Error('handler must be a function');
  if (!(sender instanceof Object)) throw new Error('sender must be an object');

  // initialize the sender._evtHandlers if absent
  sender._evtHandlers = sender._evtHandlers || {};
  if (!sender._evtHandlers[eventName] || !(sender._evtHandlers[eventName] instanceof Array)) {
    sender._evtHandlers[eventName] = [];
  }

  // if this is a a duplicate handler for this eventName, then exit with false
  attachedHandlersLen = sender._evtHandlers[eventName].length;
  for (let i = 0; i < attachedHandlersLen; i++) {
    if (sender._evtHandlers[eventName][i] === handler) {
      return false;
    }
  }

  // push this handler in the array of handlers for this eventName
  sender._evtHandlers[eventName].push(handler);

  return true;
}

/**
 * Fetched handler functions for an event
 *
 * @param {string} eventName The name of the event
 * @param {function} handler The handler function for the event
 */
function getHanlders (eventName, sender) {
  if (typeof eventName !== 'string') throw new Error('eventName must be a non-empty string');
  if (!(sender instanceof Object)) throw new Error('sender must be an object');

  return (sender._evtHandlers && sender._evtHandlers[eventName]) || [];
}

/**
 * Removes handler functions from an event
 *
 * @param {string} eventName The name of the event
 * @param {function} handler The handler function for the event
 * @param {object} sender The object on which the event occured
 */
function removeHandler (eventName, handler, sender) {
  var attachedHandlers, attachedHandlersLen;

  // in case handler is sent as array, we recursively process it
  if (handler instanceof Array) {
    let recurseReturn = [], handlerLen = handler.length;
    for (let i = 0; i < handlerLen; i += 1) {
      recurseReturn.push(removeHandler(eventName, handler[i], sender));
    }
    return recurseReturn;
  }

  if (!eventName || typeof eventName !== 'string') throw new Error('eventName must be a non-empty string');
  if (handler && typeof handler !== 'function') throw new Error('handler must be a function');
  if (!(sender instanceof Object)) throw new Error('sender must be an object');

  // get all the handlers for the event
  attachedHandlers = getHanlders(eventName, sender);

  // if event has no handlers, return
  if (!(attachedHandlers instanceof Array) || attachedHandlers.length === 0) {
    return;
  }

  // if handler is empty, remove all
  if (!handler) {
    delete sender._evtHandlers[eventName];
    return true;
  }

  // else, loop through the handlers and remove the relevant one
  attachedHandlersLen = attachedHandlers.length;
  for (let i = 0; i < attachedHandlersLen; i++) {
    if (attachedHandlers[i] === handler) {
      attachedHandlers.splice(i, 1);
    }
  }

  return true;
}

function triggerEvent (eventName, sender, args) {
  var attachedHandlers, attachedHandlersLen, eventObj;

  if (!eventName || typeof eventName !== 'string') throw new Error('eventName must be a non-empty string');
  if (!(sender instanceof Object)) throw new Error('sender must be an object');

  attachedHandlers = getHanlders(eventName, sender);

  eventObj = {
    eventName: eventName,
    sender: sender,
    data: args
  };

  // if event has no handlers, return
  if (!(attachedHandlers instanceof Array) || attachedHandlers.length === 0) {
    return;
  }

  // loop through the handlers and call each
  attachedHandlersLen = attachedHandlers.length;
  for (let i = 0; i < attachedHandlersLen; i++) {
    attachedHandlers[i](eventObj);
  }

  return true;
}

export { addHandler, getHanlders, removeHandler, triggerEvent };
