import sort from './sort';
import { getConfig } from '../globals/global-config';
import { FieldType } from '../enums/field-type';
import { isNumber, numberComparator, stringComparator } from '../toolbox/src/index';
import TimeConverter from '../time-converters/src/index';
import { ROW_ID_COL_NAME } from '../globals/defaults';

/**
 * Get 0 based index of a column from the schema
 * @param {string} columnName The name of the column to find
 * @param {array} schema The schema array
 */
function columnIndexOf (columnName, schema) {
  if (!schema || !columnName) return null;

  for (let i = 0; i < schema.length; i++) {
    if (schema[i] && schema[i].name === columnName) {
      return i;
    }
  }

  return -1;
}

/**
 * Get the minimum value from a column
 * @param {string} columnName The name of the column to find
 * @param {array} data The data array
 * @param {array} schema The schema array
 */
function columnMinValue (columnName, data, schema) {
  let columnIndex, minVal;
  // get the column index
  columnIndex = columnIndexOf(columnName, schema);

  // check if column is found
  if (columnIndex === null || columnIndex === -1) {
    return null;
  }

  // check if data is valid
  if (data && data.length > 0) {
    let valToCheck;
    minVal = Number.POSITIVE_INFINITY;
    for (let i = 0; i < data.length; i++) {
      valToCheck = schema[columnIndex].type === FieldType.Interval ? data[i][columnIndex] ? data[i][columnIndex].start : null : data[i][columnIndex];
      if (isNumber(valToCheck) && valToCheck < minVal) {
        minVal = valToCheck;
      }
    }
  }

  return minVal;
}

/**
 * Get the maximum value from a column
 * @param {string} columnName The name of the column to find
 * @param {array} data The data array
 * @param {array} schema The schema array
 */
function columnMaxValue (columnName, data, schema) {
  let columnIndex, maxVal;
  // get the column index
  columnIndex = columnIndexOf(columnName, schema);

  // check if column is found
  if (columnIndex === null || columnIndex === -1) {
    return null;
  }

  // check if data is valid
  if (data && data.length > 0) {
    let valToCheck;
    maxVal = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < data.length; i++) {
      valToCheck = schema[columnIndex].type === FieldType.Interval ? data[i][columnIndex] ? data[i][columnIndex].end : null : data[i][columnIndex];
      if (isNumber(valToCheck) && valToCheck > maxVal) {
        maxVal = valToCheck;
      }
    }
  }

  return maxVal;
}

/**
 * Get the min difference between values in a column
 * @param {string} columnName The name of the column to find
 * @param {array} data The data array
 * @param {array} schema The schema array
 * @param {string} indexBy The column name on which the data is indexed/sorted
 */
function columnMinDiff (columnName, data, schema, indexBy) {
  // proceed only if date or number, else throw error
  let columnIndex, dataClone = data, minDiff;
  // get the column index
  columnIndex = columnIndexOf(columnName, schema);

  // check if column is found
  if (columnIndex === null || columnIndex === -1) {
    return null;
  }

  if (schema[columnIndex] && [FieldType.DateTime, FieldType.Number].indexOf(schema[columnIndex].type) < 0) throw new Error('Operation valid only on date or number columns');

  // if column is not indexBy then sort it
  if (!indexBy || columnName !== indexBy) {
    // clone before sorting so as not to disturb the original data
    dataClone = data.slice(0);
    dataClone.sort((a, b) => {
      return numberComparator(a[columnIndex], b[columnIndex]);
    });
  }

  // loop through the data,
  // calculate the difference between current and next elements,
  // if new difference less than current difference, update it
  if (dataClone && data.length > 0) {
    let valToCheck, a, b;
    minDiff = Number.POSITIVE_INFINITY;
    for (let i = 0; i < dataClone.length - 1; i++) {
      a = dataClone[i][columnIndex];
      b = dataClone[i + 1][columnIndex];
      if (isNumber(b) && isNumber(a)) {
        // both are 0, then 0
        // either/both greater than 0 and not same then subtract
        valToCheck = b - a;
        minDiff = isNumber(valToCheck) && valToCheck >= 0 && valToCheck < minDiff ? valToCheck : minDiff;

        // difference will always be positive and the smallest value can be 0
        if (minDiff === 0) break;
      } else {
        break;
      }
    }
  }

  return minDiff === Number.POSITIVE_INFINITY ? null : minDiff;
}

/**
 * Get both minimum and maximum from a column
 * @param {string} columnName The name of the column to find
 * @param {array} data The data array
 * @param {array} schema The schema array
 */
function columnExtents (columnName, data, schema) {
  let min = Number.POSITIVE_INFINITY,
    max = Number.NEGATIVE_INFINITY,
    columnIndex = columnIndexOf(columnName, schema), valToCheck; // get the column index

  // check if column is found
  if (columnIndex === null || columnIndex === -1) {
    return null;
  }

  // check if data is valid
  if (data && data.length > 0) {
    for (let i = 0; i < data.length; i++) {
      valToCheck = schema[columnIndex].type === FieldType.Interval ? data[i][columnIndex] ? data[i][columnIndex].start : null : data[i][columnIndex];

      if (isNumber(valToCheck) && valToCheck < min) {
        min = valToCheck;
      }

      valToCheck = schema[columnIndex].type === FieldType.Interval ? data[i][columnIndex] ? data[i][columnIndex].end : null : data[i][columnIndex];

      if (isNumber(valToCheck) && valToCheck > max) {
        max = valToCheck;
      }
    }
  }

  return {
    min: min,
    max: max
  };
}

/**
 * Get unique values from a column
 * @param {string} columnName The name of the column to find
 * @param {array} data The data array
 * @param {array} schema The schema array
 */
function columnUnique (columnName, data, schema) {
  // get the column index
  let columnIndex = columnIndexOf(columnName, schema), uniqueVals = [], uniqueList;

  // check if column is found
  if (columnIndex === null || columnIndex === -1) {
    return [];
  }

  for (let i = 0; i < data.length; i++) {
    uniqueVals.push(data[i][columnIndex]);
  }

  if (data && data.length > 0) {
    uniqueList = Array.from(new Set(uniqueVals));
    return uniqueList.length === 1 && typeof uniqueList[0] === 'undefined' ? [] : uniqueList;
  }

  return [];
}

/**
 * Returns the schema updated with new columns
 *
 * @param {array} schema The schema to be updated
 * @param {array} columnConfigs The columns to be added
 */
function addColumnsSchema (schema, columnConfigs) {
  var schemaCopy = schema.slice(0);

  for (let i = 0; i < columnConfigs.length; i++) {
    let schemaLen = schemaCopy.length;
    columnConfigs[i].originalName = columnConfigs[i].name;

    for (let j = 0; j < schemaLen; j++) {
      // if name already exists append increasing integer
      if (columnConfigs[i].name === schemaCopy[j].name) {
        columnConfigs[i].i = (columnConfigs[i].i && ++columnConfigs[i].i) || 1;
        columnConfigs[i].name = columnConfigs[i].originalName + ' ' + columnConfigs[i].i;
      }

      // if type is missing or not one of string, number and date, then use string
      if (!columnConfigs[i].type || [FieldType.String, FieldType.Number, FieldType.DateTime].indexOf(columnConfigs[i].type) === -1) {
        columnConfigs[i].type = FieldType.String;
      }
    }

    // clear up temporary value
    delete columnConfigs[i].originalName;
    delete columnConfigs[i].i;

    // update the schemaCopy
    schemaCopy.push({
      name: columnConfigs[i].name,
      type: columnConfigs[i].type || FieldType.String
    });

    // save the calcFn, format, enableUTC as well
    if (columnConfigs[i].calcFn) {
      schemaCopy[schemaCopy.length - 1].calcFn = columnConfigs[i].calcFn;
    }
    if (columnConfigs[i].format) {
      schemaCopy[schemaCopy.length - 1].format = columnConfigs[i].format;
    }
    if (columnConfigs[i].enableUTC) {
      schemaCopy[schemaCopy.length - 1].enableUTC = columnConfigs[i].enableUTC;
    }

    // set the columnindex of the new column in the schemaCopy
    columnConfigs[i].columnIndex = schemaCopy.length - 1;
  }

  return {
    schema: schemaCopy,
    calcColumns: columnConfigs
  };
}

/**
 * Returns the data updated with new columns
 *
 * @param {array} data The data to be updated
 * @param {array} schema The schema to be updated
 * @param {array} columnConfigs The columns to be added
 */
function addColumnsData (data, schema, columnConfigs) {
  var columns = {}, cellData;

  // create the columns object which is basically a mapping between column name and index
  // as user will provide the filter fn as = (row, columns) => row[columns.Name] === 'val'
  for (let i = 0; i < schema.length; i++) {
    columns[schema[i].name] = i;
  }

  // loop through the data
  for (let i = 0; i < data.length; i++) {
    // loop through the columns
    for (let j = 0; j < columnConfigs.length; j++) {
      // if calcFn, process it
      if (columnConfigs[j].calcFn) {
        cellData = columnConfigs[j].calcFn(data[i], columns, i);
        cellData = _parseCell(columnConfigs[j], cellData, buildDateColumnsFormatter(columnConfigs));

        data[i][columnConfigs[j].columnIndex] = cellData;
      }
    }
  }

  return data;
}

function _parseCell (colConfig, val, dateColumnsAndFormatter) {
  if (colConfig.type === FieldType.DateTime) {
    let parsedDate;
    if (dateColumnsAndFormatter[colConfig.name]) { // if formatter is defined, parse value according to formatter
      parsedDate = dateColumnsAndFormatter[colConfig.name].parse(val);
    } else { // if formatter is not defined, then attempt to parse directly
      parsedDate = new Date(val);
    }

    // Except null and undefined, other value must be converted to epoc
    if (parsedDate) {
      // We store only epoc values in datatable datetime column
      parsedDate = +parsedDate;
    }
    // after converting to epoc value, if it's a valid date then epoc value will be a valid number, otherwise we fill the cell with null
    return isNumber(parsedDate) ? parsedDate : null;
  } else if (colConfig.type === FieldType.Number) {
    if (isNumber(val)) {
      return val;
    }
    let parsedNumber = parseFloat(val);
    return isNumber(parsedNumber) ? parsedNumber : null;
  } else if (typeof val !== 'undefined' && val !== null) {
    // default type is string
    return val.toString();
  }
  return val;
}

/**
 * Parse and perform indexing. Returns the parsed & indexed data
 * @param {array} data 2D array or array of JSON object
 * @param {array} schema array of JSON object
 * @param {object} config configuration object
 * @param {function} row_id_generator generator function for row id
 * @returns {array} parsed and indexed data
 */
function parseAndIndexData (data, schema, config, row_id_generator) {
  // build date column and formatter map object
  let dateColumnsAndFormatter = buildDateColumnsFormatter(schema),
    // parse the data
    parsedData = parseData(data, schema, dateColumnsAndFormatter, row_id_generator);

  // perform indexing
  indexData(parsedData, schema, config, dateColumnsAndFormatter);

  // return the parsed data
  return parsedData;
}

/**
 * Build date column and formatter mapping
 * @param {array} schema schema object array
 */
function buildDateColumnsFormatter (schema) {
  let dateColumnsAndFormatter = {};
  // loop through the schema and check all date type and store the column name formatter object
  for (let i = 0; i < schema.length; i++) {
    // check if all elements of input schema has name attribute
    // for now we are allowing blank values
    if (!schema[i].name) {
      throw new Error('Input schema is not in a correct format - each column must have a name');
    }

    if (schema[i].type && schema[i].type === FieldType.DateTime) {
      // key will be the column name
      dateColumnsAndFormatter[schema[i].name] =
        schema[i].format // if format is not provided in schema just insert null, so that the value is parsed according to JS date object parsing rule
          ? ((typeof schema[i].enableUTC !== 'undefined' ? schema[i].enableUTC : getConfig('enableUTC')) ? TimeConverter.utcParser(schema[i].format) : TimeConverter.parser(schema[i].format))
          : null;
    }
  }

  return dateColumnsAndFormatter;
}

/**
 * Parse the data
 * @param {array} data 2D array or array of JSON
 * @param {array} schema array of schema objects
 * @param {object} dateColFormatter a key value pair containing date columns and formatter
 * @param {function} row_id_generator generator function for row id
 * @return {array} parsed data
 */
function parseData (data, schema, dateColFormatter, row_id_generator) {
  let parsedData = [];

  // if any data is present only then perform parsing and indexing
  if (data.length > 0) {
    // store all date column and corresponding formatter object in a key value
    // pair we do not wish to create a formatter object every time we want to
    // parse a date
    let dateColumnsAndFormatter = dateColFormatter,
      i,
      indexofRowIdColumn = schema.findIndex(s => s.name === ROW_ID_COL_NAME);

    if (!dateColumnsAndFormatter) {
      dateColumnsAndFormatter = buildDateColumnsFormatter(schema);
    }

    // If a ROW_ID_COL_NAME column doesn't already exist,
    if (indexofRowIdColumn === -1) {
      // Mutate the data and schema by adding an ROW_ID_COL_NAME column
      // This helps track rows when items are deleted or otherwise modified
      indexofRowIdColumn = schema.push({ name: ROW_ID_COL_NAME, type: FieldType.Number }) - 1;
    }

    // start parsing the data
    try {
      let columnLength = schema.length,
        arr,
        element,
        arrLen;

      for (let n = 0; n < data.length; n++) {
        // initialize the row array
        arr = [];
        // get the current row
        element = data[n];

        // check if elements is an array
        if (element.constructor === Array) {
          // array length will be minimum of schema length and currently
          // encountered row array length so that extra values are discarded
          arrLen = Math.min(columnLength, element.length);
          // loop over the columns and parse data
          for (i = 0; i < arrLen; i++) {
            arr[i] = _parseCell(schema[i], element[i], dateColumnsAndFormatter);
          }
        } else if (typeof element === 'object') {
          // if currently encountered row is an object then JSON parse
          for (i = 0; i < columnLength; i++) {
            if (typeof element[schema[i].name] !== 'undefined' && element[schema[i].name] !== null) {
              arr[i] = _parseCell(
                schema[i],
                element[schema[i].name],
                dateColumnsAndFormatter
              );
            }
          }
        } else {
          // this is done to ensure blank array is not pushed into the data i.e.
          // if a single string or number appears in between rows then it will
          // be skipped rather than throwing error
          continue;
        }

        // setting the row id of current row
        arr[indexofRowIdColumn] = row_id_generator();
        parsedData.push(arr);
      }
    } catch (e) {
      throw new Error('Error while parsing the data - ' + e);
    }
  }

  return parsedData;
}

/**
 * Perform indexing on the parsed data
 * @param {array} parsedData 2D array of parsed data
 * @param {array} schema array of JSON objects
 * @param {object} config configuration object
 * @param {object} dateColFormatter date column and formatter mapping
 */
function indexData (parsedData, schema, config, dateColFormatter) {
  if (config.enableIndex) {
    let i, comparator, dateColumnsAndFormatter;
    // If indexing is enabled but no index column is specified then we will smartly pick one column for indexing
    if (!config.indexBy) {
      // determine the index by column smartly

      dateColumnsAndFormatter = dateColFormatter;

      if (!dateColumnsAndFormatter) {
        dateColumnsAndFormatter = buildDateColumnsFormatter(schema);
      }

      // if any date column is present then priority is the date column
      let dateColumns = Object.keys(dateColumnsAndFormatter);
      if (dateColumns.length > 0) {
        // for multiple date columns, pick the first one
        config.indexBy = dateColumns[0];
      } else {
        // otherwise if number column is present then pick the first number column
        for (i = 0; i < schema.length; i++) {
          if (schema[i].type && schema[i].type === FieldType.Number) {
            config.indexBy = schema[i].name;
            break;
          }
        }

        // if number column is not present then just pick the first column as index column
        if (i === schema.length) {
          config.indexBy = schema[0].name;
        }
      }
    }

    for (i = 0; i < schema.length; i++) {
      if (schema[i] && schema[i].name === config.indexBy) {
        break;
      }
    }

    if (i === schema.length) {
      throw new Error('Index column is not found in schema');
    }

    // determine which type of comparator to be used for the sorting
    switch (schema[i].type) {
      case FieldType.Number:
      case FieldType.DateTime:
        // we will not be dealing with interval column
        // interval is only an intermediate column and not exposed
        // and user will only be feeding exterbal data to data store
        // but for children data table we must deal with interval column
        comparator = numberComparator;
        break;
      default:
        comparator = stringComparator;
        break;
    }

    // sorts the data based on the index column
    sort(parsedData, (a, b) => comparator(a[i], b[i]));
  }
}

/**
 * Checks the data store's internal storage and create a non conflicting table id
 * @param {array} tableIdArr string array of table id inside a data store
 * @returns {string} unique table id which is not present in the provided tableIdArr
 */
function createTableID (tableIdArr) {
  let counter = tableIdArr.length + 1;

  while (tableIdArr.includes('table-' + counter)) {
    counter++;
  }

  return 'table-' + counter;
}

/**
 * Get the enableUTC flag of the column or global.
 * @param {string} columnName The name of the column to find
 * @param {array} schema The schema array
 */
function isUTCEnabled (columnName, schema) {
  let columnIndex;
  // get the column index
  columnIndex = columnIndexOf(columnName, schema);

  // if column not found OR column is not of type date/interval
  if (columnIndex === null || columnIndex === -1 || (schema[columnIndex].type !== FieldType.DateTime && schema[columnIndex].type !== FieldType.Interval)) {
    return null;
  }

  return typeof schema[columnIndex].enableUTC !== 'undefined' ? schema[columnIndex].enableUTC : getConfig('enableUTC');
}

function searchPattern({ search, searchText, rowData, row, isGlobalSearch }, exactMatch, containsData) {
  //if searchText is regex
  if(searchText.test && isGlobalSearch) {
    if(searchText.test(rowData)) {
      exactMatch.push(row);
      return true;
    }
    return false;
  } 
  const lowerSearchText = searchText && searchText.toLowerCase(), lowerRowData = rowData.toString().toLowerCase();
  if(search){
    switch(search.type){
      case 'start': 
        if(lowerRowData.slice(0, search.text.length) === search.text ){
          exactMatch.push(row);
          return true;
        }
        break;
      case 'end' :
        if(lowerRowData.slice(lowerRowData.length - search.text.length, lowerRowData.length) === search.text ){
          exactMatch.push(row);
          return true;
        }
        break;
      case 'center' :
        if(lowerRowData.includes(search.text)) {
          exactMatch.push(row);
          return true;
        }
        break;
      default : break;
    }
  } else {
    if(lowerRowData === lowerSearchText){
      exactMatch.push(row);
      return true;
    } else if(lowerRowData.includes(lowerSearchText)){
      containsData.push(row);
      return true;
    }
  }
  return false;
}

export { columnIndexOf, columnMinValue, columnMaxValue, columnMinDiff, columnExtents, columnUnique, addColumnsSchema, addColumnsData, parseAndIndexData, createTableID, buildDateColumnsFormatter, parseData, indexData, isUTCEnabled, searchPattern };
