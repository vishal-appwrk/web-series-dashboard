// binary insertion sort is the best method for sorting small arrays: it does
// few compares, but can do data movement quadratic in the number of
// elements.
// [lo, hi) is a contiguous slice of a list, and is sorted via
// binary insertion.  This sort is stable.
// On entry, must have lo <= start <= hi, and that [lo, start) is already
// sorted (pass start == lo if you don't know!).

/**
 * Sort a relatively smaller array in a stable manner
 * By default this method will sort array of primitive types in ascending order if comparer is not provided
 * For non primitive type, comparer must be provided
 * @param {array} arr - array to sort
 * @param {function} comparer - comparer function to sort
 * @param {number} _lo - start index of array for sorting
 * @param {number} _hi - end index of aray for sorting
 * @param {number} _start - index to start comparison
 */
function binaryInsertionSort (arr, _comparer, _lo, _hi, _start) {
  let lo = _lo || 0,
    hi = _hi || arr.length,
    start = _start || lo + 1,
    comparer = _comparer;

  if (!comparer) {
    comparer = (a, b) => a - b; // default comparere is ascending order and for primitive type only
  }

  if (lo === start) {
    ++start;
  }

  for (; start < hi; ++start) {
    let l = lo,
      r = start,
      pivot = arr[r];

    /* Invariants:
          * pivot >= all in [lo, l).
          * pivot  < all in [r, start).
          * The second is vacuously true at the start.
      */

    do {
      let p = l + ((r - l) >> 1);
      if (comparer(pivot, arr[p]) < 0) {
        r = p;
      } else {
        l = p + 1;
      }
    } while (l < r);

    /* The invariants still hold, so pivot >= all in [lo, l) and
         pivot < all in [l, start), so pivot belongs at l.  Note
         that if there are elements equal to pivot, l points to the
         first slot after them -- that's why this sort is stable.
         Slide over to make room.
      */
    for (let p = start; p > l; --p) {
      arr[p] = arr[p - 1];
    }
    arr[l] = pivot;
  }
}

/**
 * Stable merge sort implementation. This sorting does not modify the original array.
 * @param {array} arr - array to sort
 * @param {function} _comparer - item comparison function
 * @return {array} - sorted array
 */
function mergeSort (arr, _comparer) {
  let comparer = _comparer,
    middle,
    leftSection,
    rightSection;
  if (arr.constructor !== Array) {
    throw new TypeError('Merge sort can only be applied on Array.');
  }

  if (arr.length === 1) {
    return arr;
  }

  if (!comparer) {
    comparer = (a, b) => a - b;
  }

  middle = Math.floor(arr.length / 2);
  leftSection = arr.slice(0, middle);
  rightSection = arr.slice(middle);

  return merge(mergeSort(leftSection, comparer), mergeSort(rightSection, comparer), comparer);
}

/**
 * Merge 2 arrays and returns the merged array
 * @param {array} leftSection - first array to merge
 * @param {array} rightSection - second array to merge
 * @param {function} comparer - item comparison function
 */
function merge (leftSection, rightSection, comparer) {
  let result = [],
    leftSecIndex = 0,
    rightSecIndex = 0;

  while (leftSecIndex < leftSection.length && rightSecIndex < rightSection.length) {
    if (comparer(leftSection[leftSecIndex], rightSection[rightSecIndex]) <= 0) {
      result.push(leftSection[leftSecIndex]);
      leftSecIndex++;
    } else {
      result.push(rightSection[rightSecIndex]);
      rightSecIndex++;
    }
  }

  return result.concat(leftSection.slice(leftSecIndex)).concat(rightSection.slice(rightSecIndex));
}

/**
 * This is an implementation of TimSort devised by Tim Peters for Python list.
 * This is the default sorting algorithm for Python, also this sorting is adopted in Java for non primitive object sorting starting from v7.
 * It's a stable and in-place hybrid sorting algorithm, which runs quite fast for real world data.
 *
 * Original documentation by Time Peters : https://svn.python.org/projects/python/trunk/Objects/listsort.txt
 * Original source code : https://github.com/python/cpython/blob/master/Objects/listobject.c
 *
 * Also part of the project refers to an existing JavaScript implementation of TimSort - https://github.com/mziccard/node-timsort
 */

/**
 * minimum size of a run
 */
const MINRUN_LENGTH = 64,

  /**
 * When we get into galloping mode, we stay there until both runs win less
 * often than MIN_GALLOP_LENGTH consecutive times.
 */
  MIN_GALLOP_LENGTH = 7,

  /**
 * Default temp storage length.
 */
  DEFAULT_TMP_STORAGE_LEN = 256,

  /**
   * Max stack size
   */
  MAX_STACK_SIZE = 40;

/**
 * Reverse a slice of a list in place, from lo up to (exclusive) hi.
 * @param {*} arr - array
 * @param {*} _lo - lo index
 * @param {*} _hi - hi index
 */
function reverseSlice (arr, _lo, _hi) {
  let hi = _hi,
    lo = _lo;
  --hi;
  while (lo < hi) {
    let temp = arr[lo];
    arr[lo++] = arr[hi];
    arr[hi--] = temp;
  }
}

/**
Return the length of the run beginning at lo, in the slice [lo, hi).  lo < hi
is required on entry.  "A run" is the longest ascending sequence, with
  lo[0] <= lo[1] <= lo[2] <= ...
or the longest descending sequence, with
  lo[0] > lo[1] > lo[2] > ...

  For its intended use in a stable mergesort, the strictness of the defn of
"descending" is needed so that the caller can safely reverse a descending
sequence without violating stability (strict > ensures there are no equal
elements to get out of order).

If it's strictly descending then reverse the array.

* @param {array} arr - array
* @param {function} comparer - comparer function
* @param {number} lo - lo index
* @param {number} hi - hi index
*/
function countRun (arr, comparer, lo, hi) {
  let endIndex = lo + 1;
  if (endIndex === hi) {
    return 1;
  }

  // if strictly descending
  if (comparer(arr[endIndex++], arr[lo]) < 0) {
    while (endIndex < hi && comparer(arr[endIndex], arr[endIndex - 1]) < 0) {
      endIndex++;
    }

    reverseSlice(arr, lo, endIndex);
  } else { // if ascending
    while (endIndex < hi && comparer(arr[endIndex], arr[endIndex - 1]) >= 0) {
      endIndex++;
    }
  }

  return endIndex - lo;
}

/**
* Compute a good value for the minimum run length; natural runs shorter
* than this are boosted artificially via binary insertion.
*
* If n < 64, return n (it's too small to bother with fancy stuff).
* Else if n is an exact power of 2, return 32.
* Else return an int k, 32 <= k <= 64, such that n/k is close to, but
* strictly less than, an exact power of 2.
*
* @param {number} _n
*/
function mergeComputeMinrun (_n) {
  let r = 0,
    n = _n;

  while (n >= MINRUN_LENGTH) {
    r |= (n & 1);
    n >>= 1;
  }

  return n + r;
}

/**
 * Locate the proper position of key in a sorted vector; if the vector contains
 * an element equal to key, return the position immediately to the left of
 * the leftmost equal element. This ensures stability.
 *
 * @param {number} key - value to insert.
 * @param {array} arr - array
 * @param {number} start - first element in the range.
 * @param {number} length - length of the range.
 * @param {number} hint - index at which to begin the search.
 * @param {function} comparer - item comparison function.
 * @return {number} - index where to insert value.
 */
function gallopLeft (key, arr, start, length, hint, comparer) {
  let lastOffset = 0,
    maxOffset = 0,
    offset = 1, tmp, m;

  if (comparer(key, arr[start + hint]) > 0) {
    maxOffset = length - hint;

    /* a[start + hint] < key -- gallop right, until
    * a[start + hint + lastofs] < key <= a[start + hint + ofs]
    */
    while (offset < maxOffset && comparer(key, arr[start + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) { // overflow
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    // Translate back to offsets relative to start
    lastOffset += hint;
    offset += hint;
  } else {
    /* key <= a[start + hint] -- gallop left, until
    * a[start + hint - ofs] < key <= a[start + hint - lastofs]
    */
    maxOffset = hint + 1;
    while (offset < maxOffset && comparer(key, arr[start + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }

    // Translate back to positive offsets relative to start
    tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }

  /* Now a[start + lastofs] < key <= a[start + ofs], so key belongs somewhere to the
  * right of lastofs but no farther right than ofs.  Do a binary
  * search, with invariant a[start + lastofs - 1] < key <= a[start + ofs].
  */
  lastOffset++;
  while (lastOffset < offset) {
    m = lastOffset + ((offset - lastOffset) >>> 1);

    if (comparer(key, arr[start + m]) > 0) {
      lastOffset = m + 1;
    } else {
      offset = m;
    }
  }
  return offset;
}

/**
 * Exactly like gallopLeft(), except that if key already exists in arr[0:n],
 * finds the position immediately to the right of the rightmost equal value.
 *
 * @param {number} value - value to insert.
 * @param {array} arr - array in which to insert value.
 * @param {number} start - first element in the range.
 * @param {number} length - length of the range.
 * @param {number} hint - index at which to begin the search.
 * @param {function} comparer - item comparison function.
 * @return {number} - index where to insert value.
 */
function gallopRight (value, arr, start, length, hint, comparer) {
  let lastOffset = 0,
    maxOffset = 0,
    offset = 1, tmp, m;

  if (comparer(value, arr[start + hint]) < 0) {
    maxOffset = hint + 1;

    /* key < a[start + hint] -- gallop left, until
    * a[start + hint - ofs] <= key < a[start + hint - lastofs]
    */
    while (offset < maxOffset && comparer(value, arr[start + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    // Translate back to positive offsets relative to start
    tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length - hint;

    /* a[start + hint] <= key -- gallop right, until
    * a[start + hint + lastofs] <= key < a[start + hint + ofs]
    */
    while (offset < maxOffset && comparer(value, arr[start + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    // Translate back to offsets relative to
    lastOffset += hint;
    offset += hint;
  }

  /* Now a[start + lastofs] <= key < a[start + ofs], so key belongs somewhere to the
  * right of lastofs but no farther right than ofs.  Do a binary
  * search, with invariant a[start + lastofs-1] <= key < a[start + ofs].
  */
  lastOffset++;

  while (lastOffset < offset) {
    m = lastOffset + ((offset - lastOffset) >>> 1);

    if (comparer(value, arr[start + m]) < 0) {
      offset = m;
    } else {
      lastOffset = m + 1;
    }
  }

  return offset;
}

class MergeState {
  constructor (arr, comparer) {
    this.arr = arr;
    this.comparer = comparer;

    this.length = arr.length;

    this.tmpStorageLen = this.length < 2 * DEFAULT_TMP_STORAGE_LEN ? this.length >>> 1 : DEFAULT_TMP_STORAGE_LEN;

    this.tmp = new Array(this.tmpStorageLen);

    this.runBaseArr = new Array(MAX_STACK_SIZE);
    this.runLenArr = new Array(MAX_STACK_SIZE);

    this.minGallop = MIN_GALLOP_LENGTH;

    this.stackSize = 0;
  }

  /**
   * Push a new run on the stack
   *
   * @param {number} runStart - start index of the run in the original array
   * @param {number} runLength - length of the run
   */
  pushRun (runStart, runLength) {
    this.runBaseArr[this.stackSize] = runStart;
    this.runLenArr[this.stackSize] = runLength;
    this.stackSize++;
  }

  /**
   * Examine the stack of runs waiting to be merged, merging adjacent runs
   * until the stack invariants are re-established:
   * 1. runLenArr[i - 3] > runLenArr[i - 2] + runLenArr[i - 1]
   * 2. runLenArr[i - 2] > runLenArr[i - 1]
   */
  mergeCollapse () {
    let n;
    while (this.stackSize > 1) {
      n = this.stackSize - 2;

      if ((n >= 1 &&
        this.runLenArr[n - 1] <= this.runLenArr[n] + this.runLenArr[n + 1]) ||
        (n >= 2 &&
        this.runLenArr[n - 2] <= this.runLenArr[n] + this.runLenArr[n - 1])) {
        if (this.runLenArr[n - 1] < this.runLenArr[n + 1]) {
          n--;
        }
      } else if (this.runLenArr[n] > this.runLenArr[n + 1]) {
        break;
      }
      this.mergeAt(n);
    }
  }

  /**
   * Regardless of invariants, merge all runs on the stack until only one remains.
   * This is used at the end of the mergesort.
  */
  mergeForceCollapse () {
    let n;
    while (this.stackSize > 1) {
      n = this.stackSize - 2;

      if (n > 0 && this.runLenArr[n - 1] < this.runLenArr[n + 1]) {
        n--;
      }

      this.mergeAt(n);
    }
  }

  /**
   * Merge the two runs at stack indices i and i+1
   *
   * @param {number} i - index of the run to merge with next run
   */
  mergeAt (i) {
    let comparer = this.comparer,
      arr = this.arr,

      start1 = this.runBaseArr[i],
      length1 = this.runLenArr[i],
      start2 = this.runBaseArr[i + 1],
      length2 = this.runLenArr[i + 1], k;

    /* Record the length of the combined runs; if i is the 3rd-last
     * run now, also slide over the last run (which isn't involved
     * in this merge).  The current run i+1 goes away in any case.
     */
    this.runLenArr[i] = length1 + length2;

    if (i === this.stackSize - 3) {
      this.runBaseArr[i + 1] = this.runBaseArr[i + 2];
      this.runLenArr[i + 1] = this.runLenArr[i + 2];
    }

    this.stackSize--;

    /* Where does run2 starts in run1 i.e. first elemet in the second run position in run1?
     * Elements in run1 before that can be ignored (already in place)
     */
    k = gallopRight(arr[start2], arr, start1, length1, 0, comparer);
    start1 += k;
    length1 -= k;

    if (length1 === 0) {
      return;
    }

    /* Where does run1 ends in run2 i.e. last element of first run position in second run?
     * Elements in run2 after that can be ignored (already in place).
     */
    length2 = gallopLeft(arr[start1 + length1 - 1], arr, start2, length2, length2 - 1, comparer);

    if (length2 === 0) {
      return;
    }

    /* Merge what remains of the runs, using a temp array with
     * min(length1, length2) elements.
     */
    if (length1 <= length2) {
      this.mergeLo(start1, length1, start2, length2);
    } else {
      this.mergeHi(start1, length1, start2, length2);
    }
  }

  /**
   * Merge the length1 elements starting at start1 with the length2 elements starting at
   * start2 = start1 + length1 in a stable way, in-place. length1 and length2 must be > 0.
   * Should have length1 <= length2.
   *
   * @param {number} start1 - first index of run1
   * @param {number} length1 - length of run1
   * @param {number} start2 - first index of run2
   * @param {number} _length2 - length of run2.
   */
  mergeLo (start1, _length1, start2, _length2) {
    let i = 0, cursor1 = 0,
      cursor2 = start2,
      dest = start1, minGallop, count1, count2, exit,
      length1 = _length1,
      length2 = _length2;

    for (i = 0; i < length1; i++) {
      this.tmp[i] = this.arr[start1 + i];
    }

    this.arr[dest++] = this.arr[cursor2++];

    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        this.arr[dest + i] = this.tmp[cursor1 + i];
      }
      return;
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        this.arr[dest + i] = this.arr[cursor2 + i];
      }
      this.arr[dest + length2] = this.tmp[cursor1];
      return;
    }

    minGallop = this.minGallop;

    while (true) { // eslint-disable-line no-constant-condition
      count1 = 0; // number of times run1 won in a row
      count2 = 0; // number of times run2 won in a row
      exit = false;

      /* Do the straightforward thing until (if ever) one run
      * appears to win consistently.
      */
      do {
        if (this.comparer(this.arr[cursor2], this.tmp[cursor1]) < 0) {
          this.arr[dest++] = this.arr[cursor2++];
          count2++;
          count1 = 0;

          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          this.arr[dest++] = this.tmp[cursor1++];
          count1++;
          count2 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < minGallop);

      if (exit) {
        break;
      }

      /* One run is winning so consistently that galloping may
      * be a huge win.  So try that, and continue galloping until
      * (if ever) neither run appears to be winning consistently
      * anymore.
      */
      do {
        count1 = gallopRight(this.arr[cursor2], this.tmp, cursor1, length1, 0, this.comparer);

        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            this.arr[dest + i] = this.tmp[cursor1 + i];
          }

          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }

        this.arr[dest++] = this.arr[cursor2++];

        if (--length2 === 0) {
          exit = true;
          break;
        }

        count2 = gallopLeft(this.tmp[cursor1], this.arr, cursor2, length2, 0, this.comparer);

        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            this.arr[dest + i] = this.arr[cursor2 + i];
          }

          dest += count2;
          cursor2 += count2;
          length2 -= count2;

          if (length2 === 0) {
            exit = true;
            break;
          }
        }
        this.arr[dest++] = this.tmp[cursor1++];

        if (--length1 === 1) {
          exit = true;
          break;
        }

        minGallop--;
      } while (count1 >= MIN_GALLOP_LENGTH || count2 >= MIN_GALLOP_LENGTH);

      if (exit) {
        break;
      }

      if (minGallop < 0) {
        minGallop = 0;
      }

      minGallop += 2; /* penalize it for leaving galloping mode */
    }

    this.minGallop = minGallop;

    if (minGallop < 1) {
      this.minGallop = 1;
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        this.arr[dest + i] = this.arr[cursor2 + i];
      }
      this.arr[dest + length2] = this.tmp[cursor1];
    } else {
      for (i = 0; i < length1; i++) {
        this.arr[dest + i] = this.tmp[cursor1 + i];
      }
    }
  }

  /**
   * Merge the length1 elements starting at start1 with the length2 elements starting at
   * start2 = start1 + length1 in a stable way, in-place. length1 and length2 must be > 0.
   * Should have length1 >= length2.
   *
   * @param {number} start1 - first index of run1
   * @param {number} _length1 - length of run1
   * @param {number} start2 - first index of run2
   * @param {number} _length2 - length of run2.
   */
  mergeHi (start1, _length1, start2, _length2) {
    let i = 0, length1 = _length1, length2 = _length2, cursor1 = start1 + length1 - 1,
      cursor2 = length2 - 1,
      dest = start2 + length2 - 1,
      customCursor = 0,
      customDest = 0, minGallop, count1, count2, exit;

    for (i = 0; i < length2; i++) {
      this.tmp[i] = this.arr[start2 + i];
    }

    this.arr[dest--] = this.arr[cursor1--];

    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);

      for (i = 0; i < length2; i++) {
        this.arr[customCursor + i] = this.tmp[i];
      }

      return;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        this.arr[customDest + i] = this.arr[customCursor + i];
      }

      this.arr[dest] = this.tmp[cursor2];
      return;
    }

    minGallop = this.minGallop;

    while (true) { // eslint-disable-line no-constant-condition
      count1 = 0;
      count2 = 0;
      exit = false;

      do {
        if (this.comparer(this.tmp[cursor2], this.arr[cursor1]) < 0) {
          this.arr[dest--] = this.arr[cursor1--];
          count1++;
          count2 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          this.arr[dest--] = this.tmp[cursor2--];
          count2++;
          count1 = 0;
          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < minGallop);

      if (exit) {
        break;
      }

      do {
        count1 = length1 - gallopRight(this.tmp[cursor2], this.arr, start1, length1, length1 - 1, this.comparer);

        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = count1 - 1; i >= 0; i--) {
            this.arr[customDest + i] = this.arr[customCursor + i];
          }

          if (length1 === 0) {
            exit = true;
            break;
          }
        }

        this.arr[dest--] = this.tmp[cursor2--];

        if (--length2 === 1) {
          exit = true;
          break;
        }

        count2 = length2 - gallopLeft(this.arr[cursor1], this.tmp, 0, length2, length2 - 1, this.comparer);

        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;

          for (i = 0; i < count2; i++) {
            this.arr[customDest + i] = this.tmp[customCursor + i];
          }

          if (length2 <= 1) {
            exit = true;
            break;
          }
        }

        this.arr[dest--] = this.arr[cursor1--];

        if (--length1 === 0) {
          exit = true;
          break;
        }

        minGallop--;
      } while (count1 >= MIN_GALLOP_LENGTH || count2 >= MIN_GALLOP_LENGTH);

      if (exit) {
        break;
      }

      if (minGallop < 0) {
        minGallop = 0;
      }

      minGallop += 2;
    }

    this.minGallop = minGallop;

    if (minGallop < 1) {
      this.minGallop = 1;
    }

    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;

      for (i = length1 - 1; i >= 0; i--) {
        this.arr[customDest + i] = this.arr[customCursor + i];
      }

      this.arr[dest] = this.tmp[cursor2];
    } else {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        this.arr[customCursor + i] = this.tmp[i];
      }
    }
  }
}

/**
 * Sorts an array with the help of an comparer function.
 * This is an implementation of TimSort used in Python. It's stable and in place.
 *
 * @param {array} arr - array to sort
 * @param {function} comparer - item comparison function
 * @param {number} lo - index from which sorting will begin
 * @param {number} hi - end index of the range which will be sorted
 */
function timSort (arr, _comparer, _lo, _hi) {
  let lo = _lo,
    hi = _hi,
    comparer = _comparer,
    nremaining,
    n, minrun, mergeState, force;
  if (arr.constructor !== Array) {
    throw new TypeError('Sorting can only be applied on arrays.');
  }

  lo = lo || 0;
  hi = hi || arr.length;

  if (!comparer) {
    comparer = (a, b) => a - b;
  }

  nremaining = hi - lo;

  if (nremaining < 2) {
    return;
  }

  // On small arrays binary sort can be used directly
  if (nremaining < MINRUN_LENGTH) {
    n = countRun(arr, comparer, lo, hi);
    binaryInsertionSort(arr, comparer, lo, hi, lo + n);
    return;
  }

  minrun = mergeComputeMinrun(nremaining);
  mergeState = new MergeState(arr, comparer);

  do {
    n = countRun(arr, comparer, lo, lo + nremaining);

    /* If short, extend to min(minrun, nremaining). */
    if (n < minrun) {
      force = nremaining <= minrun ? nremaining : minrun;
      binaryInsertionSort(arr, comparer, lo, lo + force, lo + n);
      n = force;
    }

    mergeState.pushRun(lo, n);
    mergeState.mergeCollapse();

    nremaining -= n;
    lo += n;
  } while (nremaining !== 0);

  mergeState.mergeForceCollapse();
}

export default timSort;
export { binaryInsertionSort, mergeSort };
