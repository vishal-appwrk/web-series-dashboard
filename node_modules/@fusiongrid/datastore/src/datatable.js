import { columnIndexOf, columnMinValue, columnMaxValue, columnMinDiff, columnExtents, columnUnique, addColumnsSchema, addColumnsData, isUTCEnabled } from './utils/datatable-utils.js';
import { addHandler, triggerEvent, removeHandler } from './utils/event-handler.js';

let UNDEF;
export default class DataTable {
  constructor (dataStore, data, schema, config, parentTable, opsFunnel, id) {
    /// Property declaration

    // the data table object from where the DataTable is generated
    this._dataStore = dataStore;

    // the parent table from which this data table is generated
    this._parentTable = parentTable;

    // the children tables generated from this table
    this._children = [];
    // store the child table id(s), this is used to generate unique id
    this._childrenTableIDs = [];

    // set of operations which applied on the parent data table to create this data table
    this._opsFunnel = opsFunnel;

    // data for this data table, data will refer to the parent table's data if the funnel which generates this data table does not contain any schema changing operation and only updates the set of rows
    this._data = data || [];

    // schema of the data table
    this._schema = schema;

    // store the config object of the data table
    this._config = config;

    // id of the data table
    this._id = id;

    // ensure that id is always generated
    let counter = 1, baseID;
    if (!this._id) {
      baseID = this._parentTable && this._parentTable._id ? this._parentTable._id : 'table_1';
      this._id = baseID + '_' + counter;
    }

    if (this._parentTable) {
      // check for conflicting child table ids and create unique id if required
      while (this._parentTable._childrenTableIDs.includes(this._id)) {
        if (baseID) {
          this._id = baseID + '_' + ++counter;
        } else {
          this._id = this._id + '_1';
        }
      }

      // add this data table to the parent's children
      this._parentTable._children.push(this);
      this._parentTable._childrenTableIDs.push(this._id);
    }

    // the result set after executing the funnel/generatorFn
    this._result = null;
  }

  /**
   * Number of rows in the data table
   * @returns {number} total number of rows in the data table
   */
  count () {
    let result = this._executeFunnel();
    return result.data.length;
  }

  /**
   * Return the schema of the data table
   * @returns {array} array of column objects
   */
  getSchema () {
    let result = this._executeFunnel();
    return result.schema;
  }

  /**
   * Get the ID of this DataTable
   */
  getID () {
    return this._id;
  }

  /**
   * Return the original data table object from which the data table is generated
   * @returns {object}
   */
  getDataStore () {
    return this._dataStore;
  }

  /**
   * Get a child data table of the current datatable based on the id
   * @param {string} id - id of the child datatable to fetch
   * @returns instance of child datatable
   */
  getChildren (id) {
    if (id) {
      for (let i = 0; i < this._children.length; i++) {
        if (this._children[i]._id === id) {
          return this._children[i];
        }
      }
      return null;
    }
    return this._children;
  }

  /**
   * Get data starting from offset index, and number of items returned is denoted by numberOfItems
   *
   * @param {number} [_offset] - starting index of data to fetch, default is zero
   * @param {number} [_numberOfItems] - number of items to fetch, default is all items
   * @returns {object} - an object containing both data and schema
   */
  getData (_offset, _numberOfItems) {
    let offset = _offset,
      numberOfItems = _numberOfItems,
      result;
    // if no value is provided then offset is zero
    offset = offset || 0;

    // This check is only for numberOfItems is string, otherwise an undefined
    // numberOfItems is a valid second argument in array slice method
    // Also null as second parameter is invalid for array slice, hence if null
    // is passed it's converted to undefined
    numberOfItems = (numberOfItems && (typeof numberOfItems === 'string' || numberOfItems instanceof String)) || (numberOfItems === null) ? UNDEF : numberOfItems;

    // return value
    result = this._executeFunnel();

    return {
      data: result.data && result.data.slice(offset, numberOfItems && numberOfItems > 0 ? offset + numberOfItems : numberOfItems),
      schema: result.schema
    };
  }

  /**
   * Dispose the current data table and all tables derived from this data table
   */
  dispose () {
    let instance = this;

    // to remove instances of current table reference in parent table
    if (instance._parentTable && instance._parentTable._children) {
      let i;
      for (i = 0; i < instance._parentTable._children.length; i++) {
        if (typeof instance._id !== 'undefined' && instance._id === instance._parentTable._children[i]._id) {
          break;
        }
      }

      if (i !== instance._parentTable._children.length) {
        instance._parentTable._children.splice(i, 1);
      }
    }

    delete instance._dataStore;
    delete instance._parentTable;
    delete instance._opsFunnel;
    delete instance._data;
    delete instance._schema;
    delete instance._config;
    delete instance._result;
    delete instance._id;

    instance.disposeChildren();

    // and remove it
    delete instance._children;
    delete instance._childrenTableIDs;
    // fire the disposed event
    instance._trigger('disposed');

    // to remove all event handlers, this step is done after disposed event is triggered
    delete instance._evtHandlers;
    instance.disposed = true;
    instance = null;
  }

  disposeChildren () {
    let instance = this, childrenLength = (instance._children && instance._children.length) || 0;
    // call all children datatables' dispose in reverse order since children
    // removes its reference from parent through splicing the array
    for (let i = childrenLength - 1; i >= 0; i--) {
      instance._children[i].dispose();
    }
    // and remove it
    instance._children = [];
    instance._childrenTableIDs = [];
  }

  /**
   * Get the min value of a column
   * @param {string} columnName - name of the column
   * @returns {number|object} returns the minimum number of the column. In case of interval columns - interval with earliest start timestamp
   */
  min (columnName) {
    // retrieve the data
    // this step is necessary as this.data may contain the root data and only way to get valid data for the datatable is to call the getData method
    let dtData = this.getData();

    return columnMinValue(columnName, dtData.data, dtData.schema);
  }

  /**
   * Get the max value of a column
   * @param {string} columnName - name of the column
   * @returns {number|object} returns the maximum number of the column. In case of interval columns - interval with latest end timestamp
   */
  max (columnName) {
    // retrieve the data
    // this step is necessary as this.data may contain the root data and only way to get valid data for the datatable is to call the getData method
    let dtData = this.getData();

    return columnMaxValue(columnName, dtData.data, dtData.schema);
  }

  /**
   * Get unique values from a column
   * @param {string} columnName - name of the column
   * @returns {any} returns the unique elements of the column
   */
  unique (columnName) {
    // retrieve the data
    // this step is necessary as this.data may contain the root data and only way to get valid data for the datatable is to call the getData method
    let dtData = this.getData();

    return columnUnique(columnName, dtData.data, dtData.schema);
  }

  /**
   * Get peak values - max & min from a column
   * @param {string} columnName - name of the column
   * @returns {object} - an object containing both min and max value of the column. In case of interval column min is the earliest start timestamp and max is the latest end time stamp
   */
  extents (columnName) {
    // retrieve the data
    // this step is necessary as this.data may contain the root data and only way to get valid data for the datatable is to call the getData method
    let dtData = this.getData();

    return columnExtents(columnName, dtData.data, dtData.schema);
  }

  /**
   * Adds one or more columns to data table
   * @param  {...any} columnConfigs - array of columns to add
   */
  addColumns (...columnConfigs) {
    var columnConfigsLen = columnConfigs.length;

    if (columnConfigsLen > 0) {
      this._calcColumns = this._calcColumns || [];
      for (let i = 0; i < columnConfigsLen; i++) {
        if (!columnConfigs[i].name) throw new Error('name is required in column ' + (i + 1));
        if (columnConfigs[i].calcFn && !(columnConfigs[i].calcFn instanceof Function)) throw new Error('calcFn must be a function in column ' + (i + 1));

        if (!columnConfigs[i].calcFn) {
          columnConfigs[i].calcFn = () => { return UNDEF; };
        }

        // to ensure deep clone
        this._calcColumns.push(Object.assign({}, columnConfigs[i]));
      }
    }

    // trigger updated event
    this._trigger('updated', columnConfigs);
  }

  /**
   * Runs a single operation or a set of operations on the data table and creates a new data table
   * @param {any} _operations - an operation or array of operations
   * @returns {DataTable} the derived DataTable created from the current DataTable
   */
  query (_operations) {
    let operations = _operations,
      dataTable;
    if (operations && operations.constructor !== Array) {
      operations = [operations];
    }

    // for the new derived data table, data, schema, config reference is same
    // we are not concatenating the parent's funnel here as in executeFunnel method we are always executing parent's funnel before executing it's own
    dataTable = new DataTable(this._dataStore, this._data, this._schema, this._config, this, operations);

    return dataTable;
  }

  /**
   * Returns the 0 based index of the columnName in schema, if not found then -1 is returned
   * @param {*} columnName - name of the column
   * @returns {number}
   */
  indexOf (columnName) {
    let result = this._executeFunnel();
    return columnIndexOf(columnName, result.schema);
  }

  /**
   * Attach a handler function to an event
   * @param {string} eventName - name of the event to attach
   * @param {function} handlers - handler function to attach
   */
  on (eventName, handlers) {
    addHandler(eventName, handlers, this);
  }

  /**
   * Detach a handler from an event
   * @param {string} eventName - name of the event
   * @param {function} handlers - handler function to attach
   */
  off (eventName, handlers) {
    removeHandler(eventName, handlers, this);
  }

  _trigger (eventName, data) {
    triggerEvent(eventName, this, data);
  }

  /**
   * execute the data table's funnel and _calcColumns, and return data, schema, config
   * the result is cached for future use
   * if some operation invalidates the result then it must manually make the result field null
   */
  _executeFunnel () {
    if (!this._result) {
      if (this._opsFunnel) {
        let parentResult, data, schema, config, funnelLen;

        // run the parent funnel and then use the result for subsequent operations
        parentResult = this._parentTable._executeFunnel();
        data = parentResult.data.slice(0);
        schema = parentResult.schema.slice(0);
        config = Object.assign({}, parentResult.config);

        funnelLen = this._opsFunnel.length;
        // loop through the funnel and execute each funnel
        for (let i = 0; i < funnelLen; i++) {
          if (this._opsFunnel[i] && this._opsFunnel[i].fn) {
            let result = this._opsFunnel[i].fn(data, schema, config);
            data = result.generatorFn ? result.generatorFn() : result.data;
            schema = result.schema;
            config = Object.assign(config, result.config);
            if (typeof config.indexBy === 'undefined') config.enableIndex = false;
          }
        }
        this._result = {
          data,
          schema,
          config
        };
      } else {
        this._result = { data: this._data, schema: this._schema, config: this._config };
      }
    }

    // check if _calcColumns exists and if it has been executed
    if (this._calcColumns && this._calcColumns.length > 0) {
      // update the schema and data
      let columnConfigs = addColumnsSchema(this._result.schema, this._calcColumns);
      this._result.schema = columnConfigs.schema;
      // update the data
      this._result.data = addColumnsData(this._result.data, this._result.schema, columnConfigs.calcColumns);

      // after all processing, remove the property
      delete this._calcColumns;
    }

    return this._result;
  }

  /**
   * Clears any existing results from the table to ensure that the operations
   * funnel gets re-executed when required. Also invokes
   * DataTable#flushResults on child tables to clear their results as well.
   */
  flushResults () {
    let schemaLength = (this._result && this._result.schema.length) || 0,
      childrenLength = (this._children && this._children.length) || 0;

    // move calulated columns to _calcColumns
    if (schemaLength) this._calcColumns = [];
    for (let i = 0; i < schemaLength; i++) {
      if (this._result.schema[i].calcFn) {
        this._calcColumns.push(this._result.schema[i]);
      }
    }

    // if _result exists, clear it
    if (this._result) this._result = null;

    // call all children datatables' flushResults
    for (let i = 0; i < childrenLength; i++) {
      this._children[i].flushResults();
    }
  }

  /**
   * Propagate a payload to all data store
   * @param {object} payload - payload object to propagate
   */
  propagate (payload) {
    // send payload and trigger info to datastore
    this.getDataStore()._propagate({
      trigger: this,
      payload: payload
    });
  }

  _payloadReceiver (payload) {
    let childrenLength = (this._children && this._children.length) || 0;

    // ignore when trigger is itself (?)
    if (payload && payload.trigger && payload.trigger !== this) {
      // trigger event payloadReceived
      this._trigger('payloadReceived', payload);
    }

    // call child datatables' payloadReceivers
    for (let i = 0; i < childrenLength; i++) {
      this._children[i]._payloadReceiver(payload);
    }
  }

  getMinDiff (columnName) {
    // retrieve the data
    // this step is necessary as this.data may contain the root data and only way to get valid data for the datatable is to call the getData method
    let dtData = this.getData();

    return columnMinDiff(columnName, dtData.data, dtData.schema, this._config.indexBy);
  }

  /**
   * Get the enableUTC flag of the column or global.
   * @param {string} columnName name of the column
   */
  isUTCEnabled (columnName) {
    return isUTCEnabled(columnName, this.getSchema());
  }
}
