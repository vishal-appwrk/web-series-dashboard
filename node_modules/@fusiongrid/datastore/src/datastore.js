import DataTable from './datatable.js';
import { addHandler, triggerEvent, removeHandler } from './utils/event-handler.js';
import { parseAndIndexData, createTableID, buildDateColumnsFormatter, parseData, indexData, searchPattern } from './utils/datatable-utils.js';
import { numberIdentity } from './toolbox/src/index';
import { ROW_ID_COL_NAME } from './globals/defaults';
import { mergeSort } from './utils/sort.js';
import operate from './utils/condition-filter-operate';
import { filterSelectedData, getUniqueValues } from './utils/value-filter-utils';

export default class DataStore {
  /**
   * Create the DataStore
   * @constructor
   */
  constructor (data, schema, config) {
    // a key value pair of datatable id and datatable object
    this.dataTables = {};

    // a key value pair of datatable id ad unique datatable row id generator
    this._dataTableRowIdGenerator = {};

    // this basically points to the first data table that's created in the data store
    // this is needed for backward compatibility for existing samples
    // should be removed once the sample codes are changed
    this._defaultDataTable = null;

    this.sortRows = mergeSort;
    this.getUniqueValues = getUniqueValues;

    // Create internal unique id for the data store, simple time stamp is used for the unique id
    this._id = +new Date() + '';

    // This is a short hand to create the first datatable along with the schema
    if (Array.isArray(data) && Array.isArray(schema)) {
      this.createDataTable(data, schema, 'table-1', config);
    }
  }

  /**
   * Create a data table from data, schema and configuration
   * @param {array} data - 2D array or array of JSON objects containing the data
   * @param {array} schema - array of JSON objects defining the schema
   * @param {string} [id] - id of the table
   * @param {object} [config] - object with additional configuration
   * @returns {DataTable} created DataTable
   */
  createDataTable (data, schema, id, config) {
    if (!data || !schema) {
      throw new Error('Both data and schema must be provided to build DataTable');
    }

    if (data.constructor !== Array) {
      throw new Error('Data must be provided in 2D array format or array of json objects');
    }

    if (schema.constructor !== Array || schema.length === 0) {
      throw new Error('Input schema is not in a correct format - schema must be an array of column configurations');
    }

    let configObj = {}, dataTable, tableIdArr, tableId = id;

    tableIdArr = Object.keys(this.dataTables);

    if (tableId) {
      if (tableIdArr.includes(tableId)) {
        throw new Error('A table with the id ' + tableId + ' already exists in the DataStore. Please use a different id.');
      }
    } else {
      tableId = createTableID(tableIdArr);
    }

    // cloning the object so that the external config is not changed inside DataTable
    Object.assign(configObj, { enableIndex: false, enableUTC: false }, config);

    // unique row id generator for a datatable
    const row_id_generator = numberIdentity(),
      cloned_schema = schema.slice(); // to prevent mutate the schema while adding row id
    // save this row id generator for all future append rows operation
    this._dataTableRowIdGenerator[tableId] = row_id_generator;

    dataTable = new DataTable(
      this,
      parseAndIndexData(data, cloned_schema, configObj, row_id_generator),
      cloned_schema,
      configObj,
      null,
      null,
      tableId
    );

    if (tableIdArr.length === 0) {
      this._defaultDataTable = dataTable;
    }

    this.dataTables[tableId] = dataTable;

    return dataTable;
  }
  
  /**
   * parse rows for a DataTable inside DataStore.
   * @param {array} rows - 2D array or array of JSON object containing the data
   * @param {string} id - id of the table where rows will be inserted
   */
  parseRows(rows, id) {
    let dataTable = this.getDataTable(id);
    return parseData(
      rows,
      dataTable.getSchema(),
      null,
      this._dataTableRowIdGenerator[dataTable.getID()]
    );
  }

  /**
   * Append rows to a DataTable inside DataStore. All tables derived from the DataTable will be updated.
   * @param {array} rows - 2D array or array of JSON object containing the data
   * @param {string} id - id of the table where rows will be inserted
   */
  appendRows (rows, id) {
    // get the data table
    let dataTable = this.getDataTable(id),
      schema = dataTable.getSchema(),
      parsedRows,
      dateColumnsAndFormatter;

    // build date columns and formatter mapping
    dateColumnsAndFormatter = buildDateColumnsFormatter(schema);

    // parse the data
    parsedRows = parseData(
      rows,
      schema,
      dateColumnsAndFormatter,
      this._dataTableRowIdGenerator[dataTable.getID()]
    );

    // insert the parsed rows in data table data
    dataTable._data.push(...parsedRows);

    // perform indexing
    indexData(
      dataTable._data,
      schema,
      dataTable._config,
      dateColumnsAndFormatter
    );

    // propagate the event to all child data tables
    dataTable.flushResults();

    // fire tha itemAdded event
    this.trigger('itemsAdded', { rows: rows, parsedRows, tableID: id });
  }

  /**
   * Function to apply the value filter over the column values
   * @param {*} filterData - Array containing the details of filter
   * @param {*} id - datatable id
   */
  applyValueFilter(customData, filterData, id){
    // get the data table
    let dataTable = this.getDataTable(id),
      data = customData || dataTable._data,
      schema = dataTable._schema,
      dateColumnsAndFormatter,
      tempData = data;

    filterData.map((colDetails, index) => {
      tempData = filterSelectedData(tempData, index, colDetails.selectedValues);
      return true;
    });


    // build date columns and formatter mapping
    dateColumnsAndFormatter = buildDateColumnsFormatter(schema);

    // perform indexing
    indexData(
      tempData,
      schema,
      dataTable._config,
      dateColumnsAndFormatter
    );
    return tempData;
  }

  /**
   * Update row in a DataTable inside DataStore. All tables derived from the DataTable will be updated.
   * @param {array} row - array or JSON object containing the data
   * @param {number} index - index of the row that will be updated.
   */
  updateRow (index, row, id) {
    // get the data table
    let dataTable = this.getDataTable(id),
      schema = dataTable.getSchema(),
      parsedRows;

    parsedRows = parseData(
      [row],
      schema,
      null,
      this._dataTableRowIdGenerator[dataTable.getID()]
    );
    dataTable._data[index] = parsedRows[0];

    // perform indexing
    indexData(
      dataTable._data,
      schema,
      dataTable._config
    );

    // propagate the event to all child data tables
    dataTable.flushResults();

    // fire tha itemUpdated event
    this.trigger('itemUpdated', { row, parsedRows, tableID: id });
  }

  /**
   * Function to search rows as per search values for all column
   * @param {Array} colSearchValues 
   * @param {Number} id 
   * @param {Array} customData 
   */
  filterSearchRows(colSearchValues, id) {
    let dataTable = this.getDataTable(id),
      data = dataTable._data,
      filteredData = data;
    colSearchValues.map((col, index) => {
      if(col.text){
        filteredData = this.filterRows(index, col.text, id, filteredData);
      }
      return true;
    });

    return filteredData;
  }

  /* Function to get filtered rows as per search text
   * @param {Number} columnIndex 
   * @param {String} searchText 
   * @param {Number} id 
   * @param {Array} customData
   */
  filterRows (columnIndex, searchText, id, customData) {
    // get the data table
    let dataTable = this.getDataTable(id),
      data = customData || dataTable._data,
      schema = dataTable._schema,
      dateColumnsAndFormatter,
      filteredData = [],
      exactMatch = [],
      containsData = [],
      lowerSearchText = searchText && searchText.toLowerCase(),
      search = this.checkPatternSearch(lowerSearchText);

    if(searchText){
      data.map((row) => {
        searchPattern({ search, searchText, rowData: row[columnIndex], row }, exactMatch, containsData);
        return true;
      });

      filteredData = [...exactMatch, ...containsData];

      // build date columns and formatter mapping
      dateColumnsAndFormatter = buildDateColumnsFormatter(schema);

      // perform indexing
      indexData(
        filteredData,
        schema,
        dataTable._config,
        dateColumnsAndFormatter
      );
    } else {
      filteredData = dataTable._data;
    }

    return filteredData;
  }

  /**
   * Function to search text globally or as per column names/index provided
   * @param {Number} id 
   * @param {String} searchText 
   * @param {Array} columns 
   */
  globalSearch(id, searchText, columns) {
    // get the data table
    let dataTable = this.getDataTable(id),
      data = dataTable._data,
      schema = dataTable._schema,
      filteredData = [],
      exactMatch = [],
      containsData = [],
      dateColumnsAndFormatter,
      search = null,
      isGlobalSearch = true;
    if(!searchText.test) {
      search = this.checkPatternSearch(searchText.toLowerCase());
    }

    // If it is a Regex check
    data.map((row) => {
      // When columns array is given, then it is not a global serach
      if(columns && columns.length){
        let rowAdded = false;
        // For each column name given, check it index and then apply search in that particular column
        columns.map((col) => {
          // When column index is passed
          if(Number(col)){
            if(col < row.length){
              rowAdded = searchPattern({ search, searchText, row, rowData: row[col], isGlobalSearch }, exactMatch, containsData);
            }
          } // When field name is passed  
          else {
            let fieldIndex = schema.findIndex((sch) => sch.name === col);
            if(fieldIndex !== -1 && !rowAdded) {
              rowAdded = searchPattern({ search, searchText, row, rowData: row[fieldIndex], isGlobalSearch }, exactMatch, containsData);
            }
          }
          return true;
        });
      } // Perform global search
      else {
        row.some((rowData) => {
          return searchPattern({ search, searchText, row, rowData, isGlobalSearch }, exactMatch, containsData);
        });
      } 
      return true;
    });

    filteredData = [...exactMatch, ...containsData];

    // build date columns and formatter mapping
    dateColumnsAndFormatter = buildDateColumnsFormatter(schema);

    // perform indexing
    indexData(
      filteredData,
      schema,
      dataTable._config,
      dateColumnsAndFormatter
    );
    return filteredData;
  }

  // eslint-disable-next-line class-methods-use-this
  checkPatternSearch(searchText){
    let endTextPatternRegex = /^[^\*].*\*$/gm,
      startTextPatternRegex = /^\*.*[^\*]$/gm,
      midTextPatternRegex = /^\*.*\*$/gm;
      
    if(startTextPatternRegex.test(searchText)){
      return {
        type: 'end',
        text: searchText.slice(1, searchText.length)
      }; 
    } else if(endTextPatternRegex.test(searchText)){
      return {
        type: 'start',
        text: searchText.slice(0, searchText.length - 1)
      };
    } else if(midTextPatternRegex.test(searchText)){
      return {
        type: 'center',
        text: searchText.slice(1, searchText.length - 1)
      }; 
    }

    return null;
  }

  /**
   * 
   * @param {Array} customData - Optional data
   * @param {Array} conditionalFilterArray - 2D Array containing the conditions for each column
   * @param {Array} operator - Array containing the operator choice (currently 'AND' and 'OR' are supported)
   * @param {*} id - Datatable id 
   */
  applyConditionalFilter(customData, conditionalFilterArray, operator, id){
    // get the data table
    let dataTable = this.getDataTable(id),
      data = customData || dataTable._data,
      schema = dataTable._schema,
      dateColumnsAndFormatter,
      tempData = data,
      noConditionApplied = true;

    // Apply conditions on each row and update data accordingly
    conditionalFilterArray.map((conditionColumn, index) => {
      let filteredData = [];
      tempData.map((row) => {
        let value = row[index],
          conditionMatch = operator[index] === 'and' ? true : false;
        conditionColumn.map((filterObj) => {
          // eslint-disable-next-line no-undefined
          if((filterObj.value !== '' && filterObj.value !== undefined) || (filterObj.condition === 'is not empty' || filterObj.condition === 'is empty') ){
            let match = operate(filterObj.condition, schema[index], value, filterObj.value, filterObj.valueSecond);
            conditionMatch = operator[index] === 'and' ? conditionMatch && match : conditionMatch || match;
            noConditionApplied = false;
          }
          return true;
        });
  
        if(conditionMatch){
          filteredData.push(row);
        }
        return true;
      });

      tempData = filteredData;
      return true;
    });

    // If the condition array is empty then return primary data
    if(noConditionApplied){
      tempData = data;
    }

    // build date columns and formatter mapping
    dateColumnsAndFormatter = buildDateColumnsFormatter(schema);

    // perform indexing
    indexData(
      tempData,
      schema,
      dataTable._config,
      dateColumnsAndFormatter
    );
    return tempData;
  }

  /**
   * Deletes rows matching the provided query operation(s) from the table with
   * the provided ID.
   *
   * @param {object | object[]} operations The query operation(s) which, when
   * satisfied, will be used to delete the rows of the table.
   * @param {string} tableID The ID of the table from which the rows have to be
   * deleted.
   */
  deleteRows (operations, tableID) {
    const table = this.getDataTable(tableID),
      // Create a child table by applying the provided operations.
      queryTable = table.query(operations),
      { data: rows } = queryTable.getData(),
      tableRowID = table.indexOf(ROW_ID_COL_NAME),
      queryTableRowID = queryTable.indexOf(ROW_ID_COL_NAME),
      deletedRowIds = rows.map(row => row[queryTableRowID]);

    // Filter out all rows from the data of the table which do not need to be
    // deleted and set it as the data of the table.
    table._data = table._data.filter(
      row => !deletedRowIds.includes(row[tableRowID])
    );

    // Propagate the changes to child tables.
    table.flushResults();

    this.trigger('itemsRemoved', { rows, tableID });

    // Dispose the query table. Its work is complete.
    queryTable.dispose();
  }

  /**
   * Get instance of a DataTable object from it's id
   * @param {string} id - id of the table to fetch
   * @returns {DataTable}
   */
  getDataTable (id) {
    if (id) {
      if (!this.dataTables[id]) {
        throw new Error('DataTable with id ' + id + ' is not found in the DataStore.');
      }
      return this.dataTables[id];
    }
    return this._defaultDataTable;
  }

  /**
   * Attach a handler function to an event
   * @param {string} eventName - name of the event to attach
   * @param {function} handlers - handler function to attach to the event
   */
  on (eventName, handlers) {
    addHandler(eventName, handlers, this);
  }

  /**
   * Detach a handler function from an event
   * @param {string} eventName - name of the event to attach
   * @param {function} handlers - handler function to detach
   */
  off (eventName, handlers) {
    removeHandler(eventName, handlers, this);
  }

  /**
   * Triggers an event, optionally with some data
   * @param {string} eventName - name of the event to trigger
   * @param {*} [data] - optional data to send with the event
   */
  trigger (eventName, data) {
    triggerEvent(eventName, this, data);
  }

  /**
   * Disposes the DataStore and all DataTable contained in the DataStore or
   * derived from any of the tables in DataStore
   */
  dispose () {
    var instance = this;

    // call child datatable's dispose method
    for (let tableId in instance.dataTables) {
      if (instance.dataTables.hasOwnProperty(tableId)) { // eslint-disable-line no-prototype-builtins
        instance.dataTables[tableId].dispose();
        // remove the variable
        delete instance.dataTables[tableId];
      }
    }

    delete instance._id;

    // remove the object containing data tables
    delete instance.dataTables;

    delete instance._dataTableRowIdGenerator;

    delete instance._defaultDataTable;

    // fire the disposed event
    this.trigger('disposed');

    instance = null;
  }

  _propagate (payload) {
    var instance = this;

    // trigger event payload received
    this.trigger('payloadReceived', payload);

    // call child datatables' _payloadReceiver method
    for (const tableId in instance.dataTables) {
      if (instance.dataTables.hasOwnProperty(tableId)) { // eslint-disable-line no-prototype-builtins
        instance.dataTables[tableId]._payloadReceiver(payload);
      }
    }
  }
}
