import TimeFormatter from './time-formatter.js';
import TimeParser, { utcDate } from './time-parser.js';
import { timeSunday, timeMonday, timeThursday, timeDay, timeYear, } from '../../time-intervals/src/index';
import { utcSunday, utcMonday, utcThursday, utcDay, utcYear, } from '../../time-intervals/src/utc';
import enUS from './locales/en-US.js';

/**
 * @typedef {Object} LocaleDefinition Specifies locale specific formatting information.
 * @property {string} dateTime The date and time (%c) format specifier
 * @property {string} date The date  (%x) format specifier
 * @property {string} time The time (%X) format specifier
 * @property {Array<string>} periods The equivalents for AM and PM
 * @property {Array<string>} days Full names of the weekdays starting from Sunday
 * @property {Array<string>} shortDays Short names of the weekdays starting from Sunday
 * @property {Array<string>} months Full names of the months starting from January
 * @property {Array<string>} shortMonths Short names of the months starting from January
 */

const numberRe = /^\s*\d+/, // does not include percentages
  quarterRe = /^\s*Q\d+/,
  percentRe = /^%/,
  requoteRe = /[\\^$*+?|[\]().{}]/g,
  pad = (value, fill, width) => {
    const sign = value < 0 ? '-' : '',
      string = (sign ? -value : value) + '',
      length = string.length,
      padStr = length < width
        ? new Array(width - length + 1).join(fill) + string
        : string;

    return sign + padStr;
  },
  requote = s => s.replace(requoteRe, '\\$&'),
  formatRe = names => new RegExp('^(?:' + names.map(requote).join('|') + ')', 'i'),
  formatLookup = names => {
    let map = {},
      i = -1,
      n = names.length;

    while (++i < n) {
      map[names[i].toLowerCase()] = i;
    }

    return map;
  },
  parseWeekdayNumberSunday = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? ((d.w = +n[0]), i + n[0].length) : -1;
  },
  parseWeekdayNumberMonday = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? ((d.u = +n[0]), i + n[0].length) : -1;
  },
  parseWeekNumberSunday = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? ((d.U = +n[0]), i + n[0].length) : -1;
  },
  parseWeekNumberISO = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? ((d.V = +n[0]), i + n[0].length) : -1;
  },
  parseWeekNumberMonday = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? ((d.W = +n[0]), i + n[0].length) : -1;
  },
  parseQuarter = (d, string, i) => {
    var n = quarterRe.exec(string.slice(i, i + 2));
    return n ? ((d.m = (n[0][1] - 1) * 3), i + n[0].length) : -1;
  },
  parseFullYear = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? ((d.y = +n[0]), i + n[0].length) : -1;
  },
  parseYear = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? ((d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000)), i + n[0].length) : -1;
  },
  parseZone = (d, string, i) => {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? ((d.Z = n[1] ? 0 : -(n[2] + (n[3] || '00'))), i + n[0].length) : -1;
  },
  parseMonthNumber = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? ((d.m = n[0] - 1), i + n[0].length) : -1;
  },
  parseDayOfMonth = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? ((d.d = +n[0]), i + n[0].length) : -1;
  },
  parseDayOfYear = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? ((d.m = 0), (d.d = +n[0]), i + n[0].length) : -1;
  },
  parseHour24 = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? ((d.H = +n[0]), i + n[0].length) : -1;
  },
  parseMinutes = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? ((d.M = +n[0]), i + n[0].length) : -1;
  },
  parseSeconds = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? ((d.S = +n[0]), i + n[0].length) : -1;
  },
  parseMilliseconds = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? ((d.L = +n[0]), i + n[0].length) : -1;
  },
  parseMicroseconds = (d, string, i) => {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? ((d.L = Math.floor(n[0] / 1000)), i + n[0].length) : -1;
  },
  // eslint-disable-next-line
  parseLiteralPercent = (d, string, i) => {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  },
  parseUnixTimestamp = (d, string, i) => {
    var n = numberRe.exec(string.slice(i));
    return n ? ((d.Q = +n[0]), i + n[0].length) : -1;
  },
  parseUnixTimestampSeconds = (d, string, i) => {
    var n = numberRe.exec(string.slice(i));
    return n ? ((d.Q = (+n[0]) * 1000), i + n[0].length) : -1;
  },
  formatDayOfMonth = (d, p) => pad(d.getDate(), p, 2),
  formatHour24 = (d, p) => pad(d.getHours(), p, 2),
  formatHour12 = (d, p) => pad(d.getHours() % 12 || 12, p, 2),
  formatDayOfYear = (d, p) => pad(1 + timeDay.count(timeYear.floor(d), d), p, 3),
  formatMilliseconds = (d, p) => pad(d.getMilliseconds(), p, 3),
  formatMicroseconds = (d, p) => formatMilliseconds(d, p) + '000',
  formatMonthNumber = (d, p) => pad(d.getMonth() + 1, p, 2),
  formatMinutes = (d, p) => pad(d.getMinutes(), p, 2),
  formatSeconds = (d, p) => pad(d.getSeconds(), p, 2),
  formatQuarter = (d, p) => 'Q' + Math.ceil((d.getMonth() + 1) / 3),
  formatWeekdayNumberMonday = d => {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  },
  formatWeekNumberSunday = (d, p) => pad(timeSunday.count(timeYear.floor(d), d), p, 2),
  formatWeekNumberISO = (_d, p) => {
    var d = _d,
      day = d.getDay();
    d = day >= 4 || day === 0 ? timeThursday.floor(d) : timeThursday.ceil(d);
    return pad(timeThursday.count(timeYear.floor(d), d) + (timeYear.floor(d).getDay() === 4), p, 2);
  },
  formatWeekdayNumberSunday = d => d.getDay(),
  formatWeekNumberMonday = (d, p) => pad(timeMonday.count(timeYear.floor(d), d), p, 2),
  formatYear = (d, p) => pad(d.getFullYear() % 100, p, 2),
  formatFullYear = (d, p) => pad(d.getFullYear() % 10000, p, 4),
  formatZone = d => {
    var z = d.getTimezoneOffset();
    return (z > 0 ? '-' : ((z *= -1), '+')) + pad((z / 60) | 0, '0', 2) + pad(z % 60, '0', 2);
  },
  formatUTCDayOfMonth = (d, p) => pad(d.getUTCDate(), p, 2),
  formatUTCHour24 = (d, p) => pad(d.getUTCHours(), p, 2),
  formatUTCHour12 = (d, p) => pad(d.getUTCHours() % 12 || 12, p, 2),
  formatUTCDayOfYear = (d, p) => pad(1 + utcDay.count(utcYear.floor(d), d), p, 3),
  formatUTCMilliseconds = (d, p) => pad(d.getUTCMilliseconds(), p, 3),
  formatUTCMicroseconds = (d, p) => formatUTCMilliseconds(d, p) + '000',
  formatUTCMonthNumber = (d, p) => pad(d.getUTCMonth() + 1, p, 2),
  formatUTCMinutes = (d, p) => pad(d.getUTCMinutes(), p, 2),
  formatUTCSeconds = (d, p) => pad(d.getUTCSeconds(), p, 2),
  formatUTCQuarter = (d, p) => 'Q' + Math.ceil((d.getUTCMonth() + 1) / 3),
  formatUTCWeekdayNumberMonday = d => {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  },
  formatUTCWeekNumberSunday = (d, p) => pad(utcSunday.count(utcYear.floor(d), d), p, 2),
  formatUTCWeekNumberISO = (_d, p) => {
    var d = _d,
      day = d.getUTCDay();
    d = day >= 4 || day === 0 ? utcThursday.floor(d) : utcThursday.ceil(d);
    return pad(utcThursday.count(utcYear.floor(d), d) + (utcYear.floor(d).getUTCDay() === 4), p, 2);
  },
  formatUTCWeekdayNumberSunday = d => d.getUTCDay(),
  formatUTCWeekNumberMonday = (d, p) => pad(utcMonday.count(utcYear.floor(d), d), p, 2),
  formatUTCYear = (d, p) => pad(d.getUTCFullYear() % 100, p, 2),
  formatUTCFullYear = (d, p) => pad(d.getUTCFullYear() % 10000, p, 4),
  formatUTCZone = () => '+0000',
  formatLiteralPercent = () => '%',
  formatUnixTimestamp = d => +d,
  formatUnixTimestampSeconds = d => Math.floor(+d / 1000);

/**
 * A TimeConverter can be used to format and parse dates in a number of
 * locale specific representations. To create a converter, pass a locale
 * object when instantiating the TimeConverter.
 */
class TimeConverter {
  /**
   * Creates a TimeConverter instance with the given locale definition. It also internally
   * prepares locale specific formatting and parsing methods which is passed to
   * {@link TimeFormatter} and {@link TimeParser} when they are instantiated.
   *
   * @param {LocaleDefinition} locale The locale definition with which the TimeConverter
   * will be created
   */
  constructor (locale) {
    const {
        dateTime: localeDateTime,
        date: localeDate,
        time: localeTime,
        periods: localePeriods,
        days: localeWeekdays,
        shortDays: localeShortWeekdays,
        months: localeMonths,
        shortMonths: localeShortMonths
      } = locale,
      periodRe = formatRe(localePeriods),
      periodLookup = formatLookup(localePeriods),
      weekdayRe = formatRe(localeWeekdays),
      weekdayLookup = formatLookup(localeWeekdays),
      shortWeekdayRe = formatRe(localeShortWeekdays),
      shortWeekdayLookup = formatLookup(localeShortWeekdays),
      monthRe = formatRe(localeMonths),
      monthLookup = formatLookup(localeMonths),
      shortMonthRe = formatRe(localeShortMonths),
      shortMonthLookup = formatLookup(localeShortMonths);

    /**
     * @ignore
     */
    this._formats = {
      'a': d => localeShortWeekdays[d.getDay()],
      'A': d => localeWeekdays[d.getDay()],
      'b': d => localeShortMonths[d.getMonth()],
      'B': d => localeMonths[d.getMonth()],
      'd': formatDayOfMonth,
      'e': formatDayOfMonth,
      'f': formatMicroseconds,
      'H': formatHour24,
      'I': formatHour12,
      'j': formatDayOfYear,
      'L': formatMilliseconds,
      'm': formatMonthNumber,
      'M': formatMinutes,
      'p': d => localePeriods[+(d.getHours() >= 12)],
      'q': formatQuarter,
      'Q': formatUnixTimestamp,
      's': formatUnixTimestampSeconds,
      'S': formatSeconds,
      'u': formatWeekdayNumberMonday,
      'U': formatWeekNumberSunday,
      'V': formatWeekNumberISO,
      'w': formatWeekdayNumberSunday,
      'W': formatWeekNumberMonday,
      'y': formatYear,
      'Y': formatFullYear,
      'Z': formatZone,
      '%': formatLiteralPercent
    };

    /**
     * @ignore
     */
    this._utcFormats = {
      'a': d => localeShortWeekdays[d.getUTCDay()],
      'A': d => localeWeekdays[d.getUTCDay()],
      'b': d => localeShortMonths[d.getUTCMonth()],
      'B': d => localeMonths[d.getUTCMonth()],
      'd': formatUTCDayOfMonth,
      'e': formatUTCDayOfMonth,
      'f': formatUTCMicroseconds,
      'H': formatUTCHour24,
      'I': formatUTCHour12,
      'j': formatUTCDayOfYear,
      'L': formatUTCMilliseconds,
      'm': formatUTCMonthNumber,
      'M': formatUTCMinutes,
      'p': d => localePeriods[+(d.getUTCHours() >= 12)],
      'q': formatUTCQuarter,
      'Q': formatUnixTimestamp,
      's': formatUnixTimestampSeconds,
      'S': formatUTCSeconds,
      'u': formatUTCWeekdayNumberMonday,
      'U': formatUTCWeekNumberSunday,
      'V': formatUTCWeekNumberISO,
      'w': formatUTCWeekdayNumberSunday,
      'W': formatUTCWeekNumberMonday,
      'y': formatUTCYear,
      'Y': formatUTCFullYear,
      'Z': formatUTCZone,
      '%': formatLiteralPercent
    };

    /**
     * @ignore
     */
    this._parses = {
      'a': (d, string, i) => {
        const n = shortWeekdayRe.exec(string.slice(i));

        if (n) {
          d.w = shortWeekdayLookup[n[0].toLowerCase()];
          return i + n[0].length;
        }
        return -1;
      },
      'A': (d, string, i) => {
        const n = weekdayRe.exec(string.slice(i));

        if (n) {
          d.w = weekdayLookup[n[0].toLowerCase()];
          return i + n[0].length;
        }
        return -1;
      },
      'b': (d, string, i) => {
        const n = shortMonthRe.exec(string.slice(i));

        if (n) {
          d.m = shortMonthLookup[n[0].toLowerCase()];
          return i + n[0].length;
        }
        return -1;
      },
      'B': (d, string, i) => {
        const n = monthRe.exec(string.slice(i));

        if (n) {
          d.m = monthLookup[n[0].toLowerCase()];
          return i + n[0].length;
        }
        return -1;
      },
      'c': null,
      'd': parseDayOfMonth,
      'e': parseDayOfMonth,
      'f': parseMicroseconds,
      'H': parseHour24,
      'I': parseHour24,
      'j': parseDayOfYear,
      'L': parseMilliseconds,
      'm': parseMonthNumber,
      'M': parseMinutes,
      'p': (d, string, i) => {
        const n = periodRe.exec(string.slice(i));

        if (n) {
          d.p = periodLookup[n[0].toLowerCase()];
          return i + n[0].length;
        }
        return -1;
      },
      'Q': parseUnixTimestamp,
      'q': parseQuarter,
      's': parseUnixTimestampSeconds,
      'S': parseSeconds,
      'u': parseWeekdayNumberMonday,
      'U': parseWeekNumberSunday,
      'V': parseWeekNumberISO,
      'w': parseWeekdayNumberSunday,
      'W': parseWeekNumberMonday,
      'x': null,
      'X': null,
      'y': parseYear,
      'Y': parseFullYear,
      'Z': parseZone,
      '%': parseLiteralPercent
    };

    this._formats.x = d => new TimeFormatter(localeDate, this._formats).format(d);
    this._formats.X = d => new TimeFormatter(localeTime, this._formats).format(d);
    this._formats.c = d => new TimeFormatter(localeDateTime, this._formats).format(d);

    this._utcFormats.x = d => new TimeFormatter(localeDate, this._utcFormats).format(d);
    this._utcFormats.X = d => new TimeFormatter(localeTime, this._utcFormats).format(d);
    this._utcFormats.c = d => new TimeFormatter(localeDateTime, this._utcFormats).format(d);

    this._parses.c = (d, string, i) => {
      return new TimeParser(localeDateTime, this._parses).parseSpecifier(d, string, i);
    };
    this._parses.x = (d, string, i) => {
      return new TimeParser(localeDate, this._parses).parseSpecifier(d, string, i);
    };
    this._parses.X = (d, string, i) => {
      return new TimeParser(localeTime, this._parses).parseSpecifier(d, string, i);
    };
  }

  /**
   * Creates a time formatter for the given string specifier.
   *
   * @param {any} specifier The specifier which will be used by the
   * formatter to format a date into a string. It may contain the following directives:
   *
   * `%a` - abbreviated weekday name.
   *
   * `%A` - full weekday name.
   *
   * `%b` - abbreviated month name.
   *
   * `%B` - full month name.
   *
   * `%c` - the locale’s date and time, such as %x, %X.
   *
   * `%d` - zero-padded day of the month as a decimal number [01,31].
   *
   * `%e` - space-padded day of the month as a decimal number [ 1,31]; equivalent to %_d.
   *
   * `%f` - microseconds as a decimal number [000000, 999999].
   *
   * `%H` - hour (24-hour clock) as a decimal number [00,23].
   *
   * `%I` - hour (12-hour clock) as a decimal number [01,12].
   *
   * `%j` - day of the year as a decimal number [001,366].
   *
   * `%m` - month as a decimal number [01,12].
   *
   * `%M` - minute as a decimal number [00,59].
   *
   * `%L` - milliseconds as a decimal number [000, 999].
   *
   * `%p` - either AM or PM.
   *
   * `%Q` - milliseconds since UNIX epoch.
   *
   * `%s` - seconds since UNIX epoch.
   *
   * `%S` - second as a decimal number [00,61].
   *
   * `%u` - Monday-based (ISO 8601) weekday as a decimal number [1,7].
   *
   * `%U` - Sunday-based week of the year as a decimal number [00,53]. All days
   * in a new year preceding the first Sunday are considered to be in week 0.
   *
   * `%V` - ISO 8601 week of the year as a decimal number [01, 53]. Weeks start
   * on a Monday, and are numbered from 01, for the first week, up to 52 or 53,
   * for the last week. Week 1 is the first week where four or more days fall
   * within the new year. Basically, week 01 is the first week of the
   * year that contains a Thursday; or, the week that has 4 January in it.
   *
   * `%w` - Sunday-based weekday as a decimal number [0,6].
   *
   * `%W` - Monday-based week of the year as a decimal number [00,53]. All days
   * in a new year preceding the first Monday are considered to be in week 0.
   *
   * `%x` - the locale’s date, such as %-m/%-d/%Y.
   *
   * `%X` - the locale’s time, such as %-I:%M:%S %p.
   *
   * `%y` - year without century as a decimal number [00,99].
   *
   * `%Y` - year with century as a decimal number.
   *
   * `%Z` - time zone offset, such as -0700, -07:00, -07, or Z.
   *
   * `%%` - a literal percent sign (%)
   *
   * The directives `%a`, `%A`, `%b`, `%B`, `%c`, `%p`, `%x`, `%X` are affected by the
   * locale definition.
   *
   * @example
   * new TimeConverter(LocaleDefinition).formatter('%B %Y').format(new Date(2017, 3, 4)); // "April 2017"
   *
   * @returns {TimeFormatter} A TimeFormatter instance which is able to format a
   * JavaScript Date instance according to the given specifier string.
   */
  formatter (specifier = '') {
    return new TimeFormatter(specifier.toString(), this._formats);
  }

  /**
   * Same as {@link TimeConverter#formatter}, except that all directives are
   * interpreted as Coordinated Universal Time (UTC) rather than local time.
   *
   * @param {any} specifier The specifier which will be used by the formatter
   * to format a date into a string. It may contain the same directives as the
   * specifier passed to {@link TimeConverter#formatter}.
   *
   * @returns {TimeFormatter} A TimeFormatter instance which is able to format a
   * JavaScript Date instance according to the given specifier string.
   */
  utcFormatter (specifier = '') {
    return new TimeFormatter(specifier.toString(), this._utcFormats);
  }

  /**
   * Creates a time parser for the given string specifier.
   *
   * @param {string} _specifier The specifier which will be used by the parser
   * to parse a string into a date. It may contain the same directives as the
   * specifier passed to {@link TimeConverter#formatter}.
   *
   * @returns {TimeParser} A TimeParser instance which is able to **strictly** parse a
   * string according to the given specifier.
   */
  parser (_specifier) {
    let specifier = _specifier;
    return new TimeParser((specifier += ''), this._parses, d => {
      if (d.y >= 0 && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    });
  }

  /**
   * Same as {@link TimeConverter#parser}, except that all directives are
   * interpreted as Coordinated Universal Time (UTC) rather than local time.
   *
   * @param {string} _specifier The specifier which will be used by the parser
   * to parse a string into a date. It may contain the same directives as the
   * specifier passed to {@link TimeConverter#formatter}.
   *
   * @returns {TimeParser} A TimeParser instance which is able to **strictly** parse a
   * string according to the given specifier.
   */
  utcParser (_specifier) {
    let specifier = _specifier;
    return new TimeParser((specifier += ''), this._parses, utcDate);
  }
}

export { TimeConverter };

/**
 * An instance of {@link TimeConverter} initialized with the
 * English (United States) locale definition.
 * @type {TimeConverter}
 */
export default new TimeConverter(enUS);
