import pads from './pads.js';
import { timeDay, timeMonday } from '../../time-intervals/src/index';
import { utcDay, utcMonday } from '../../time-intervals/src/utc';

/**
 * @typedef {Object} DateObject Specifies numeric information about Date construction.
 * @property {number} y The full year
 * @property {number} m Zero based month of year
 * @property {number} d The day of month
 * @property {number} H Hour of day in 24-hour format
 * @property {number} M Minute of hour
 * @property {number} S Second of minute
 * @property {number} L Millisecond of second
 */

/**
 * @type {number}
 */
const PERCENT_CHAR_CODE = 37,
  BLANK = '',
  newYear = y => ({ y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0 }),
  utcDate = d => {
    if (d.y >= 0 && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  };

/**
 * A TimeParser is able to parse a string into a Javascript Date instance according
 * to the given specifier and locale specific parser functions.
 */
class TimeParser {
  /**
   * @param {string} specifier The specifier using which the parsrer will parse strings
   * @param {object} formats An object containing locale specific parsing functions
   * keyed by specifier directives.
   * @param {function} Date newDate A Date factory. When passed a
   * {@link DateObject}, returns a JavaScript Date instance created using it.
   */
  constructor (specifier, parses, newDate) {
    /**
     * @type {string}
     */
    this._specifier = specifier;
    /**
     * @type {object}
     */
    this._parses = parses;
    /**
     * @type {function}
     */
    this._newDate = newDate;
  }

  /**
   * Parses a specifier into dates
   *
   * @param {Date} d The Date to be used as a reference for parsing
   * @param {string} string The specifier to be parsed
   * @param {number} _j The index from which to parse the specifier
   *
   * @returns {number} Parsed information about the specifier. Returns
   * -1 if parsing was not possible,
   */
  parseSpecifier (d, string, _j) {
    var i = 0,
      n = this._specifier.length,
      m = string.length,
      c,
      j = _j,
      parse;

    while (i < n) {
      if (j >= m) return -1;
      c = this._specifier.charCodeAt(i++);
      if (c === PERCENT_CHAR_CODE) {
        c = this._specifier.charAt(i++);
        parse = this._parses[c in pads ? this._specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) {
          return -1;
        }
      } else if (c !== string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  /**
   * Parses a given string into a JavaScript Date instance according to the given specifier.
   *
   * @param {string} _string The string which will be parsed into a Javascript Date instance.
   *
   * @returns {Date} A JavaScript Date instance representing the given string.
   */
  parse (_string) {
    var d = newYear(1900),
      i,
      week,
      day,
      string = _string;

    string += BLANK;

    i = this.parseSpecifier(d, string, 0);

    if (i !== string.length) return null;

    // If a UNIX timestamp is specified, return it.
    if ('Q' in d) return new Date(d.Q);

    // The am-pm flag is 0 for AM, and 1 for PM.
    if ('p' in d) d.H = (d.H % 12) + d.p * 12;

    // Convert day-of-week and week-of-year to day-of-year.
    if ('V' in d) {
      // Can't deal with this
      if (d.V < 1 || d.V > 53) return null;

      if (!('w' in d)) d.w = 1;

      if ('Z' in d) {
        week = utcDate(newYear(d.y));
        day = week.getUTCDay();
        week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday.floor(week);
        week = utcDay.offset(week, (d.V - 1) * 7);

        d.y = week.getUTCFullYear();
        d.m = week.getUTCMonth();
        d.d = week.getUTCDate() + ((d.w + 6) % 7);
      } else {
        week = this._newDate(newYear(d.y));
        day = week.getDay();
        week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday.floor(week);
        week = timeDay.offset(week, (d.V - 1) * 7);

        d.y = week.getFullYear();
        d.m = week.getMonth();
        d.d = week.getDate() + ((d.w + 6) % 7);
      }
    } else if ('W' in d || 'U' in d) {
      if (!('w' in d)) {
        if ('u' in d) {
          d.w = d.u % 7;
        } else {
          d.w = 'W' in d ? 1 : 0;
        }
      }

      day = 'Z' in d
        ? utcDate(newYear(d.y)).getUTCDay()
        : this._newDate(newYear(d.y)).getDay();
      d.m = 0;
      d.d = 'W' in d
        ? ((d.w + 6) % 7) + d.W * 7 - ((day + 5) % 7)
        : d.w + d.U * 7 - ((day + 6) % 7);
    }

    // If a time zone is specified, all fields are interpreted as UTC and then
    // offset according to the specified time zone.
    if ('Z' in d) {
      d.H += (d.Z / 100) | 0;
      d.M += d.Z % 100;
      return utcDate(d);
    }

    // Otherwise, all fields are in local time.
    return this._newDate(d);
  }

  /**
   * @returns {string} The specifier string using which strings are parsed into Dates
   */
  toString () {
    return this._specifier;
  }
}

export { utcDate };
export default TimeParser;
