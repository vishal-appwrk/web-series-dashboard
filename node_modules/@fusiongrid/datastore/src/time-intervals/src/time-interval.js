let t0 = new Date(),
  t1 = new Date(),
  // The following variable is used to prevent UglifyJS from removing braces.
  // IE8 cannot handle do while loops nested within while loops unless they have
  // braces surrounding the code block.
  ie8Satisfier = 0; // eslint-disable-line no-unused-vars

const isNil = d => typeof d === 'undefined' || d === null;

class TimeInterval {
  constructor (name, floori, offseti, count, field) {
    this._name = name;
    this._floori = floori;
    this._offseti = offseti;
    this._count = count;
    this._field = field;
  }

  name () {
    return this._name;
  }

  floor (date) {
    const newDate = new Date(Number(date));

    this._floori(newDate);

    return newDate;
  }

  ceil (date) {
    const datei = new Date(date - 1);

    this._floori(datei);
    this._offseti(datei, 1);
    this._floori(datei);

    return datei;
  }

  round (date) {
    const d0 = this.floor(date),
      d1 = this.ceil(date);

    return date - d0 < d1 - date ? d0 : d1;
  }

  offset (date, step) {
    const datei = new Date(Number(date));

    this._offseti(datei, isNil(step) ? 1 : Math.floor(step));

    return datei;
  }

  range (start, stop, step) {
    const range = [],
      starti = this.ceil(start),
      stepi = isNil(step) ? 1 : Math.floor(step);

    let previous;

    if (!(starti < stop) || !(stepi > 0)) return range;

    do {
      previous = new Date(Number(starti));
      range.push(previous);
      this._offseti(starti, stepi);
      this._floori(starti);
    // eslint-disable-next-line no-unmodified-loop-condition
    } while (previous < starti && starti < stop);

    return range;
  }

  filter (test) {
    return new TimeInterval(
      this.name(),
      date => {
        if (!Number.isNaN(Number(date))) {
          // eslint-disable-next-line no-sequences
          while (this._floori(date), !test(date)) {
            date.setTime(date - 1);
          }
        }
      },
      (date, step) => {
        let stepi = step;

        if (!Number.isNaN(Number(date))) {
          if (stepi < 0) {
            while (++stepi <= 0) {
              ie8Satisfier++;
              do {
                this._offseti(date, -1);
              } while (!test(date));
            }
          } else {
            while (--stepi >= 0) {
              do {
                this._offseti(date, 1);
              } while (!test(date));
            }
          }
        }
      }
    );
  }

  count (start, end) {
    let count = 0;

    if (this._count) {
      t0.setTime(Number(start));
      t1.setTime(Number(end));

      this._floori(t0);
      this._floori(t1);

      count = Math.floor(this._count(t0, t1));
    }

    return count;
  }

  every (step) {
    const stepi = Math.floor(step);
    let everyInterval = null;

    if (!this._count || !Number.isFinite(stepi) || !(stepi > 0)) {
      everyInterval = null;
    } else if (!(stepi > 1)) {
      everyInterval = this;
    } else {
      everyInterval = this.filter(
        this._field
          ? d => this._field(d) % stepi === 0
          : d => this.count(0, d) % stepi === 0
      );
    }

    return everyInterval;
  }
}

export default TimeInterval;
