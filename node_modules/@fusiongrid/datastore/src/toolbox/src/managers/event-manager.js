class EventManager{
  constructor(config){
    let evtManager = this,
      events = config.events,
      evtListener,
      lowerCaseEvtName;
    this._context = config.context;
    this._evtListeners = {};
    // if events are provided during initialization
    if (events){
      for (let key in events){
        lowerCaseEvtName  = key.toLocaleLowerCase();
        if (!(evtListener = evtManager._evtListeners[lowerCaseEvtName])) {
          evtListener = evtManager._evtListeners[lowerCaseEvtName] = [];
        }
        if (typeof events[key] === 'function') {
          evtListener.push({
            handlerFn: events[key],
            context: this._context
          });
        }
      }
    }

    const preventDefaultHandler = function() {
        this.originalEvent && this.originalEvent.preventDefault();
      },

      stopPropagationHandler = function() {
        this.originalEvent && this.originalEvent.stopPropagation();
      };

    /**
       * Event dispatcher
       * @param {string} eventName the event name to be dsipatched
       * @param {object} eventObj the event payload
       * @param {EventListenerObject} eventObj the original event object
       * @param {object} explicitContext context fo the handler
       */
    this.dispatchEvent = function(eventName, payload, eventObj, explicitContext) {
      let sender = this,
        eventListeners = evtManager._evtListeners[eventName], // get all of that event
        eventData;
      if (eventListeners && eventListeners.length){
        // create event data
        eventData = {
          type: eventName, // name of the event
          originalEvent: eventObj, // original DOM event
          data: payload, // event payload
          sender, // sender component,
          preventDefault: preventDefaultHandler, // prevent default operation,
          stopPropagation: stopPropagationHandler // stop propagation operation
        };
        eventListeners.forEach((eventListener)=>{
          // call all the handlers of that event with proper data
          eventListener.handlerFn && eventListener.handlerFn.call(explicitContext || eventListener.context, eventData, payload);
        });
      }
    };
  }
  /**
     * Method to add a handler for a particular event
     * @param eventName string The name of the event 
     * @param handler function The handler function
     */
  addEventListener(eventName, handler){
    let _evtListeners = this._evtListeners,
      evtListener,
      evtName = eventName.toLowerCase();
    if (!(evtListener = _evtListeners[evtName])){
      evtListener = _evtListeners[evtName] = [];
    }
    if (typeof handler === 'function'){
      evtListener.push({
        handlerFn: handler,
        context: this._context
      });
    }
  }
  /**
     * Method to remove a particular handler for an event
     * @param eventName string The name of the event
     * @param handler function The handler function
     */
  removeEventListener(eventName, handler){
    let _evtListeners = this._evtListeners,
      evtListener = _evtListeners[eventName] || [],
      evtName = eventName.toLowerCase();
      // create a new listener array after excluding the concerned handler
    _evtListeners[evtName] = evtListener.filter(evtObj=>evtObj.handlerFn !== handler);
  }
  /**
     * Method to get all listeners currently stored by Event Manager 
     */
  getAllListeners(){
    return this._evtListeners;
  }
}
export default EventManager;