import * as timeIntervals from '../../time-intervals/src/index';
import * as timeIntervalsUTC from '../../time-intervals/src/utc';
import { DatetimeUnits, Weekdays } from '../../toolbox/src/index';
import TC from '../../time-converters/src/index';

const unitDefaultFormats = {
    'Year': '%Y', // 2018
    'Month': '%b %Y', // Jan 2018
    'Day': '%b %d, %Y', // Jan 01, 2018
    'Hour': '%b %d, %Y %H hrs', // Jan 01, 2018 23 hrs
    'Minute': '%b %d, %Y %H:%M', // Jan 01, 2018 23:34
    'Second': '%b %d, %Y %H:%M:%S', // Jan 01, 2018 23:34:26
    'Millisecond': '%b %d, %Y %H:%M:%S:%L' // Jan 01, 2018 23:34:26:123
  },
  timeIntervalMapping = {
    'Millisecond': timeIntervals.timeMillisecond,
    'Second': timeIntervals.timeSecond,
    'Minute': timeIntervals.timeMinute,
    'Hour': timeIntervals.timeHour,
    'Day': timeIntervals.timeDay,
    'Week': {
      0: timeIntervals.timeSunday,
      1: timeIntervals.timeMonday,
      2: timeIntervals.timeTuesday,
      3: timeIntervals.timeWednesday,
      4: timeIntervals.timeThursday,
      5: timeIntervals.timeFriday,
      6: timeIntervals.timeSaturday
    },
    'Month': timeIntervals.timeMonth,
    'Quarter': timeIntervals.timeQuarter,
    'Year': timeIntervals.timeYear
  },
  UTCTimeIntervalMapping = {
    'Millisecond': timeIntervalsUTC.utcMillisecond,
    'Second': timeIntervalsUTC.utcSecond,
    'Minute': timeIntervalsUTC.utcMinute,
    'Hour': timeIntervalsUTC.utcHour,
    'Day': timeIntervalsUTC.utcDay,
    'Week': {
      0: timeIntervalsUTC.utcSunday,
      1: timeIntervalsUTC.utcMonday,
      2: timeIntervalsUTC.utcTuesday,
      3: timeIntervalsUTC.utcWednesday,
      4: timeIntervalsUTC.utcThursday,
      5: timeIntervalsUTC.utcFriday,
      6: timeIntervalsUTC.utcSaturday
    },
    'Month': timeIntervalsUTC.utcMonth,
    'Quarter': timeIntervalsUTC.utcQuarter,
    'Year': timeIntervalsUTC.utcYear
  };

/**
 * Returns the default output format for a datetime unit.
 * @param {string} Unit The datetime unit
 */
function getDefaultOutputFormat (Unit) {
  switch (Unit) {
    case 'Millisecond':
    case 'Second':
    case 'Minute':
    case 'Hour':
    case 'Day':
    case 'Month':
    case 'Year':
      return unitDefaultFormats[Unit];
    case 'Week':
      return unitDefaultFormats.Day; // Day
    case 'Quarter':
      return unitDefaultFormats.Month; // Month
    default: 
      return null;
  }
}

/**
 * Returns the string output of datetime interval.
 */
function dateIntervalToString () {
  var specifier, config = this.config;

  specifier = (typeof config.enableUTC !== 'undefined' ? config.enableUTC : false) ? TC.utcFormatter(config.outputFormat) : TC.formatter(config.outputFormat);

  switch (config.duration.Unit) {
    case 'Millisecond':
    case 'Second':
    case 'Minute':
    case 'Hour':
    case 'Day':
    case 'Month':
    case 'Year':
      return specifier.format(new Date(this.start)) + (config.duration.number > 1 ? ' - ' + specifier.format(new Date(this.end - 1)) : '');
    case 'Week':
    case 'Quarter':
      return specifier.format(new Date(this.start)) + ' - ' + specifier.format(new Date(this.end - 1));
    default: 
      return null;
  }
}

/**
 * Returns the start and end timestamps, provided a start date and duration information.
 *
 * @param {number} start The given start date's timestamp
 * @param {object} duration The duration object defining the duration
 * @param {boolean} enableUTC The setting to enable/disable UTC
 * @param {object} weekStartFrom The weekday which will be considered as start of a week
 */
function dateRangeCaclulator (start, duration, enableUTC, weekStartFrom, calculateStart = false) {
  var startDate, endDate, durationCopy;
  startDate = start;
  if (calculateStart) {
    durationCopy = Object.assign({}, duration);
    durationCopy.number = 1;
    startDate = getDateStart(startDate, durationCopy, enableUTC, weekStartFrom);
  }
  endDate = getDateOffset(startDate, duration.Unit, duration.number, enableUTC, weekStartFrom);
  return { startDate: startDate, endDate: endDate };
}

/**
 * Get the floor value of the given date given the time unit.
 *
 * @param {number} date The date for which to get the start date
 * @param {object} duration The duration object
 * @param {boolean} enableUTC The setting to enable/disable UTC
 * @param {object} weekStartFrom The weekday which will be considered as start of a week
 * @param {number} start The start date wrt which, the provided date's binning start date will be calculated
 */
function getDateStart (date, duration, enableUTC, _weekStartFrom, start) {
  var timeIntervalObj = (typeof enableUTC !== 'undefined' ? enableUTC : false) ? UTCTimeIntervalMapping[duration.Unit] : timeIntervalMapping[duration.Unit],
    weekStartFrom = _weekStartFrom;

  if (weekStartFrom && !Weekdays[weekStartFrom.name]) throw new Error(`Invalid weekStartFrom provided: ${weekStartFrom}`);

  // for single/no binning, simply floor the provided date
  // for binnig of more than 1,
  //  if start value is not provided, use logical binning level
  //  else,
  //    get the count from the start to the provided date,
  //    find number by which date exceeds binning
  //    floor the date to single logical binning, and get previous using above number as offset
  if (duration.number === 1) {
    if (duration.Unit === 'Week') {
      weekStartFrom = weekStartFrom || Weekdays.Sunday;
      return +timeIntervalObj[weekStartFrom.id].floor(new Date(date));
    }
    return +timeIntervalObj.floor(new Date(date));
  } else if (!start) {
    if (duration.Unit === 'Week') {
      weekStartFrom = weekStartFrom || Weekdays.Sunday;
      return +timeIntervalObj[weekStartFrom.id].every(duration.number).floor(new Date(date));
    }
    return +timeIntervalObj.every(duration.number).floor(new Date(date));
  }
  let count, extraUnit;
  if (duration.Unit === 'Week') {
    weekStartFrom = weekStartFrom || Weekdays.Sunday;
    count = timeIntervalObj[weekStartFrom.id].count(start, date);
    extraUnit = count % duration.number;

    if (extraUnit) {
      return getDateOffset(+timeIntervalObj[weekStartFrom.id].floor(date), duration.Unit, -(extraUnit), enableUTC, weekStartFrom);
    }
    return +timeIntervalObj[weekStartFrom.id].floor(date);
  }
  count = timeIntervalObj.count(start, date);
  extraUnit = count % duration.number;

  if (extraUnit) {
    return getDateOffset(+timeIntervalObj.floor(date), duration.Unit, -(extraUnit), enableUTC, weekStartFrom);
  }
  return +timeIntervalObj.floor(date);
}

/**
 * Get the offset value of the given date given the time unit and the step count.
 *
 * @param {number} date The date for which to get the start date
 * @param {string} unit The datetime unit string
 * @param {number} offset The offset integer, postive or negative
 * @param {boolean} enableUTC The setting to enable/disable UTC
 * @param {object} weekStartFrom The weekday which will be considered as start of a week
 */
function getDateOffset (date, unit, offset, enableUTC, weekStartFrom) {
  // Calculate only for month, quarter and year which involves the uninform time unit 'month'
  // for rest, just add the miliseconds of the unit multiplied by offset times to the provided date
  switch (unit) {
    case 'Month':
    case 'Quarter':
    case 'Year':
      // eslint-disable-next-line no-case-declarations
      let timeIntervalObj = (typeof enableUTC !== 'undefined' ? enableUTC : false) ? UTCTimeIntervalMapping[unit] : timeIntervalMapping[unit];
      return +timeIntervalObj.offset(new Date(date), offset);

    default:
      return date + (DatetimeUnits[unit].ms * offset);
  }
}

export { getDefaultOutputFormat, dateIntervalToString, dateRangeCaclulator, getDateStart, getDateOffset };
