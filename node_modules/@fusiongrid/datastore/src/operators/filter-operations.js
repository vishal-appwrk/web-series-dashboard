import { leftMostExactOrGreater, rightMostExactOrLesser } from '../utils/sorted-search';
import { columnIndexOf } from '../utils/datatable-utils';
import { OperatorTypes, FieldType } from '../enums';
import { numberComparator } from '../toolbox/src/index';
import { getIndexColComparer } from './index-col-comparer';

/**
 * Get all rows between 2 values, this function assumes the column is already sorted
 * @param {number} columnIndex 0 based index of the column
 * @param {*} startVal start value
 * @param {*} endVal end value
 */
function indexColBetween (columnIndex, startVal, endVal, _comparer) {
  let start = startVal, end = endVal, comparer = _comparer;

  return {
    ops: 'indexColBetween',
    type: OperatorTypes.IndexOpsFilter,
    _updateArgs: (startLimit, endLimit) => {
      start = startLimit;
      end = endLimit;
    },
    fn: (_data, schema, config, generatorFn) => {
      if (!comparer) {
        comparer = getIndexColComparer(schema, columnIndex);
      }

      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        hiComparer = schema[columnIndex].type === FieldType.Interval ? (a, b) => numberComparator(a[columnIndex].end, b) : comparer,
        // find the left most element which is exactly equal to or just greater than the start
        loIndex = leftMostExactOrGreater(start, data, comparer, 0, data.length),
        // find the right most element which is exactly equal to or just less than the end
        hiIndex = rightMostExactOrLesser(end, data, hiComparer, loIndex, data.length);

      return {
        data,
        schema,
        config,
        generatorFn: () => { return data.slice(loIndex, hiIndex + 1); }
      };
    }
  };
}

/**
 * Get all rows between 2 values
 * @param {string} columnName - name of the column
 * @param {number} startVal - start value
 * @param {number} endVal - end value
 * @returns {array} - filtered data rows
 */
function between (columnName, startVal, endVal) {
  let start = startVal, end = endVal;

  return {
    ops: 'between',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (startLimit, endLimit) => {
      start = startLimit;
      end = endLimit;
    },
    fn: (_data, schema, config, generatorFn) => {
      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        columnIndex = columnIndexOf(columnName, schema);

      if (columnIndex >= 0) {
        let comparer = getIndexColComparer(schema, columnIndex);
        if (config && config.indexBy === columnName) {
          let indexOps = indexColBetween(columnIndex, start, end, comparer);
          return indexOps.fn(data, schema, config);
        }
        return {
          data,
          schema,
          config,
          generatorFn: () => { return data.filter(row => comparer(row, start) >= 0 && comparer(row, end) <= 0); }
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

/**
 * Get all rows where a column value is equal to a given value
 * @param {number} columnIndex index of the column
 * @param {*} val value to search with
 */
function indexColEquals (columnIndex, val, _comparer) {
  let valToCheck = val, comparer = _comparer;
  return {
    ops: 'indexColEquals',
    type: OperatorTypes.IndexOpsFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      if (!comparer) {
        comparer = getIndexColComparer(schema, columnIndex);
      }

      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        // find the left most element which is exactly equal to or just greater than the startVal
        loIndex = leftMostExactOrGreater(valToCheck, data, comparer, 0, data.length);

      // check if the match is an exact match otheriwse return blank array
      if (loIndex >= data.length || comparer(data[loIndex], valToCheck) !== 0) {
        return {
          data: [],
          schema,
          config
        };
      }

      // get the index of right most occurrence
      let hiIndex = rightMostExactOrLesser(valToCheck, data, comparer, loIndex, data.length);

      return {
        data,
        schema,
        config,
        generatorFn: () => { return data.slice(loIndex, hiIndex + 1); }
      };
    }
  };
}

/**
 * Get all rows where a column value is equal to a given value
 * @param {string} columnName - name of the column
 * @param {number | string} val - value to filter with
 * @returns {array} - filtered data rows
 */
function equals (columnName, val) {
  let valToCheck = val;
  return {
    ops: 'equals',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        columnIndex = columnIndexOf(columnName, schema);

      if (columnIndex >= 0) {
        let comparer = getIndexColComparer(schema, columnIndex);
        if (config && config.indexBy === columnName) {
          let indexOps = indexColEquals(columnIndex, valToCheck, comparer);
          return indexOps.fn(data, schema, config);
        }
        return {
          data,
          schema,
          config,
          generatorFn: () => { return data.filter(row => comparer(row, valToCheck) === 0); }
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

/**
 * Get all rows where a column value is less than a given value
 * @param {number} columnIndex index of the column
 * @param {*} val value to check with
 */
function indexColLess (columnIndex, val, _comparer) {
  let valToCheck = val, comparer = _comparer;
  return {
    ops: 'indexColLess',
    type: OperatorTypes.IndexOpsFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      if (!comparer) {
        comparer = getIndexColComparer(schema, columnIndex);
      }
      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        // get the index of right most occurrence
        pos = leftMostExactOrGreater(valToCheck, data, comparer, 0, data.length);

      return {
        data,
        schema,
        config,
        generatorFn: () => { return data.slice(0, pos); }
      };
    }
  };
}

/**
 * Get all rows less than a given value
 * @param {string} columnName - name of the column
 * @param {number} val - value to check
 * @returns {array} - filtered data rows
 */
function less (columnName, val) {
  let valToCheck = val;
  return {
    ops: 'less',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        columnIndex = columnIndexOf(columnName, schema);

      if (columnIndex >= 0) {
        let comparer = getIndexColComparer(schema, columnIndex);
        if (config && config.indexBy === columnName) {
          let indexOps = indexColLess(columnIndex, valToCheck, comparer);
          return indexOps.fn(data, schema, config);
        }
        return {
          data,
          schema,
          config,
          generatorFn: () => { return data.filter(row => comparer(row, valToCheck) < 0); }
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

/**
 * Get all rows where a column value is less than a given value
 * @param {number} columnIndex index of the column
 * @param {*} val value to check with
 */
function indexColLessEquals (columnIndex, val, _comparer) {
  let valToCheck = val, comparer = _comparer;
  return {
    ops: 'indexColLessEquals',
    type: OperatorTypes.IndexOpsFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      if (!comparer) {
        comparer = getIndexColComparer(schema, columnIndex);
      }

      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        // get the index of right most occurrence
        pos = rightMostExactOrLesser(valToCheck, data, comparer, 0, data.length);

      return {
        data,
        schema,
        config,
        generatorFn: () => { return data.slice(0, pos + 1); }
      };
    }
  };
}

/**
 * Get all rows less than a given value
 * @param {string} columnName - name of the column
 * @param {number} val - value to check
 * @returns {array} - filtered data rows
 */
function lessEquals (columnName, val) {
  let valToCheck = val;
  return {
    ops: 'lessEquals',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        columnIndex = columnIndexOf(columnName, schema);

      if (columnIndex >= 0) {
        let comparer = getIndexColComparer(schema, columnIndex);
        if (config && config.indexBy === columnName) {
          let indexOps = indexColLessEquals(columnIndex, valToCheck, comparer);
          return indexOps.fn(data, schema, config);
        }
        return {
          data,
          schema,
          config,
          generatorFn: () => { return data.filter(row => comparer(row, valToCheck) <= 0); }
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

/**
 * Get all rows where a column value is greater than a given value
 * @param {number} columnIndex index of the column
 * @param {*} val value to check with
 */
function indexColGreater (columnIndex, val, _comparer) {
  let valToCheck = val, comparer = _comparer;

  return {
    ops: 'indexColGreater',
    type: OperatorTypes.IndexOpsFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      if (!comparer) {
        comparer = getIndexColComparer(schema, columnIndex);
      }

      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        // get the index of right most occurrence
        pos = rightMostExactOrLesser(valToCheck, data, comparer, 0, data.length),
        nullPos = leftMostExactOrGreater(null, data, comparer, pos, data.length);

      return {
        data,
        schema,
        config,
        generatorFn: () => { return data.slice(pos + 1, nullPos); }
      };
    }
  };
}

/**
 * Get all rows greater than a given value
 * @param {string} columnName - name of the column
 * @param {number} val - value to check
 * @returns {array} - filtered data rows
 */
function greater (columnName, val) {
  let valToCheck = val;
  return {
    ops: 'greater',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        columnIndex = columnIndexOf(columnName, schema);

      if (columnIndex >= 0) {
        let comparer = getIndexColComparer(schema, columnIndex);
        if (config && config.indexBy === columnName) {
          let indexOps = indexColGreater(columnIndex, valToCheck, comparer);
          return indexOps.fn(data, schema, config);
        }
        return {
          data,
          schema,
          config,
          generatorFn: () => { return data.filter(row => row[columnIndex] !== null && typeof row[columnIndex] !== 'undefined' && comparer(row, valToCheck) > 0); }
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

/**
 * Get all rows where a column value is greater than a given value
 * @param {number} columnIndex index of the column
 * @param {*} val value to check with
 */
function indexColGreaterEquals (columnIndex, val, _comparer) {
  let valToCheck = val, comparer = _comparer;
  return {
    ops: 'indexColGreaterEquals',
    type: OperatorTypes.IndexOpsFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      if (!comparer) {
        comparer = getIndexColComparer(schema, columnIndex);
      }

      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        // get the index of right most occurrence
        pos = leftMostExactOrGreater(valToCheck, data, comparer, 0, data.length),
        nullPos = leftMostExactOrGreater(null, data, comparer, pos, data.length);

      return {
        data,
        schema,
        config,
        generatorFn: () => { return data.slice(pos, nullPos); }
      };
    }
  };
}

/**
 * Get all rows greater than a given value
 * @param {string} columnName - name of the column
 * @param {number} val - value to check
 * @returns {array} - filtered data rows
 */
function greaterEquals (columnName, val) {
  let valToCheck = val;
  return {
    ops: 'greaterEquals',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        columnIndex = columnIndexOf(columnName, schema);

      if (columnIndex >= 0) {
        let comparer = getIndexColComparer(schema, columnIndex);
        if (config && config.indexBy === columnName) {
          let indexOps = indexColGreaterEquals(columnIndex, valToCheck, comparer);
          return indexOps.fn(data, schema, config);
        }
        return {
          data,
          schema,
          config,
          generatorFn: () => { return data.filter(row => row[columnIndex] !== null && typeof row[columnIndex] !== 'undefined' && comparer(row, valToCheck) >= 0); }
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

export { indexColBetween, between, indexColEquals, equals, indexColLess, less, indexColLessEquals, lessEquals, indexColGreater, greater, indexColGreaterEquals, greaterEquals };
