import { OperatorTypes, FieldType } from '../enums';
import { columnIndexOf } from '../utils/datatable-utils';
import { getIndexColComparer, getComparer } from './index-col-comparer';
import { leftMostExactOrGreater, rightMostExactOrLesser } from '../utils/sorted-search';

/**
 * Get all rows where a particular column value matches any of the value in a given array
 * @param {string} columnName Name of the column
 * @param {array} values Array of values to search for
 * @param {function} [_comparer] The comparer function
 */
function indexColIN(columnIndex, values, _comparer) {
  let valueArr = values, comparer = _comparer;
  return {
    ops: 'indexColIN',
    type: OperatorTypes.IndexOpsFilter,
    _updateArgs: (newValues) => {
      valueArr = newValues;
    },
    fn: (_data, schema, config, generatorFn) => {
      let genFn;
      const data = typeof generatorFn === 'function' ? generatorFn() : _data;

      genFn = () => {
        let loIndex, hiIndex, sortedValues, result;
        if (!comparer) {
          comparer = getIndexColComparer(schema, columnIndex, true); // IN operation should be case sensitive
        }

        // sort the compare values
        sortedValues = valueArr.slice(0).sort(getComparer(schema[columnIndex].type === FieldType.Interval ? FieldType.Number : schema[columnIndex].type, true));

        hiIndex = -1;
        result = [];
        for (let i = 0; i < sortedValues.length; i++) {
          // find the start index
          // search will start from the next position of previously found match
          loIndex = leftMostExactOrGreater(sortedValues[i], data, comparer, hiIndex + 1, data.length);

          // check if the matched index is greater than array length, this indicates an end of search
          // as the entire array is sorted then it's safe to assume all subsequent search won't yield any result
          // hence break out of the loop
          if (loIndex >= data.length) {
            break;
          }

          // after searching the loIndex either the result is an exact match or the next greater match
          // search for the hiIndex only if it's an exact match
          if(comparer(data[loIndex], sortedValues[i]) === 0) {
            hiIndex = rightMostExactOrLesser(sortedValues[i], data, comparer, loIndex, data.length);
            result.push(...data.slice(loIndex, hiIndex + 1));
          }
          // if it's not an exact match then no point searching for the hiIndex and we should skip the unmatched value and continue the search for the next value
        }
        return result;
      };

      return {
        data,
        schema,
        config,
        generatorFn: genFn
      };
    }
  };
}


/**
 * Get all rows where a particular column value matches any of the value in a given array
 * @param {string} columnName Name of the column
 * @param {array} values Array of values to search for
 */
function IN (columnName, values) {
  let valueArr = values;

  return {
    ops: 'IN',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (newValues) => {
      valueArr = newValues;
    },
    fn: (_data, schema, config, generatorFn) => {
      if (!Array.isArray(valueArr)) {
        throw new Error('For the IN filter - search values must be an array');
      }

      const columnIndex = columnIndexOf(columnName, schema),
        data = typeof generatorFn === 'function' ? generatorFn() : _data;

      if (columnIndex >= 0) {
        // if filter operation is applied on any indexed column then perform the indexColIN operation
        if (config && config.indexBy === columnName) {
          let indexOps = indexColIN(columnIndex, valueArr);
          return indexOps.fn(data, schema, config);
        }
        return {
          data,
          schema,
          config,
          generatorFn: () => { return data.filter(row => valueArr.indexOf(row[columnIndex]) !== -1); }
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

export default IN;
export { indexColIN };
