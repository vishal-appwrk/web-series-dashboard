import { OperatorTypes } from '../enums';
import { leftMostExactOrGreater } from '../utils/sorted-search';
import { numberComparator } from '../toolbox/src/index';

/**
 * Applies logical OR on 2 the result of 2 operations and returns the result
 * @param {*} ops1 First operation
 * @param {*} ops2 Second operation
 */
function or (ops1, ops2) {
  return {
    ops: 'or',
    type: OperatorTypes.LogicalOps,
    fn: (_data, schema, config, generatorFn) => {
      if (!ops1 || !ops2) {
        throw new Error('2 operators needed for the OR operation');
      }

      if (typeof ops1.type === 'undefined' || typeof ops2.type === 'undefined') {
        throw new Error('Invlid operators are being used in OR operation');
      }

      if (ops1.type > 2 || ops2.type > 2) {
        throw new Error('Or operations can only be performed with filters or other logical operations');
      }

      const data = typeof generatorFn === 'function' ? generatorFn() : _data,
        genFn = () => {
          let ops1Data, ops2Data, largerTable, smallerTable, result, insertIndex, comparer, dataCopy = [], arrItem;
          // inserting the index of a row at the last position
          // this will be used later to find the proper position of a row after merging 2 results
          // note: we need to make a copy of this data otherwise mutating data will adversely affect on multiple chained operations
          for (let i = 0; i < data.length; i++) {
            arrItem = data[i].slice(0);
            arrItem.push(i);
            dataCopy.push(arrItem);
          }

          const ops1Fn = ops1.fn(dataCopy, schema, config),
            ops2Fn = ops2.fn(dataCopy, schema, config),
            indexPos = schema.length; // the position of the index column inserted in previous loop

          // execute both operation's funnels and retrieve the data
          ops1Data = typeof ops1Fn.generatorFn === 'function' ? ops1Fn.generatorFn() : ops1Fn.data;
          ops2Data = typeof ops2Fn.generatorFn === 'function' ? ops2Fn.generatorFn() : ops2Fn.data;

          // determine the larger table and smaller table
          // looping and checking over the smaller table will give performance benefit
          if (ops1Data.length >= ops2Data.length) {
            largerTable = ops1Data;
            smallerTable = ops2Data;
          } else {
            largerTable = ops2Data;
            smallerTable = ops1Data;
          }

          // take larger table as it is
          result = [ ...largerTable ];

          // comparer function to compare between index columns
          comparer = (a, b) => numberComparator(a[indexPos], b);
          insertIndex = -1;
          for (let i = 0; i < smallerTable.length; i++) {
            // find the index where a new row should be inserted
            insertIndex = leftMostExactOrGreater(smallerTable[i][indexPos], result, comparer, insertIndex + 1, result.length);

            if (insertIndex >= result.length) {
              // if insert index is greater than reult table then insert at last
              result.push(smallerTable[i]);
            } else if (result[insertIndex][indexPos] === smallerTable[i][indexPos]) {
              // if it's an exact match that means the record already exists
              // in the larger table hence already inserted into the resultant table
              continue;
            } else {
              // insert at correct index
              result.splice(insertIndex, 0, smallerTable[i]);
            }
          }

          // remove the last column from data array
          for (let i = 0; i < result.length; i++) {
            result[i].splice(result[i].length - 1, 1);
          }

          return result;
        };

      return {
        data,
        schema,
        config,
        generatorFn: genFn
      };
    }
  };
}

export default or;