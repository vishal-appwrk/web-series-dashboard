import { OperatorTypes } from '../enums/operator-type';
import { binaryInsertionSort } from '../utils/sort';

/**
 * Optimize the flow of operations while keeping the intended output same
 * @param  {...any} operations set of operations to optimize
 */
export default function pipe (...operations) {
  let opsLen, currentFunnel = [],
    markedForDel = [],
    resultFunnel = [],
    _optimizeGroupBetweenOps = (current, marked) => {
      let result = [],
        funnelLen = current.length;
      // loop over the current funnel and remove all select and sort operations
      for (let i = 0; i < funnelLen; i++) {
        if (!marked[i]) { // in result funnel only push operations which are not marked for deletion i.e. filter operations
          result.push(current[i]);
        }
      }

      // sort the filter operations, indexed filters are a priority over generic filters
      if (result && result.length > 0) {
        binaryInsertionSort(result, (a, b) => { return a.type - b.type; });
      }
      return result;
    },
    _optimizeEndOps = (current) => {
      let result = [],
        funnelLen = current.length;

      // At first sort the operations based on operations types
      // Here sorting does 2 job - place the filter operations at first with index filters preceding generic filters
      // and then place sort and select operations at the last. But if multiple sort or select operations are used by mistake
      // then sorting will place them together, making it easier to remove all select, sort except last
      // So, clearly we need a stable sort here
      binaryInsertionSort(current, (a, b) => { return a.type - b.type; });

      // push the first operation in stack for comparison
      result.push(current[0]);
      // start examining from the second element
      for (let i = 1; i < funnelLen; i++) {
        // Type 3 and 4 denotes sort and select respectively
        // For only sort and select operation if result funnel's last ops type is same as currently encountered ops type
        // then result funnel's last operations must be overridden with current operation
        // due to stable sorting of operations, all sort and select filters are placed together and only last ops of each type is valid
        // hence a linear search is performed, checking the last element each time, if the type matches then overrides the last element until there are no ops of same type left
        if (current[i].type >= 3 && current[i].type === result[result.length - 1].type) {
          result.pop();
        }
        result.push(current[i]);
      }

      return result;
    };

  // loop over all operations and check if the operation need to removed or reordered
  opsLen = operations.length;
  for (let i = 0; i < opsLen; i++) {
    switch (operations[i].type) {
      // if the operation is any kind of filter operation then they are never going to be removed, just pushed to current funnel stack for reordering
      case OperatorTypes.IndexOpsFilter:
      case OperatorTypes.GenericFilter:
      case OperatorTypes.LogicalOps:
        currentFunnel.push(operations[i]);
        markedForDel.push(false);
        break;
      // if the operation is select or sort operation then they will be removed if occurred between 2 group by operations
      case OperatorTypes.Select:
      case OperatorTypes.Sort:
        currentFunnel.push(operations[i]);
        markedForDel.push(true);
        break;
      case OperatorTypes.GroupBy:
        // if a group by is encountered then this is considered as a pivot point
        // all select and sort operations will be removed and filter operations are sorted - index filters are performed first then rest of the filters
        resultFunnel = resultFunnel.concat(_optimizeGroupBetweenOps(currentFunnel, markedForDel), operations[i]);
        // reset the current funnel and marked funnel stack as funnel stack before group by is already optimized and added to final result funnel
        currentFunnel = [];
        markedForDel = [];
        break;
      default:
        break;
    }
  }

  // At this point, all operations between every group by is optimized, only the last section i.e. from last group by till end
  // or if a group by is not present then from start to end are left with
  // All filter operations are pushed first with indexed filters as priority over geberic filter
  // Then sort operation is placed, if multiple sort operations are present then only the last sort is valid
  // Then select operayion is placed, if multiple select operations are present then only the last select is valid
  resultFunnel = resultFunnel.concat(_optimizeEndOps(currentFunnel));

  return resultFunnel;
}
