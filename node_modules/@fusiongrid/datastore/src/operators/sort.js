import { OperatorTypes, FieldType } from '../enums';
import { columnIndexOf } from '../utils/datatable-utils';
import { numberComparator, stringComparator } from '../toolbox/src/index';
import timSort from '../utils/sort';

let UNDEF;
/**
 * sorts the data table
 * @param {array} sortConfig - an array of sort configuration, number of items in array is equal to number of levels of sorting
 */
function sort (sortConfig) {
  let sortConfigArr = sortConfig;

  return {
    ops: 'sort',
    type: OperatorTypes.Sort,
    _updateArgs: (configArr) => {
      sortConfigArr = configArr;
    },
    fn: (_data, schema, config, generatorFn) => {
      let data = _data, postSortConfig, indexColumn;

      if (Array.isArray(sortConfigArr) && sortConfigArr.length) {
        // if there are multiple columns defined in sort array, choose only the first one for indexing
        // subsequent columns do not qualify for indexing
        indexColumn = sortConfigArr[0];
      } else if (typeof sortConfigArr === 'object') {
        indexColumn = sortConfigArr;
      }

      // set the sort column as indexed column if the sorting type is ascending
      // note: default sorting type is ascending
      if (typeof indexColumn !== 'undefined' && typeof indexColumn.column !== 'undefined' && (typeof indexColumn.order === 'undefined' || indexColumn.order === 'asc')) {
        postSortConfig = Object.assign(config || {}, {
          enableIndex: true,
          indexBy: indexColumn.column
        });
      } else if (typeof config === 'object') {
        // if user has provided any config object, then only reset index information
        // rest of the configuration should be unaffected
        postSortConfig = Object.assign(config, {
          enableIndex: false,
          indexBy: UNDEF
        });
      }

      return {
        data,
        schema,
        config: postSortConfig,
        generatorFn: () => {
          if (typeof generatorFn === 'function') {
            data = generatorFn();
          }

          let compareFn;

          if (sortConfigArr.constructor === Function) {
            compareFn = sortConfigArr;
          } else {
            if (sortConfigArr.constructor !== Array) {
              sortConfigArr = [sortConfigArr];
            }

            let comparatorFnArr = [], colIndexArr = [], i, colIndex, result;

            for (i = 0; i < sortConfigArr.length; i++) {
              if (sortConfigArr[i].column) {
                colIndex = columnIndexOf(sortConfigArr[i].column, schema);
                colIndexArr.push(colIndex);

                if (colIndex === -1) {
                  throw new Error('Sort column is not found in schema - ' + sortConfigArr[i].column);
                }

                switch (schema[colIndex].type) {
                  case FieldType.Number:
                  case FieldType.Interval:
                  case FieldType.DateTime:
                    comparatorFnArr.push(numberComparator);
                    break;
                  default:
                    comparatorFnArr.push(stringComparator);
                }
              }
            }

            compareFn = (a, b) => {
              for (i = 0; i < sortConfigArr.length; i++) {
                if (schema[colIndexArr[i]].type === FieldType.Interval) {
                  result = sortConfigArr[i].order === 'desc' ? comparatorFnArr[i](b[colIndexArr[i]].start, a[colIndexArr[i]].start) : comparatorFnArr[i](a[colIndexArr[i]].start, b[colIndexArr[i]].start);
                } else {
                  result = sortConfigArr[i].order === 'desc' ? comparatorFnArr[i](b[colIndexArr[i]], a[colIndexArr[i]]) : comparatorFnArr[i](a[colIndexArr[i]], b[colIndexArr[i]]);
                }

                if (result === 0) { // if exact match
                  if (i === sortConfigArr.length - 1) { // if current sort level is the last one then simply return 0, no swap will occur
                    return 0;
                  } continue; // if exact match is found but this is not the current level then further levels need to be evaluated
                } else { // if anything other than 0 then further evaluation is not needed
                  return result;
                }
              }
            };
          }

          timSort(data, compareFn);
          return data;
        }
      };
    }
  };
}

export default sort;
