import { OperatorTypes, FieldType } from '../enums';
import { columnIndexOf } from '../utils/datatable-utils';
import { escapeRegExp } from '../toolbox/src/string-utils/regex-utils';

/**
 * Returns all rows which contains a pattern string in a given column
 * @param {string} columnName name of the column
 * @param {string} val pattern to search
 * @param {boolean} [isCaseSensitive] if the search should be case sensitive, default is false i.e. case insensitive searching is performed
 */
function contains (columnName, val, isCaseSensitive = false) {
  let valToCheck = val;
  return {
    ops: 'contains',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      const escapedRegEx = escapeRegExp(valToCheck),
        regEx = isCaseSensitive ? new RegExp(escapedRegEx, 'u') : new RegExp(escapedRegEx, 'iu'),
        columnIndex = columnIndexOf(columnName, schema),
        data = typeof generatorFn === 'function' ? generatorFn() : _data,
        fn = () => { return data.filter(row => typeof row[columnIndex] === 'string' && regEx.test(row[columnIndex])); };

      if (columnIndex >= 0) {

        if (!(typeof schema[columnIndex].type === 'undefined' || schema[columnIndex].type === FieldType.String)) {
          throw new Error('Column \'' + columnName + '\' is not valid for contains operation. Contains operation can only be performed on string type columns.');
        }

        return {
          data,
          schema,
          config,
          generatorFn: fn
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

/**
 * Returns all rows which starts with a specific string in a given column
 * @param {string} columnName name of the column
 * @param {string} val pattern to search
 * @param {boolean} [isCaseSensitive] if the search should be case sensitive, default is false i.e. case insensitive searching is performed
 */
function startsWith (columnName, val, isCaseSensitive = false) {
  let valToCheck = val;
  return {
    ops: 'startsWith',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      const escapedRegEx = '^' + escapeRegExp(valToCheck),
        regEx = isCaseSensitive ? new RegExp(escapedRegEx, 'u') : new RegExp(escapedRegEx, 'iu'),
        columnIndex = columnIndexOf(columnName, schema),
        data = typeof generatorFn === 'function' ? generatorFn() : _data,
        fn = () => { return data.filter(row => typeof row[columnIndex] === 'string' && regEx.test(row[columnIndex])); };

      if (columnIndex >= 0) {

        if (!(typeof schema[columnIndex].type === 'undefined' || schema[columnIndex].type === FieldType.String)) {
          throw new Error('Column \'' + columnName + '\' is not valid for startsWith operation. startsWith operation can only be performed on string type columns.');
        }

        return {
          data,
          schema,
          config,
          generatorFn: fn
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

/**
 * Returns all rows which ends with a specific string in a given column
 * @param {string} columnName name of the column
 * @param {string} val pattern to search
 * @param {boolean} [isCaseSensitive] if the search should be case sensitive, default is false i.e. case insensitive searching is performed
 */
function endsWith (columnName, val, isCaseSensitive = false) {
  let valToCheck = val;
  return {
    ops: 'endsWith',
    type: OperatorTypes.GenericFilter,
    _updateArgs: (compareVal) => {
      valToCheck = compareVal;
    },
    fn: (_data, schema, config, generatorFn) => {
      const escapedRegEx = escapeRegExp(valToCheck) + '$',
        regEx = isCaseSensitive ? new RegExp(escapedRegEx, 'u') : new RegExp(escapedRegEx, 'iu'),
        columnIndex = columnIndexOf(columnName, schema),
        data = typeof generatorFn === 'function' ? generatorFn() : _data,
        fn = () => { return data.filter(row => typeof row[columnIndex] === 'string' && regEx.test(row[columnIndex])); };

      if (columnIndex >= 0) {

        if (!(typeof schema[columnIndex].type === 'undefined' || schema[columnIndex].type === FieldType.String)) {
          throw new Error('Column \'' + columnName + '\' is not valid for endsWith operation. endsWith operation can only be performed on string type columns.');
        }

        return {
          data,
          schema,
          config,
          generatorFn: fn
        };
      } throw new Error('Column \'' + columnName + '\' is not found in the schema.');
    }
  };
}

export { contains, startsWith, endsWith };