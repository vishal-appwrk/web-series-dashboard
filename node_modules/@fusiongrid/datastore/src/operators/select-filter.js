import { OperatorTypes } from '../enums/operator-type';
import { columnIndexOf } from '../utils/datatable-utils';

/**
 * Select a number of columns from the data table
 * @param {string[]} _columnNames - array of column names
 * @param {object} [_options] - an option object
 */
function select (_columnNames, _options) {
  let columnNames = _columnNames,
    options = _options;
  // If user provides only one column as argument, instead of an array of argument
  // Then make it a singe element array
  columnNames = columnNames && columnNames.constructor !== Array ? [columnNames] : columnNames;

  return {
    ops: 'select',
    type: OperatorTypes.Select,
    fn: (data, schema, config, generatorFn) => {
      let newSchema = [],
        selectedColIndices = [];

      if (columnNames) {
        let i;
        options = options || { exclude: false };
        if (options.exclude) {
          for (i = 0; i < schema.length; i++) {
            if (!columnNames.includes(schema[i].name)) {
              newSchema.push(schema[i]);
              selectedColIndices.push(i);
            }
          }
        } else {
          let foundIndex;
          for (i = 0; i < columnNames.length; i++) {
            foundIndex = columnIndexOf(columnNames[i], schema);
            if (foundIndex > -1 && !selectedColIndices.includes(foundIndex)) {
              newSchema.push(schema[foundIndex]);
              selectedColIndices.push(foundIndex);
            }
          }
        }
      } else {
        newSchema = schema;
      }
      return {
        data,
        schema: newSchema,
        config,
        generatorFn: () => {
          let selectedColLen = selectedColIndices.length;
          if (selectedColLen > 0) {
            let returnData = [], i, j, row;
            for (i = 0; i < data.length; i++) {
              row = [];
              for (j = 0; j < selectedColLen; j++) {
                row[j] = data[i][selectedColIndices[j]];
              }
              returnData[i] = row;
            }
            return returnData;
          }
          return data.slice(0);
        }
      };
    }
  };
}

function filter (fn) {
  return {
    ops: 'filter',
    type: OperatorTypes.GenericFilter,
    fn: (_data, schema, config, generatorFn) => {
      let data = _data;
      return {
        data,
        schema,
        config,
        generatorFn: () => {
          if (typeof generatorFn === 'function') {
            data = generatorFn();
          }

          // create the columns object which is basically a mapping between column name and index
          // as user will provide the filter fn as = (row, columns) => row[columns.Name] === 'val'
          let columns = {};
          for (let i = 0; i < schema.length; i++) {
            columns[schema[i].name] = i;
          }

          return data.filter(row => fn.call(this, row, columns));
        }
      };
    }
  };
}

export { select, filter };
