import { columnIndexOf, columnUnique, columnExtents } from '../utils/datatable-utils';
import aggregatorStore from '../aggregators';
import { getConfig } from '../globals/global-config';
import { OperatorTypes, FieldType } from '../enums';
import groupBy, { _singleSortedAddRow, _singleSortedAddRowDate } from './group-by';
import { leftMostExactOrGreater } from '../utils/sorted-search';
import { numberComparator, stringComparator } from '../toolbox/src/index';
import { getDateStart, duration, interval } from '../time-utils/src/index';

let UNDEF;
const EMPTY_STR = '';
/**
 * Performs pivot operation on current data table.
 *
 * @param {array} groupConfigArr - The group configuration array
 * @param {string} pivotColumn - The column name on which to pivot
 * @param {array} aggrConfigArr - The aggregation configuration array
 * @returns {array} - data rows after performing pivot operations
 */
function pivot (groupConfigArr, pivotColumn, aggrConfigArr) {
  let groupConfigArray = groupConfigArr, pivotCol = pivotColumn, aggrConfigArray = aggrConfigArr;

  return {
    ops: 'pivot',
    type: OperatorTypes.GroupBy,
    _updateArgs: (groupConfigurationArr, pivotColumnName, aggrConfigurationArr) => {
      groupConfigArray = groupConfigurationArr;
      pivotCol = pivotColumnName;
      aggrConfigArray = aggrConfigurationArr;
    },
    fn: (data, schema, config, generatorFn) => {
      if (groupConfigArray.length === 0) throw new Error('groupConfigArray cannot be empty');
      if (aggrConfigArray.length === 0) throw new Error('aggrConfigArray cannot be empty');
      if (!pivotCol) throw new Error('pivotCol cannot be empty');

      if (!(groupConfigArray instanceof Array) && groupConfigArray instanceof Object) {
        groupConfigArray = [groupConfigArray];
      }
      if (!(aggrConfigArray instanceof Array) && aggrConfigArray instanceof Object) {
        aggrConfigArray = [aggrConfigArray];
      }

      if (groupConfigArray.length === 1 && config && groupConfigArray[0].column === config.indexBy) {
        // if single and indexBy column
        return _singleSortedPivot(data, schema, config, groupConfigArray[0], aggrConfigArray, pivotCol);
      }
      // OR, unsorted single/multiple columns
      return _genericPivot(data, schema, config, generatorFn, groupConfigArray, aggrConfigArray, pivotCol);
    }
  };
}

/**
 * Takes the group config, aggregation config arrays and the pivot column name,
 * and creates and returns a schema from the two.
 *
 * @param {array} data The datatable being operated on
 * @param {array} schema The schema
 * @param {array} _groupConfig The group configuration array
 * @param {array} _aggrConfig The aggregation configuration array
 * @param {object} pivotColumn The column on which to pivot
 */
function _createAggrSchema (data, schema, _groupConfig, _aggrConfig, pivotColumn) {
  var newSchema = [], comparator, uniquePivotItems, uniquePivotLength, pivotColumns = {}, groupConfigLength, aggrConfigLength,
    columnIndex, column, type, aggregatorFn, aggrColName, i, j, count = 0, operation, newColumn,
    groupConfig = _groupConfig,
    aggrConfig = _aggrConfig;

  groupConfig = groupConfig instanceof Array ? groupConfig : [groupConfig];
  aggrConfig = aggrConfig instanceof Array ? aggrConfig : [aggrConfig];

  groupConfigLength = groupConfig.length;
  aggrConfigLength = aggrConfig.length;

  // add the group columns in new schema
  for (i = 0; i < groupConfigLength; i++) {
    columnIndex = columnIndexOf(groupConfig[i].column, schema);
    column = schema[columnIndex];

    if (columnIndex === -1) throw new Error('incorrect column name in groupConfigArr - ' + groupConfig[i].column);

    newColumn = {
      name: groupConfig[i].outputAs || groupConfig[i].column,
      type: column.type === FieldType.DateTime ? FieldType.Interval : column.type
    };
    if (typeof column.enableUTC !== 'undefined') {
      newColumn.enableUTC = column.enableUTC;
    }
    newSchema.push(newColumn);
  }

  switch (pivotColumn.type) {
    case FieldType.Number:
    case FieldType.DateTime:
      // we will not be dealing with interval column
      // interval is only an intermediate column and not exposed
      // and user will only be feeding exterbal data to data store
      // but for children data table we must deal with interval column
      comparator = numberComparator;
      break;
    default:
      comparator = stringComparator;
      break;
  }

  // get unique pivot values
  uniquePivotItems = columnUnique(pivotColumn.name, data, schema);
  uniquePivotItems.sort((a, b) => comparator(a, b));
  uniquePivotLength = uniquePivotItems.length;

  for (i = 0; i < aggrConfigLength; i++) {
    // default operation is avg
    operation = aggrConfig[i].operation || 'avg';
    columnIndex = columnIndexOf(aggrConfig[i].column, schema);
    column = schema[columnIndex];

    if (columnIndex === -1) throw new Error('incorrect column name in aggrConfigArr - ' + aggrConfig[i].column);

    aggregatorFn = aggregatorStore.resolve(operation);
    if (!aggregatorFn) throw new Error(`${operation} is not a defined operation`);

    // if operation is first or last then inherit from schema's column
    // if it's count, type will be number
    // rest are all numeric operations
    // however, if the column type is not numeric, throw an error
    switch (operation) {
      case 'first':
      case 'last':
        type = column.type;
        break;
      case 'count':
        type = FieldType.Number;
        break;
      default:
        if (column.type !== FieldType.Number) throw new Error(`${operation} can apply only on numbers`);
        type = FieldType.Number;
    }

    for (j = 0; j < uniquePivotLength; j++) {
      aggrColName = uniquePivotItems[j] + ' - ' + (aggrConfig[i].outputAs || (aggrConfig[i].column + (operation ? ' - ' + operation : '')));
      pivotColumns[aggrColName] = count++;

      newSchema.push({
        name: aggrColName,
        type: type
      });
    }
  }

  return {
    schema: newSchema,
    pivots: pivotColumns
  };
}

/**
 * Performs group by on a single column.
 *
 * @param {array} data The datatable being operated on
 * @param {array} schema The schema
 * @param {array} groupConfig The group configuration array
 * @param {array} aggrConfig The aggregation configuration array
 * @param {string} pivotName The column name on which to pivot
 */
function _singleSortedPivot (data, schema, config, groupConfig, aggrConfig, pivotName) {
  var newData = [],
    newSchema = [],
    pivotColumns = {},
    schemaResult,
    dataLength = data.length,
    groupColumnIndex,
    groupColumn,
    pivotColumnIndex,
    pivotColumn,
    maxDate,
    groupConfigCopy,
    timeDuration,
    startValFloorVal,
    startPos = 0,
    lastEntry,
    cacheColumnIndex = _cacheColumnIndex(),
    cacheGroupCount = [],
    newDataLength,
    enableUTC,
    i;

  groupColumnIndex = columnIndexOf(groupConfig.column, schema);
  if (groupColumnIndex === -1) throw new Error('incorrect column name in groupConfigArr - ' + groupConfig);

  pivotColumnIndex = columnIndexOf(pivotName, schema);
  if (pivotColumnIndex === -1) throw new Error('incorrect pivot column name');

  groupColumn = schema[groupColumnIndex];
  pivotColumn = schema[pivotColumnIndex];

  groupConfigCopy = Object.assign({}, groupConfig);

  // prepare the schema
  groupConfigCopy.type = groupColumn.type;
  groupConfigCopy.outputAs = groupConfig.outputAs;
  schemaResult = _createAggrSchema(data, schema, groupConfigCopy, aggrConfig, pivotColumn);
  newSchema = schemaResult.schema;
  pivotColumns = schemaResult.pivots;

  if (dataLength > 0) {
    enableUTC = groupColumn.enableUTC || getConfig('enableUTC');

    // if it's a date column,
    //  create a duration object
    //  if startValue is present/number, else use first row's datetime
    //    get the start value of the dataset
    if (groupColumn.type === FieldType.DateTime) {
      let peaks, minDate, startValue;
      timeDuration = duration(groupConfig.timeUnit, Math.abs(groupConfig.binSize) || 1);
      if (!data[0] || !data[0][groupColumnIndex] || !data[dataLength - 1] || !data[dataLength - 1][groupColumnIndex]) {
        peaks = columnExtents(groupConfig.column, data, schema, config.indexBy);
      }
      minDate = (data[0] && data[0][groupColumnIndex]) || peaks.min;
      startValue = groupConfig.startValue && parseInt(groupConfig.startValue, 10);
      if (startValue) {
        if (startValue >= minDate) {
          let comparer = (a, b) => numberComparator(a[groupColumnIndex], b);
          // if start value falls on or after the minimum date in dataset, then floor it to unit with binning 1
          startValFloorVal = getDateStart(startValue, duration(groupConfig.timeUnit, 1), enableUTC, groupConfig.weekStartFrom);
          // get the index of left most occurrence
          startPos = leftMostExactOrGreater(startValFloorVal, data, comparer, 0, data.length);
        } else {
          // if start value falls before the minimum date in dataset, then floor the minimum to date unit with binning binSize
          startValFloorVal = getDateStart(minDate, timeDuration, enableUTC, groupConfig.weekStartFrom, startValue);
        }
      } else {
        // if start value absent, then floor the minimum to date unit with binning 1
        startValFloorVal = getDateStart(minDate, duration(groupConfig.timeUnit, 1), enableUTC, groupConfig.weekStartFrom);
      }
      maxDate = (data[dataLength - 1] && data[dataLength - 1][groupColumnIndex]) || peaks.max;
    }

    // if start value is less than maxdate only then proceed
    if (typeof startValFloorVal === 'undefined' || startValFloorVal <= maxDate) {
      let intervalConfig = {
        duration: timeDuration,
        outputFormat: groupConfig.outputFormat,
        enableUTC: enableUTC,
        weekStartFrom: groupConfig.weekStartFrom
      };
      if (typeof startValFloorVal !== 'undefined') {
        // if no entry in new data array, create new interval entry,
        // add it to new data array and return it
        lastEntry = [interval(startValFloorVal, intervalConfig)];
        newData.push(lastEntry);
      }
      for (i = startPos; i < dataLength; i++) {
        if (data[i].length > 0) {
          // date field
          // OR, string field OR, number field with binning 1
          if (groupColumn.type === FieldType.DateTime) {
            lastEntry = _singleSortedAddRowDate(newData, lastEntry, data[i][groupColumnIndex], intervalConfig, startValFloorVal);
          } else if (groupColumn.type === FieldType.String || groupColumn.type === FieldType.Number) {
            lastEntry = _singleSortedAddRow(newData, lastEntry, data[i][groupColumnIndex]);
          }

          newDataLength = newData.length - 1;

          // init the cacheGroupCount current row with an empty object before aggregation
          cacheGroupCount[newDataLength] = cacheGroupCount[newDataLength] || {};
          lastEntry && _applyAggr(data[i], schema, lastEntry, 1, aggrConfig, pivotColumnIndex, pivotColumns, cacheColumnIndex, cacheGroupCount[newDataLength]);
        }
      }
    }
  }

  return {
    data: newData,
    schema: newSchema,
    config: { indexBy: (groupConfig.outputAs || groupConfig.column) }
  };
}

/**
 * Performs group by on unsorted/multiple column data.
 *
 * @param {array} data The datatable being operated on
 * @param {array} schema The schema
 * @param {object} config The config object
 * @param {object} generatorFn
 * @param {array} groupConfigArr The group configuration array
 * @param {array} aggrConfigArr The aggregation configuration array
 * @param {string} pivotColumn The column name on which to pivot
 */
function _genericPivot (data, schema, config, generatorFn, groupConfigArr, aggrConfigArr, pivotColumn) {
  let groupOps,
    groupedData,
    comparator,
    pivotUnique,
    pivotUniqueSorted,
    groupedSchemaWithoutPivot,
    pivotColIndex,
    groupedSchemaLen,
    groupConfigColumns,
    groupColMap = {},
    hashTable = {},
    _getRowIndex = (hashKey) => {
      if ({}.hasOwnProperty.call(hashTable, hashKey)) {
        return hashTable[hashKey];
      } return -1;
    },
    _insertNewKey = (hashKey, rowIndex) => {
      hashTable[hashKey] = rowIndex;
    },
    _getPivotAggrColName = (pivotCol, outputAs, aggrCol, aggrOps) => {
      return pivotCol + ' - ' + (outputAs || (aggrCol + (aggrOps ? ' - ' + aggrOps : '')));
    },
    _buildPivotSchema = () => {
      let newSchema = [],
        aggr;
      for (let i = 0; i < groupedSchemaLen; i++) {
        // if column is one of group by column then directly copy the column config
        if (groupConfigColumns.includes(groupedSchemaWithoutPivot[i].name)) {
          newSchema.push(groupedSchemaWithoutPivot[i]);
          // build the column mapping for future use
          groupColMap[groupedSchemaWithoutPivot[i].name] = i;
        } else {
          // if column is one of aggregation column then create a new name by prefixing the aggregation column name with the unique values of pivot columns

          /* eslint-disable no-loop-func */
          aggr = aggrConfigArr.filter(x => (x.outputAs || (x.column + (x.operation ? ' - ' + x.operation : ''))) === groupedSchemaWithoutPivot[i].name)[0];
          // loop through all the unique values and create a column for each combination
          for (let j = 0; j < pivotUniqueSorted.length; j++) {
            newSchema.push({
              name: _getPivotAggrColName(pivotUniqueSorted[j], aggr.outputAs, aggr.column, aggr.operation),
              type: groupedSchemaWithoutPivot[i].type
            });
          }
        }
      }
      return newSchema;
    },
    _buildPivotData = (newSchema) => {
      let pivotData = [],
        columnLen = newSchema.length,
        newSchemaColMap = {},
        i, j, rowIndex, aggr, rowMapIndex, rowMap = {},
        hashKey = EMPTY_STR;
      // build the mapping of key value pair where key is the column name of new schema and value is the index of data
      for (i = 0; i < columnLen; i++) {
        newSchemaColMap[newSchema[i].name] = i;
      }

      // loop through all data of grouped result set to build the pivot
      for (i = 0; i < groupedData.data.length; i++) {
        rowMap = {};
        hashKey = EMPTY_STR;

        for (j = 0; j < groupedData.schema.length; j++) {
          // previously group col map was built which contains all columns of original group by
          // if column is one of the group by column then create the hashkey using the column value
          if ({}.hasOwnProperty.call(groupColMap, groupedData.schema[j].name)) {
            // a row map is created for the curret row where key is index of column
            rowMap[newSchemaColMap[groupedData.schema[j].name]] = groupedData.data[i][j];

            // build the hashkey
            if (groupedData.schema[j].type === FieldType.Interval) {
              hashKey += groupedData.data[i][j].start;
            } else {
              hashKey += groupedData.data[i][j];
            }
          } else if (groupedData.schema[j].name !== pivotColumn) { // do not take any action for pivot column
            // for all aggregation column we combine the aggregation column with the pivot column value
            // fine the proper column index where it should be inserted and insert the value in row map

            aggr = aggrConfigArr.filter(x => (x.outputAs || (x.column + (x.operation ? ' - ' + x.operation : ''))) === groupedData.schema[j].name)[0];
            rowMapIndex = newSchemaColMap[_getPivotAggrColName(groupedData.data[i][pivotColIndex], aggr.outputAs, aggr.column, aggr.operation)];
            if (rowMapIndex) rowMap[rowMapIndex] = groupedData.data[i][j];
          }
        }

        // check if row already exists
        rowIndex = _getRowIndex(hashKey);
        if (rowIndex > -1) { // if row already exists and just need to update pivot aggregation value
          let row = pivotData[rowIndex];

          for (let index in rowMap) {
            row[index] = rowMap[index];
          }
        } else { // if row does not exist
          // create an array of exact schema length
          let row = new Array(columnLen);

          // insert all values at proper place, keeping the missing values as undefined
          // missing values may be filled up at later phase
          for (let index in rowMap) {
            row[index] = rowMap[index];
          }

          // insert the row
          pivotData.push(row);
          // insert the row index at hash table
          _insertNewKey(hashKey, pivotData.length - 1);
        }
      }
      return pivotData;
    },
    pivotSchema = [],
    pivotData = [];

  groupOps = groupBy(groupConfigArr.concat({ column: pivotColumn }), aggrConfigArr);
  groupedData = groupOps.fn(data, schema, config, generatorFn);
  pivotUnique = columnUnique(pivotColumn, data, schema);
  pivotColIndex = columnIndexOf(pivotColumn, groupedData.schema);
  switch (groupedData.schema[pivotColIndex].type) {
    case FieldType.Number:
    case FieldType.DateTime:
      // we will not be dealing with interval column
      // interval is only an intermediate column and not exposed
      // and user will only be feeding exterbal data to data store
      // but for children data table we must deal with interval column
      comparator = numberComparator;
      break;
    default:
      comparator = stringComparator;
      break;
  }
  pivotUniqueSorted = (pivotUnique && pivotUnique.sort((a, b) => comparator(a, b))) || [];
  groupedSchemaWithoutPivot = groupedData.schema.filter(x => x.name !== pivotColumn);
  groupedSchemaLen = groupedSchemaWithoutPivot.length;
  groupConfigColumns = groupConfigArr.map(x => x.outputAs || x.column);

  pivotSchema = _buildPivotSchema();

  if (groupedData.data.length > 0) {
    pivotData = _buildPivotData(pivotSchema);
  }

  return {
    data: pivotData,
    schema: pivotSchema,
    config: { indexBy: (groupedData.config.indexBy === pivotColumn) ? UNDEF : groupedData.config.indexBy }
  };
}

/**
 * Caches the column's index in the original data schema.
 */
function _cacheColumnIndex () {
  let cache = {};
  return function (columnName, schema) {
    if (!cache[columnName]) {
      cache[columnName] = columnIndexOf(columnName, schema);
    }
    return cache[columnName];
  };
}

/**
 * Perform aggregation operation on given aggregation configuration and a data row.
 *
 * @param {array} dataRow The datatable row being operated on
 * @param {array} schema The schema
 * @param {array} lastEntry The last entry in the new data array
 * @param {number} entryIndex The entry index for the aggregated columns in the row, after the group columns
 * @param {array} aggrConfig The aggregation configuration array
 * @param {number} pivotColumnIndex The index of the pivot column in data
 * @param {object} pivotColumns The list of unique pivot column values mapped to their index
 * @param {function} cacheColumnIndex The reference to the caching function for column indices
 * @param {object} cacheGroupCountRow The current row in the cache group count column
 */
function _applyAggr (dataRow, schema, lastEntry, entryIndex, aggrConfig, pivotColumnIndex, pivotColumns, cacheColumnIndex, cacheGroupCountRow) {
  let aggrConfigLength = aggrConfig.length, columnIndex, operation, count, i, index;

  for (i = 0; i < aggrConfigLength; i++) {
    columnIndex = cacheColumnIndex(aggrConfig[i].column, schema);
    if (typeof dataRow[columnIndex] !== 'undefined' && dataRow[columnIndex] !== null) {
      // default operation is avg
      operation = aggrConfig[i].operation || 'avg';
      index = pivotColumns[dataRow[pivotColumnIndex] + ' - ' + (aggrConfig[i].outputAs || (aggrConfig[i].column + (operation ? ' - ' + operation : '')))];

      // for the below operations, calculate and store the current count of the column values in the group, in the cacheGroupCount and count
      switch (operation) {
        case 'sum':
        case 'min':
        case 'max':
        case 'first':
        case 'last':
          count = null;
          break;

        default:
          count = cacheGroupCountRow[index] = (cacheGroupCountRow[index] && (cacheGroupCountRow[index] + 1)) || 1;
          break;
      }

      // for operation other than count, calculate the aggregated value and add to the last entered row
      lastEntry[entryIndex + index] = operation === 'count' ? count : aggregatorStore.resolve(operation)(typeof lastEntry[entryIndex + index] !== 'undefined' ? lastEntry[entryIndex + index] : null, dataRow[columnIndex], count);
    }
  }
}

export default pivot;
