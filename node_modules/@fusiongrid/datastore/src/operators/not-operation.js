import { OperatorTypes } from '../enums';
import { columnIndexOf } from '../utils/datatable-utils';
import { ROW_ID_COL_NAME } from '../globals/defaults';

function not (operation) {
  return {
    ops: 'not',
    type: OperatorTypes.LogicalOps,
    fn: (_data, schema, config, generatorFn) => {
      if (!operation) {
        throw new Error('Operation to perform not is missing');
      }

      if (typeof operation.type === 'undefined') {
        throw new Error('Invlid operation is used for not operation');
      }

      if (operation.type > 2) {
        throw new Error('Not operations can only be performed with filters or other logical operations');
      }

      let data = typeof generatorFn === 'function' ? generatorFn() : _data;
      const genFn = () => {
        let opsData, isRowIdInserted = false,
          row_id_index = columnIndexOf(ROW_ID_COL_NAME, schema), result;

        const opsFn = operation.fn(data, schema, config),
          matched_row_id_set = new Set();

        // retrieve the result of operation passed inside not function
        opsData = typeof opsFn.generatorFn === 'function' ? opsFn.generatorFn() : opsFn.data;

        // row id should always be present, but in case user forcefully remove the row id by select operation
        // then add the id
        if (row_id_index < 0) {
          for (let i = 0; i < opsData.length; i++) {
            opsData[i].push(i + 1);
          }
          row_id_index = schema.length;
          isRowIdInserted = true; // set a flag to remove the id later
        }

        // store all the unique row ids in a set
        for (let i = 0; i < opsData.length; i++) {
          matched_row_id_set.add(opsData[i][row_id_index]);
        }

        // get those rows which are not matched by the operation passed in not function
        result = data.filter(x => !matched_row_id_set.has(x[row_id_index]));

        // if row id was inserted in earlier step then we need to move the row id from both result and data
        if (isRowIdInserted) {
          result = result.map(x => x.slice(0, row_id_index));
          data = data.map(x => x.slice(0, row_id_index));
        }

        return result;
      };

      return {
        data,
        schema,
        config,
        generatorFn: genFn
      };
    }
  };
}

export default not;